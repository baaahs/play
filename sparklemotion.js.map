{"version":3,"file":"sparklemotion.js","sources":["../../../../../src/commonMain/kotlin/baaahs/Brain.kt","kotlin/math.kt","collections/Sets.kt","collections/Maps.kt","collections/Collections.kt","kotlin/collections.kt","generated/_Collections.kt","../../../../../src/commonMain/kotlin/baaahs/Mapper.kt","comparisons/Comparisons.kt","kotlin/Comparator.kt","../../../../../src/commonMain/kotlin/baaahs/Pinky.kt","util/Standard.kt","text/Strings.kt","kotlin/text/numberConversions.kt","kotlin/ranges.kt","generated/_ArraysJs.kt","../../../../../src/commonMain/kotlin/baaahs/io/ByteArrayReader.kt","generated/_Arrays.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/MapperClient.kt","arrayUtils.kt","../../../../../src/commonMain/kotlin/baaahs/shows/PanelTweenShow.kt","../../../../../src/jsMain/kotlin/baaahs/SheepSimulator.kt","../../../../../src/jsMain/kotlin/baaahs/glsl/JsGlsl.kt","../../../../../src/commonMain/kotlin/baaahs/BeatData.kt","../../../../../../../../dummy.kt","../../../../../src/commonMain/kotlin/baaahs/Color.kt","kotlin/text/string.kt","../../../../../src/commonMain/kotlin/baaahs/Config.kt","../../../../../src/commonMain/kotlin/baaahs/Display.kt","../../../../../src/commonMain/kotlin/baaahs/Dmx.kt","../../../../../src/commonMain/kotlin/baaahs/FirmwareDaddy.kt","../../../../../src/commonMain/kotlin/baaahs/Gadget.kt","generated/_Maps.kt","../../../../../src/commonMain/kotlin/baaahs/GadgetManager.kt","../../../../../src/commonMain/kotlin/baaahs/MediaDevices.kt","../../../../../src/commonMain/kotlin/baaahs/MovingHead.kt","../../../../../src/commonMain/kotlin/baaahs/MovingHeadManager.kt","../../../../../src/commonMain/kotlin/baaahs/PubSub.kt","../../../../../src/commonMain/kotlin/baaahs/Shaders.kt","util/Lazy.kt","../../../../../src/commonMain/kotlin/baaahs/SheepModel.kt","../../../../../src/commonMain/kotlin/baaahs/Show.kt","../../../../../src/commonMain/kotlin/baaahs/ShowRunner.kt","collections/MutableCollections.kt","../../../../../src/commonMain/kotlin/baaahs/SparkleMotion.kt","../../../../../src/commonMain/kotlin/baaahs/Surface.kt","../../../../../src/commonMain/kotlin/baaahs/Topics.kt","../../../../../src/commonMain/kotlin/baaahs/dmx/LixadaMiniMovingHead.kt","../../../../../src/commonMain/kotlin/baaahs/dmx/Shenzarpy.kt","../../../../../src/commonMain/kotlin/baaahs/gadgets/ColorPicker.kt","../../../../../src/commonMain/kotlin/baaahs/gadgets/PalettePicker.kt","../../../../../src/commonMain/kotlin/baaahs/gadgets/Slider.kt","../../../../../src/commonMain/kotlin/baaahs/geom/Matrix4.kt","../../../../../src/commonMain/kotlin/baaahs/geom/Vector2F.kt","../../../../../src/commonMain/kotlin/baaahs/geom/Vector3F.kt","../../../../../src/commonMain/kotlin/baaahs/glsl/GlslBase.kt","../../../../../src/commonMain/kotlin/baaahs/imaging/Imaging.kt","kotlin/numbers.kt","../../../../../src/commonMain/kotlin/baaahs/io/ByteArrayWriter.kt","../../../../../src/commonMain/kotlin/baaahs/io/Fs.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/DateTimeSerializer.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/ImageProcessing.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/MapperEndpoint.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/MappingResults.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/MappingSession.kt","../../../../../src/commonMain/kotlin/baaahs/mapper/Storage.kt","../../../../../src/commonMain/kotlin/baaahs/net/FragmentingUdpLink.kt","../../../../../src/commonMain/kotlin/baaahs/net/Network.kt","../../../../../src/commonMain/kotlin/baaahs/proto/Protocol.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/CompositorShader.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/GlslShader.kt","text/regex/MatchResult.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/HeartShader.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/PixelShader.kt","kotlin/kotlin.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/RandomShader.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/SimpleSpatialShader.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/SineWaveShader.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/SolidShader.kt","../../../../../src/commonMain/kotlin/baaahs/shaders/SparkleShader.kt","../../../../../src/commonMain/kotlin/baaahs/shows/AllShows.kt","../../../../../src/commonMain/kotlin/baaahs/shows/CompositeShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/CreepingPixelsShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/GlslShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/HeartbleatShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/LifeyShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/PixelTweenShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/RandomShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/SimpleSpatialShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/SolidColorShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/SomeDumbShow.kt","../../../../../src/commonMain/kotlin/baaahs/shows/ThumpShow.kt","../../../../../src/commonMain/kotlin/baaahs/sim/FakeDmxUniverse.kt","../../../../../src/commonMain/kotlin/baaahs/sim/FakeFs.kt","../../../../../src/commonMain/kotlin/baaahs/sim/FakeNetwork.kt","../../../../../src/commonMain/kotlin/baaahs/util.kt","../../../../../src/jsMain/kotlin/baaahs/JsDisplay.kt","org.w3c/org.w3c.dom.kt","../../../../../src/jsMain/kotlin/baaahs/JsMapperUi.kt","../../../../../src/jsMain/kotlin/baaahs/Launcher.kt","../../../../../src/jsMain/kotlin/baaahs/View.kt","../../../../../src/jsMain/kotlin/baaahs/WebUi.kt","../../../../../src/jsMain/kotlin/baaahs/browser/RealMediaDevices.kt","org.w3c/org.w3c.dom.mediacapture.kt","../../../../../src/jsMain/kotlin/baaahs/geom/Vector2.kt","org.w3c/org.khronos.webgl.kt","../../../../../src/jsMain/kotlin/baaahs/imaging/JsImaging.kt","../../../../../src/jsMain/kotlin/baaahs/jsImpl.kt","../../../../../src/jsMain/kotlin/baaahs/net/BrowserNetwork.kt","../../../../../src/jsMain/kotlin/baaahs/net/BrowserUdpProxy.kt","../../../../../src/jsMain/kotlin/baaahs/sim/FakeMediaDevices.kt","../../../../../src/jsMain/kotlin/baaahs/util.kt","../../../../../src/jsMain/kotlin/baaahs/visualizer/SwirlyPixelArranger.kt","../../../../../src/jsMain/kotlin/baaahs/visualizer/Visualizer.kt","../../../../../src/jsMain/kotlin/baaahs/visualizer/VizPanel.kt","../../../../../src/jsMain/kotlin/baaahs/visualizer/util.kt"],"sourcesContent":["package baaahs\n\nimport baaahs.geom.Vector3F\nimport baaahs.io.ByteArrayReader\nimport baaahs.net.FragmentingUdpLink\nimport baaahs.net.Network\nimport baaahs.proto.*\nimport kotlinx.coroutines.delay\n\nclass Brain(\n    val id: String,\n    private val network: Network,\n    private val display: BrainDisplay,\n    private val pixels: Pixels\n) : Network.UdpListener {\n    private lateinit var link: Network.Link\n    private lateinit var udpSocket: Network.UdpSocket\n    private var lastInstructionsReceivedAtMs: Long = 0\n    private var surfaceName : String? = null\n    private var surface : Surface = AnonymousSurface(BrainId(id))\n        set(value) { field = value; display.surface = value }\n    private var currentShaderDesc: ByteArray? = null\n    private var currentRenderTree: RenderTree<*>? = null\n\n    suspend fun run() {\n        link = FragmentingUdpLink(network.link())\n        udpSocket = link.listenUdp(Ports.BRAIN, this)\n\n        display.id = id\n        display.haveLink(link)\n        display.onReset = {\n            println(\"Resetting Brain $id!\")\n            reset()\n        }\n\n        sendHello()\n    }\n\n    private suspend fun reset() {\n        lastInstructionsReceivedAtMs = 0\n        surfaceName = null\n        surface = AnonymousSurface(BrainId(id))\n        currentShaderDesc = null\n        currentRenderTree = null\n\n        for (i in pixels.indices) pixels[i] = Color.WHITE\n\n        sendHello()\n    }\n\n    /**\n     * So that the JVM standalone can boot up and have a surface name without mapping\n     */\n    fun forcedSurfaceName(name: String) {\n        surfaceName = name\n    }\n\n    private suspend fun sendHello() {\n        while (true) {\n            val elapsedSinceMessageMs = getTimeMillis() - lastInstructionsReceivedAtMs\n            if (elapsedSinceMessageMs > 10000) {\n                if (lastInstructionsReceivedAtMs != 0L) {\n                    logger.info { \"$id: haven't heard from Pinky in ${elapsedSinceMessageMs}ms\" }\n                }\n                udpSocket.broadcastUdp(Ports.PINKY, BrainHelloMessage(id, surfaceName))\n            }\n\n            delay(5000)\n        }\n    }\n\n    override fun receive(fromAddress: Network.Address, fromPort: Int, bytes: ByteArray) {\n        val now = getTimeMillis()\n        lastInstructionsReceivedAtMs = now\n\n        val reader = ByteArrayReader(bytes)\n\n        // Inline message parsing here so we can optimize stuff.\n        val type = Type.get(reader.readByte())\n        // println(\"Got a message of type ${type}\")\n        when (type) {\n            Type.BRAIN_PANEL_SHADE -> {\n                val pongData = if (reader.readBoolean()) { reader.readBytes() } else { null }\n                val shaderDesc = reader.readBytes()\n\n                // If possible, use the previously-built Shader stuff:\n                val theCurrentShaderDesc = currentShaderDesc\n                if (theCurrentShaderDesc == null || !theCurrentShaderDesc.contentEquals(shaderDesc)) {\n                    currentShaderDesc = shaderDesc\n\n                    @Suppress(\"UNCHECKED_CAST\")\n                    val shader = Shader.parse(ByteArrayReader(shaderDesc)) as Shader<Shader.Buffer>\n                    currentRenderTree = RenderTree(\n                        shader,\n                        shader.createRenderer(surface),\n                        shader.createBuffer(surface)\n                    )\n                }\n\n                with(currentRenderTree!!) {\n                    read(reader)\n                    draw(pixels)\n                }\n\n                if (pongData != null) {\n                    udpSocket.sendUdp(fromAddress, fromPort, PingMessage(pongData, true))\n                }\n\n            }\n\n            Type.BRAIN_ID_REQUEST -> {\n                udpSocket.sendUdp(fromAddress, fromPort, BrainHelloMessage(id, surfaceName))\n            }\n\n            Type.BRAIN_MAPPING -> {\n                val message = BrainMappingMessage.parse(reader)\n                surfaceName = message.surfaceName\n                surface = if (message.surfaceName != null) {\n                    val fakeModelSurface = FakeModelSurface(message.surfaceName)\n                    IdentifiedSurface(fakeModelSurface, message.pixelCount, message.pixelLocations)\n                } else {\n                    AnonymousSurface(BrainId(id))\n                }\n\n                // next frame we'll need to recreate everything...\n                currentShaderDesc = null\n                currentRenderTree = null\n\n                udpSocket.broadcastUdp(Ports.PINKY, BrainHelloMessage(id, surfaceName))\n            }\n\n            Type.PING -> {\n                val ping = PingMessage.parse(reader)\n                if (!ping.isPong) {\n                    udpSocket.sendUdp(fromAddress, fromPort, PingMessage(ping.data, isPong = true))\n                }\n            }\n\n            // Other message types are ignored by Brains.\n            else -> {\n                // no-op\n            }\n        }\n    }\n\n    class RenderTree<B : Shader.Buffer>(val shader: Shader<B>, val renderer: Shader.Renderer<B>, val buffer: B) {\n        fun read(reader: ByteArrayReader) = buffer.read(reader)\n\n        fun draw(pixels: Pixels) {\n            renderer.beginFrame(buffer, pixels.size)\n            for (i in pixels.indices) {\n                pixels[i] = renderer.draw(buffer, i)\n            }\n            renderer.endFrame()\n            pixels.finishedFrame()\n        }\n    }\n\n    class FakeModelSurface(override val name: String, override val description: String = name) : Model.Surface {\n        override fun allVertices(): Collection<Vector3F> = emptyList()\n    }\n\n    companion object {\n        val logger = Logger(\"Brain\")\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [LinkedHashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package baaahs\n\nimport baaahs.geom.Matrix4\nimport baaahs.geom.Vector2F\nimport baaahs.geom.Vector3F\nimport baaahs.imaging.Bitmap\nimport baaahs.imaging.Image\nimport baaahs.imaging.NativeBitmap\nimport baaahs.mapper.ImageProcessing\nimport baaahs.mapper.MapperClient\nimport baaahs.mapper.MappingSession\nimport baaahs.net.FragmentingUdpLink\nimport baaahs.net.Network\nimport baaahs.proto.*\nimport baaahs.shaders.PixelShader\nimport baaahs.shaders.SolidShader\nimport com.soywiz.klock.DateTime\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel\nimport kotlin.random.Random\n\nclass Mapper(\n    private val network: Network,\n    sheepModel: SheepModel,\n    private val mapperUi: MapperUi,\n    private val mediaDevices: MediaDevices,\n    private val pinkyAddress: Network.Address\n) : Network.UdpListener, MapperUi.Listener, CoroutineScope by MainScope() {\n    private val maxPixelsPerBrain = SparkleMotion.MAX_PIXEL_COUNT\n\n    // TODO: getCamera should just return max available size?\n    lateinit var camera: MediaDevices.Camera\n\n    private lateinit var link: Network.Link\n    private lateinit var udpSocket: Network.UdpSocket\n    private lateinit var mapperClient: MapperClient\n    private var isRunning: Boolean = false\n    private var isPaused: Boolean = false\n    private var newIncomingImage: Image? = null\n\n    private var suppressShowsJob: Job? = null\n    private val brainsToMap: MutableMap<Network.Address, BrainToMap> = mutableMapOf()\n\n    private val activeColor = Color(0x07, 0xFF, 0x07)\n    private val inactiveColor = Color(0x01, 0x00, 0x01)\n\n    init {\n        mapperUi.listen(this)\n        mapperUi.addWireframe(sheepModel)\n    }\n\n    fun start() = doRunBlocking {\n        link = FragmentingUdpLink(network.link())\n        udpSocket = link.listenUdp(0, this)\n        mapperClient = MapperClient(link, pinkyAddress)\n\n        launch {\n            mapperClient.listSessions().forEach { mapperUi.addExistingSession(it) }\n        }\n    }\n\n    override fun onStart() {\n        isPaused = false\n\n        if (!isRunning) {\n            camera = mediaDevices.getCamera().apply { onImage = { image -> haveImage(image) } }\n\n            // Restart.\n            isRunning = true\n            launch { startNewSession() }\n        }\n    }\n\n    override fun onPause() {\n        isPaused = true\n    }\n\n    override fun onStop() {\n        onClose()\n    }\n\n    override fun onClose() {\n        logger.info { \"Shutting down Mapper...\" }\n        isRunning = false\n        camera.close()\n\n        suppressShowsJob?.cancel()\n        udpSocket.broadcastUdp(Ports.PINKY, MapperHelloMessage(false))\n\n        mapperUi.close()\n    }\n\n    suspend fun startNewSession() {\n        mapperUi.showMessage(\"ESTABLISHING UPLINK\u2026\")\n\n        // shut down Pinky, advertise for Brains...\n        retry {\n            udpSocket.broadcastUdp(Ports.PINKY, MapperHelloMessage(true))\n            delay(1000L)\n            udpSocket.broadcastUdp(Ports.BRAIN, solidColor(inactiveColor))\n        }\n\n        // keep Pinky from waking up while we're running...\n        suppressShows()\n\n        // wait for responses from Brains\n        pauseForUserInteraction(\"PRESS PLAY WHEN ALL SURFACES ARE GREEN\")\n        val brainIdRequestJob = coroutineScope {\n            launch {\n                while (isPaused) {\n                    udpSocket.broadcastUdp(Ports.BRAIN, BrainIdRequest())\n                    delay(1000L)\n                }\n            }\n        }\n\n        mapperUi.showMessage(\"${brainsToMap.size} SURFACES DISCOVERED!\")\n        waitUntilUnpaused()\n        brainIdRequestJob.cancelAndJoin()\n\n        if (brainsToMap.isEmpty()) {\n            mapperUi.showMessage(\"NO SURFACES DISCOVERED! TRY AGAIN!\")\n            isRunning = false\n            return\n        }\n\n        mapperUi.showMessage(\"READY PLAYER ONE\u2026\")\n        pauseForUserInteraction(\"ALIGN MODEL AND PRESS PLAY WHEN READY\")\n        waitUntilUnpaused()\n\n        Session().start()\n    }\n\n    inner class Session {\n        val sessionStartTime = DateTime.now()\n        val visibleSurfaces = mapperUi.getVisibleSurfaces()\n        private var baseBitmap: Bitmap? = null\n        val cameraOrientation = mapperUi.lockUi()\n        lateinit var deltaBitmap: Bitmap\n\n        val pixelShader = PixelShader(PixelShader.Encoding.INDEXED_2)\n        val pixelShaderBuffer = pixelShader.createBuffer(object : Surface {\n            override val pixelCount = SparkleMotion.MAX_PIXEL_COUNT\n\n            override fun describe(): String = \"Mapper surface\"\n        }).apply {\n            palette[0] = Color.BLACK\n            palette[1] = Color.WHITE\n            setAll(0)\n        }\n\n        fun resetToBase() {\n            pixelShaderBuffer.setAll(0)\n        }\n\n        suspend fun allPixelsOff() {\n            resetToBase()\n            sendToAllReliably(pixelShaderBuffer)\n        }\n\n        suspend fun turnOnPixel(pixelIndex: Int) {\n            resetToBase()\n            pixelShaderBuffer[pixelIndex] = 1\n            sendToAllReliably(pixelShaderBuffer)\n        }\n\n        suspend fun start() {\n            mapperUi.showMessage(\"CALIBRATING\u2026\")\n            logger.info { \"Visible surfaces: ${visibleSurfaces.joinToString { it.modelSurface.name }}\" }\n\n            // Blackout for base image.\n            sendToAllReliably(solidColorBuffer(inactiveColor))\n            delay(1000L) // wait for focus\n\n            // Create base image from the brightest of a few samples.\n            val bitmap = getBrightImageBitmap(5)\n            baseBitmap = bitmap\n            deltaBitmap = NativeBitmap(bitmap.width, bitmap.height)\n\n            val baseImageName = mapperClient.saveImage(sessionStartTime, \"base\", bitmap)\n\n            mapperUi.showMessage(\"MAPPING\u2026\")\n            mapperUi.showStats(brainsToMap.size, 0, -1)\n\n            try {\n                logger.info { \"identify surfaces...\" }\n                // light up each brain in an arbitrary sequence and capture its delta...\n                brainsToMap.values.forEachIndexed { index, brainToMap ->\n                    identifyBrain(index, brainToMap)\n\n                    pauseForUserInteraction()\n\n                    var retryCount = 0\n                    mapperUi.setRedo {\n                        identifyBrain(index, brainToMap, ++retryCount)\n                    }\n\n                    waitUntilUnpaused()\n                    mapperUi.setRedo(null)\n\n                    deliverer.send(brainToMap, solidColorBuffer(inactiveColor))\n                    deliverer.await()\n                }\n\n                delay(1000L)\n\n//            mapperUi.showMessage(\"SEEKING LIMITS\u2026\")\n//            var maxPixel = 0\n                // binary search for highest present pixel 0..MAX_PIXEL_COUNT\u2026\n\n                logger.info { \"identify pixels...\" }\n                // light up each pixel...\n\n                // Turn all pixels off.\n                resetToBase()\n                sendToAllReliably(pixelShaderBuffer)\n                delay(1000L)\n\n                val pixelStep = 4\n                fun actualPixelIndex(pixelIndexX: Int) =\n                    pixelIndexX * pixelStep % maxPixelsPerBrain + pixelIndexX * pixelStep / maxPixelsPerBrain\n\n\n                for (pixelIndexX in 0 until maxPixelsPerBrain) {\n                    // Reorder so we get e.g. 0, 4, 8, ..., 1, 5, 9, ..., 2, 6, 10, ..., 3, 7, 11, ...\n                    val pixelIndex = actualPixelIndex(pixelIndexX)\n                    val nextPixelIndex = actualPixelIndex(pixelIndexX + 1)\n                    identifyPixel(pixelIndex, nextPixelIndex)\n\n//                    pauseForUserInteraction()\n                    waitUntilUnpaused()\n                    allPixelsOff()\n                }\n                logger.info { \"done identifying pixels...\" }\n\n                logger.info { \"done identifying things... $isRunning\" }\n                mapperUi.showMessage(\"++LEVEL UNLOCKED++\")\n\n                delay(1000L)\n            } catch (e: TimeoutException) {\n                mapperUi.showMessage(\"Timed out: ${e.message}\")\n                logger.error(\"Timed out\", e)\n            }\n\n            isRunning = false\n            mapperUi.unlockUi()\n\n            retry { udpSocket.broadcastUdp(Ports.PINKY, MapperHelloMessage(isRunning)) }\n\n            logger.info { \"Here's what we learned!\" }\n\n            val surfaces = mutableListOf<MappingSession.SurfaceData>()\n            brainsToMap.forEach { (address, brainToMap) ->\n                logger.info { \"Brain ID: ${brainToMap.brainId} at ${address}:\" }\n                logger.info { \"  Surface: ${brainToMap.guessedModelSurface}\" }\n                logger.debug { \"  Pixels:\" }\n\n                val visibleSurface = brainToMap.guessedVisibleSurface\n                if (visibleSurface != null) {\n                    visibleSurface.showPixels()\n\n                    brainToMap.pixelMapData.forEach { (pixelIndex, mapData) ->\n                        val changeRegion = mapData.pixelChangeRegion\n                        val position = visibleSurface.translatePixelToPanelSpace(\n                            changeRegion.centerX.toFloat(),\n                            changeRegion.centerY.toFloat()\n                        )\n                        logger.debug { \"    $pixelIndex -> ${position?.x},${position?.y}\" }\n                    }\n\n                    val pixels = visibleSurface.pixelsInModelSpace.mapIndexed { index, vector3F ->\n                        val pixelMapData = brainToMap.pixelMapData[index]\n                        val pixelChangeRegion = pixelMapData?.pixelChangeRegion\n                        val screenPosition = pixelChangeRegion?.let {\n                            visibleSurface.translatePixelToPanelSpace(it.centerX.toFloat(), it.centerY.toFloat())\n                        }\n                        MappingSession.SurfaceData.PixelData(\n                            vector3F,\n                            screenPosition,\n                            pixelMapData?.deltaImageName\n                        )\n                    }\n\n                    surfaces.add(\n                        MappingSession.SurfaceData(\n                            brainToMap.brainId,\n                            visibleSurface.modelSurface.name,\n                            pixels,\n                            brainToMap.deltaImageName,\n                            screenAreaInSqPixels = null,\n                            screenAngle = null\n                        )\n                    )\n                }\n            }\n\n            val mappingSession =\n                MappingSession(sessionStartTime.unixMillis, surfaces, cameraOrientation.cameraMatrix, baseImageName)\n            mapperClient.saveSession(mappingSession)\n        }\n\n        private suspend fun identifyPixel(pixelIndex: Int, nextPixelIndex: Int) {\n            mapperUi.showMessage(\"MAPPING PIXEL $pixelIndex / $maxPixelsPerBrain\u2026\")\n\n            if (pixelIndex % 128 == 0) logger.debug { \"pixel $pixelIndex... isRunning is $isRunning\" }\n            turnOnPixel(pixelIndex)\n\n            slowCamDelay()\n            val pixelOnBitmap = getBrightImageBitmap(2)\n\n            // turn off pixel now so it doesn't leak into next frame...\n            resetToBase()\n            sendToAll(pixelShaderBuffer) // we won't block here yet...\n\n            ImageProcessing.diff(pixelOnBitmap, baseBitmap!!, deltaBitmap)\n            mapperUi.showDiffImage(deltaBitmap)\n            val pixelOnImageName =\n                mapperClient.saveImage(sessionStartTime, \"pixel-$pixelIndex\", deltaBitmap)\n\n            brainsToMap.values.forEach { brainToMap ->\n                identifyBrainPixel(pixelIndex, brainToMap, pixelOnBitmap, deltaBitmap, pixelOnImageName)\n\n                delay(1)\n                //                    pauseForUserInteraction()\n                waitUntilUnpaused()\n            }\n\n            waitForDelivery() // ... of resetting to black above.\n        }\n\n        suspend fun identifyBrain(index: Int, brainToMap: BrainToMap, retryCount: Int = 0) {\n            mapperUi.showMessage(\"MAPPING SURFACE $index / ${brainsToMap.size} (${brainToMap.brainId})\u2026\")\n\n            deliverer.send(brainToMap, solidColorBuffer(activeColor))\n            deliverer.await()\n            slowCamDelay()\n\n            val surfaceOnBitmap = getBrightImageBitmap(3)\n            val surfaceAnalysis = ImageProcessing.diff(surfaceOnBitmap, baseBitmap!!, deltaBitmap)\n            val surfaceChangeRegion = surfaceAnalysis.detectChangeRegion(.25f)\n            logger.debug {\n                \"surfaceChangeRegion(${brainToMap.brainId}) =\" +\n                        \" $surfaceChangeRegion ${surfaceChangeRegion.width}x${surfaceChangeRegion.height}\"\n            }\n\n            mapperUi.showDiffImage(deltaBitmap, surfaceChangeRegion)\n\n            brainToMap.changeRegion = surfaceChangeRegion\n\n            val thresholdValue = surfaceAnalysis.thresholdValueFor(.25f)\n            //                val pxAboveThreshold = surfaceAnalysis.hist.sumValues(thresholdValue..255)\n            val sampleLocations = mutableListOf<Pair<Int, Int>>()\n            ImageProcessing.pixels(surfaceOnBitmap, surfaceChangeRegion) { x, y, value ->\n                if (value >= thresholdValue && Random.nextFloat() < .05f) {\n                    sampleLocations.add(x to y)\n                }\n            }\n\n            val surfaceBallot = Ballot<MapperUi.VisibleSurface>()\n            while (surfaceBallot.totalVotes < 10) {\n                val (x, y) = sampleLocations.random()!!\n                val visibleSurface = mapperUi.intersectingSurface(x, y, visibleSurfaces)\n                val surface = visibleSurface?.modelSurface\n                surface?.let {\n                    surfaceBallot.cast(surface.name, visibleSurface)\n                }\n            }\n\n            //                val orderedPanels = visibleSurfaces.map { visiblePanel ->\n            //                    visiblePanel to visiblePanel.boxOnScreen.distanceTo(surfaceChangeRegion)\n            //                }.sortedBy { it.second }\n            //\n            //                mapperUi.showCandidates(orderedPanels)\n            //\n            //                val firstGuess = orderedPanels.first().first\n            val firstGuess = surfaceBallot.winner()\n            val firstGuessSurface = firstGuess.modelSurface\n\n            mapperUi.showMessage(\"$index / ${brainsToMap.size}: ${brainToMap.brainId} \u2014\u00a0surface is ${firstGuessSurface.name}?\")\n            mapperUi.showMessage2(\"Candidate panels: ${surfaceBallot.summarize()}\")\n\n            logger.info { \"Guessed panel ${firstGuessSurface.name} for ${brainToMap.brainId}\" }\n            brainToMap.guessedModelSurface = firstGuessSurface\n            brainToMap.guessedVisibleSurface = firstGuess\n            brainToMap.panelDeltaBitmap = deltaBitmap.clone()\n            brainToMap.deltaImageName =\n                mapperClient.saveImage(sessionStartTime, \"brain-${brainToMap.brainId}-$retryCount\", deltaBitmap)\n        }\n\n        private fun identifyBrainPixel(\n            pixelIndex: Int,\n            brainToMap: BrainToMap,\n            pixelOnBitmap: Bitmap,\n            deltaBitmap: Bitmap,\n            pixelOnImageName: String\n        ) {\n            mapperUi.showMessage(\"MAPPING PIXEL $pixelIndex / $maxPixelsPerBrain (${brainToMap.brainId})\u2026\")\n            val surfaceChangeRegion = brainToMap.changeRegion\n            val visibleSurface = brainToMap.guessedVisibleSurface\n\n            if (surfaceChangeRegion != null && surfaceChangeRegion.sqPix() > 0 && visibleSurface != null) {\n                mapperUi.showAfter(brainToMap.panelDeltaBitmap!!)\n\n                val analysis = ImageProcessing.diff(\n                    pixelOnBitmap,\n                    baseBitmap!!,\n                    deltaBitmap,\n                    brainToMap.panelDeltaBitmap!!,\n                    surfaceChangeRegion\n                )\n                val pixelChangeRegion = analysis.detectChangeRegion(.5f)\n                logger.debug {\n                    \"pixelChangeRegion($pixelIndex,${brainToMap.guessedModelSurface?.name} =\" +\n                            \" $pixelChangeRegion ${pixelChangeRegion.width}x${pixelChangeRegion.height}\"\n                }\n\n                mapperUi.showDiffImage(deltaBitmap, pixelChangeRegion)\n                mapperUi.showBefore(pixelOnBitmap)\n                mapperUi.showAfter(brainToMap.panelDeltaBitmap!!)\n\n                if (analysis.hasBrightSpots() && !pixelChangeRegion.isEmpty()) {\n                    val center = Vector3F(\n                        (pixelChangeRegion.centerX - surfaceChangeRegion.x0) / surfaceChangeRegion.width.toFloat(),\n                        (pixelChangeRegion.centerY - surfaceChangeRegion.y0) / surfaceChangeRegion.height.toFloat(),\n                        0f\n                    )\n\n                    visibleSurface.addPixel(\n                        pixelIndex,\n                        pixelChangeRegion.centerX.toFloat(),\n                        pixelChangeRegion.centerY.toFloat()\n                    )\n                    brainToMap.pixelMapData[pixelIndex] = PixelMapData(pixelChangeRegion, pixelOnImageName)\n                    logger.debug { \"$pixelIndex/${brainToMap.brainId}: center = $center\" }\n                } else {\n                    mapperUi.showMessage2(\"looks like no pixel $pixelIndex for ${brainToMap.brainId}\u2026\")\n                }\n            }\n        }\n    }\n\n    private suspend fun slowCamDelay() {\n        getImage()\n        getImage()\n        getImage()\n    }\n\n    private suspend fun getBrightImageBitmap(samples: Int): Bitmap {\n        val bitmap = getImage().toBitmap()\n        for (i in 1 until samples) {\n            bitmap.lighten(getImage().toBitmap())\n        }\n        return bitmap\n    }\n\n    private fun pauseForUserInteraction(message: String = \"PRESS PLAY WHEN READY\") {\n        isPaused = true\n        mapperUi.pauseForUserInteraction()\n        mapperUi.showMessage2(message)\n    }\n\n    private suspend fun waitUntilUnpaused() {\n        while (isPaused) delay(50L)\n        mapperUi.showMessage2(\"\")\n    }\n\n    private suspend fun sendToAllReliably(buffer: Shader.Buffer) {\n        sendToAll(buffer)\n        waitForDelivery()\n    }\n\n    private suspend fun waitForDelivery() {\n        deliverer.await()\n    }\n\n    private fun sendToAll(buffer: Shader.Buffer) {\n        brainsToMap.values.forEach {\n            deliverer.send(it, buffer)\n        }\n    }\n\n    private suspend fun retry(fn: suspend () -> Unit) {\n        fn()\n        delay(10)\n        fn()\n    }\n\n    // keep Pinky from restarting a show up while Mapper is running...\n    private fun suppressShows() {\n        suppressShowsJob = launch(CoroutineName(\"Suppress Pinky\")) {\n            while (isRunning) {\n                delay(10000L)\n                udpSocket.broadcastUdp(Ports.PINKY, MapperHelloMessage(isRunning))\n            }\n        }\n    }\n\n    private fun solidColor(color: Color): BrainShaderMessage {\n        val buf = solidColorBuffer(color)\n        return BrainShaderMessage(buf.shader, buf)\n    }\n\n    private fun solidColorBuffer(color: Color): Shader.Buffer {\n        val solidShader = SolidShader()\n        val buffer = solidShader.createBuffer(object : Surface {\n            override val pixelCount = SparkleMotion.MAX_PIXEL_COUNT\n\n            override fun describe(): String = \"Mapper surface\"\n        }).apply { this.color = color }\n        return buffer\n    }\n\n    private val deliverer = ReliableShaderMessageDeliverer()\n\n    inner class ReliableShaderMessageDeliverer {\n        val outstanding = mutableMapOf<List<Byte>, DeliveryAttempt>()\n        val pongs = Channel<PingMessage>()\n\n        fun send(brainToMap: BrainToMap, buffer: Shader.Buffer) {\n            val deliveryAttempt = DeliveryAttempt(brainToMap, buffer)\n//            logger.debug { \"attempting reliable delivery with key ${deliveryAttempt.key.stringify()}\" }\n            outstanding[deliveryAttempt.key] = deliveryAttempt\n            deliveryAttempt.attemptDelivery()\n        }\n\n        suspend fun await(retryAfterMillis: Double = 200.0, failAfterMillis: Double = 10000.0) {\n            logger.debug { \"Waiting pongs from ${outstanding.values.map { it.brainToMap.brainId }}...\" }\n\n            outstanding.values.forEach {\n                it.retryAt = it.sentAt + retryAfterMillis\n                it.failAt = it.sentAt + failAfterMillis\n            }\n\n            while (outstanding.isNotEmpty()) {\n                val waitingFor =\n                    outstanding.values.map { it.brainToMap.guessedModelSurface?.name ?: it.brainToMap.brainId }\n                        .sorted()\n                mapperUi.showMessage2(\"Waiting for PONG from ${waitingFor.joinToString(\",\")}\")\n//                logger.debug { \"pongs outstanding: ${outstanding.keys.map { it.stringify() }}\" }\n\n                var sleepUntil = Double.MAX_VALUE\n\n                val nowMs = getTimeMillis().toDouble()\n\n                outstanding.values.forEach {\n                    if (it.failAt < nowMs) {\n                        throw TimeoutException(\"Timed out waiting for ${it.brainToMap.brainId} pong ${it.key.stringify()}\")\n                    }\n                    if (sleepUntil > it.failAt) sleepUntil = it.failAt\n\n                    if (it.retryAt < nowMs) {\n                        logger.warn {\n                            \"Haven't heard from ${it.brainToMap.brainId} after ${nowMs - it.retryAt},\" +\n                                    \" retrying (attempt ${++it.retryCount})...\"\n                        }\n                        it.attemptDelivery()\n                        it.retryAt = nowMs + retryAfterMillis\n                    }\n                    if (sleepUntil > it.retryAt) sleepUntil = it.retryAt\n                }\n\n                val timeoutMs = sleepUntil - nowMs\n//                logger.debug { \"Before pongs.receive() withTimeout(${timeoutMs}ms)\" }\n                val pong = withTimeoutOrNull(timeoutMs.toLong()) {\n                    pongs.receive()\n                }\n\n                if (pong != null) {\n                    val pongTag = pong.data.toList()\n//                    logger.debug { \"Received pong(${pongTag.stringify()})\" }\n\n                    val deliveryAttempt = outstanding.remove(pongTag)\n                    if (deliveryAttempt != null) {\n                        deliveryAttempt.succeeded()\n                    } else {\n                        logger.warn { \"huh? no such pong tag ${pongTag.stringify()}!\" }\n                    }\n                }\n\n                mapperUi.showMessage2(\"\")\n            }\n        }\n\n        fun gotPong(pingMessage: PingMessage) {\n            launch {\n                pongs.send(pingMessage)\n            }\n        }\n    }\n\n    class TimeoutException(message: String) : Exception(message)\n\n    inner class DeliveryAttempt(val brainToMap: BrainToMap, val buffer: Shader.Buffer) {\n        private val tag = Random.nextBytes(8)\n        val key get() = tag.toList()\n        val sentAt = getTimeMillis().toDouble()\n        var retryAt = 0.0\n        var failAt = 0.0\n        var retryCount = 0\n\n        fun attemptDelivery() {\n            udpSocket.sendUdp(brainToMap.address, brainToMap.port, BrainShaderMessage(buffer.shader, buffer, tag))\n        }\n\n        fun succeeded() {\n            logger.debug { \"${brainToMap.brainId} shader message pong after ${getTimeMillis() - sentAt}ms\" }\n        }\n    }\n\n    override fun receive(fromAddress: Network.Address, fromPort: Int, bytes: ByteArray) {\n//        logger.debug { \"Mapper received message from $fromAddress:$fromPort ${bytes[0]}\" }\n        val message = parse(bytes)\n        when (message) {\n            is BrainHelloMessage -> {\n                logger.debug { \"Heard from Brain ${message.brainId} surface=${message.surfaceName ?: \"unknown\"}\" }\n                val brainToMap = brainsToMap.getOrPut(fromAddress) { BrainToMap(fromAddress, message.brainId) }\n                mapperUi.showMessage(\"${brainsToMap.size} SURFACES DISCOVERED!\")\n                brainToMap.shade { solidColor(Color.GREEN) }\n            }\n\n            is PingMessage -> {\n                if (message.isPong) {\n                    deliverer.gotPong(message)\n                }\n            }\n        }\n    }\n\n    private fun haveImage(image: Image) {\n//        println(\"image: $image\")\n        mapperUi.showCamImage(image)\n\n        newIncomingImage = image\n    }\n\n    /**\n     * Get an image from the camera that was [we hope was] captured after the moment the method was called.\n     */\n    private suspend fun getImage(): Image {\n        newIncomingImage = null\n\n        while (newIncomingImage == null) {\n            delay(2L)\n        }\n\n        val image = newIncomingImage!!\n        newIncomingImage = null\n        return image\n    }\n\n    private suspend fun getImage(tries: Int = 5, test: (Image) -> Boolean): Image {\n        var image = getImage()\n        var remainingTries = tries - 1\n        while (!test(image) && remainingTries-- > 0) {\n            image = getImage()\n        }\n        return image\n    }\n\n    inner class BrainToMap(val address: Network.Address, val brainId: String) {\n        val port get() = Ports.BRAIN\n        var changeRegion: MediaDevices.Region? = null\n        var guessedModelSurface: Model.Surface? = null\n        var guessedVisibleSurface: MapperUi.VisibleSurface? = null\n        var panelDeltaBitmap: Bitmap? = null\n        var deltaImageName: String? = null\n        val pixelMapData: MutableMap<Int, PixelMapData> = mutableMapOf()\n\n        fun shade(shaderMessage: () -> BrainShaderMessage) {\n            udpSocket.sendUdp(address, Ports.BRAIN, shaderMessage())\n        }\n    }\n\n    class PixelMapData(val pixelChangeRegion: MediaDevices.Region, val deltaImageName: String)\n\n    private class Ballot<T> {\n        private val box = hashMapOf<String, Vote<T>>()\n        var totalVotes: Int = 0\n            private set\n\n        fun cast(key: String, value: T) {\n            box.getOrPut(key) { Vote(value) }.votes++\n            totalVotes++\n        }\n\n        fun winner(): T {\n            return box.values.sortedByDescending { it.votes }.first().item\n        }\n\n        fun summarize(): String {\n            return box.entries\n                .sortedByDescending { (_, v) -> v.votes }\n                .map { (k, v) -> \"$k=${v.votes}\" }\n                .joinToString(\", \")\n        }\n\n        private class Vote<T>(val item: T) {\n            var votes = 0\n        }\n    }\n\n    companion object {\n        val logger = Logger(\"Mapper\")\n    }\n\n    fun List<Byte>.stringify(): String {\n        return map { (it.toInt() and 0xff).toString(16).padStart(2, '0') }.joinToString(\"\")\n    }\n}\n\ninterface MapperUi {\n    fun listen(listener: Listener)\n\n    fun addWireframe(sheepModel: SheepModel)\n    fun showCamImage(image: Image, changeRegion: MediaDevices.Region? = null)\n    fun showDiffImage(deltaBitmap: Bitmap, changeRegion: MediaDevices.Region? = null)\n    fun showMessage(message: String)\n    fun showMessage2(message: String)\n    fun showBefore(bitmap: Bitmap)\n    fun showAfter(bitmap: Bitmap)\n    fun setRedo(fn: (suspend () -> Unit)?)\n    fun lockUi(): CameraOrientation\n    fun unlockUi()\n    fun getVisibleSurfaces(): List<VisibleSurface>\n    fun showCandidates(orderedPanels: List<Pair<VisibleSurface, Float>>)\n    fun intersectingSurface(x: Int, y: Int, visibleSurfaces: List<VisibleSurface>): VisibleSurface?\n    fun showStats(total: Int, mapped: Int, visible: Int)\n    fun close()\n    fun addExistingSession(name: String)\n    fun pauseForUserInteraction()\n\n    interface Listener {\n        fun onStart()\n        fun onPause()\n        fun onStop()\n        fun onClose()\n    }\n\n    interface VisibleSurface {\n        val modelSurface: Model.Surface\n        val boxOnScreen: MediaDevices.Region\n        val pixelsInModelSpace: List<Vector3F?>\n        fun translatePixelToPanelSpace(screenX: Float, screenY: Float): Vector2F?\n        fun addPixel(pixelIndex: Int, x: Float, y: Float)\n        fun showPixels()\n        fun hidePixels()\n    }\n\n    interface CameraOrientation {\n        val cameraMatrix: Matrix4\n        val aspect: Double\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual interface Comparator<T> {\n    @JsName(\"compare\")\n    actual fun compare(a: T, b: T): Int\n}\n\npublic actual inline fun <T> Comparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> = object : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparison(a, b)\n}\n","package baaahs\n\nimport baaahs.geom.Vector2F\nimport baaahs.geom.Vector3F\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport baaahs.io.Fs\nimport baaahs.mapper.MapperEndpoint\nimport baaahs.mapper.MappingResults\nimport baaahs.mapper.Storage\nimport baaahs.net.FragmentingUdpLink\nimport baaahs.net.Network\nimport baaahs.proto.*\nimport baaahs.shaders.GlslShader\nimport baaahs.shaders.PixelShader\nimport com.soywiz.klock.DateTime\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlin.math.min\n\nclass Pinky(\n    val model: Model<*>,\n    val shows: List<Show>,\n    val network: Network,\n    val dmxUniverse: Dmx.Universe,\n    val beatSource: BeatSource,\n    val clock: Clock,\n    val fs: Fs,\n    val firmwareDaddy: FirmwareDaddy,\n    val display: PinkyDisplay,\n    private val prerenderPixels: Boolean = false\n) : Network.UdpListener {\n    val newShowAfterIdleSeconds = 300\n    val adjustShowAfterIdleSeconds = 120\n\n    private val storage = Storage(fs)\n    private val mappingResults = storage.loadMappingData(model)\n\n    private val link = FragmentingUdpLink(network.link())\n    val httpServer = link.startHttpServer(Ports.PINKY_UI_TCP)\n\n\n    private val beatProvider = PinkyBeatDisplayer(beatSource)\n    private var mapperIsRunning = false\n    private var selectedShow = shows.first()\n        set(value) {\n            field = value\n            display.selectedShow = value\n            showRunner.nextShow = selectedShow\n        }\n\n    private val pubSub: PubSub.Server = PubSub.Server(httpServer).apply { install(gadgetModule) }\n    private val gadgetManager = GadgetManager(pubSub)\n    private val movingHeadManager = MovingHeadManager(fs, pubSub, model.movingHeads)\n    private val showRunner =\n        ShowRunner(model, selectedShow, gadgetManager, beatSource, dmxUniverse, movingHeadManager, clock)\n\n    private val selectedShowChannel: PubSub.Channel<String>\n    private var selectedNewShowAt = DateTime.now()\n\n    private val brainToSurfaceMap_CHEAT = mutableMapOf<BrainId, Model.Surface>()\n    private val surfaceToPixelLocationMap_CHEAT = mutableMapOf<Model.Surface, List<Vector3F>>()\n\n    private val brainInfos: MutableMap<BrainId, BrainInfo> = mutableMapOf()\n    private val pendingBrainInfos: MutableMap<BrainId, BrainInfo> = mutableMapOf()\n\n    val address: Network.Address get() = link.myAddress\n    private val networkStats = NetworkStats()\n\n    // This needs to go last-ish, otherwise we start getting network traffic too early.\n    private val udpSocket = link.listenUdp(Ports.PINKY, this)\n\n    init {\n        httpServer.listenWebSocket(\"/ws/mapper\") { MapperEndpoint(storage) }\n\n        GlslShader.model_CHEAT = model\n\n        pubSub.publish(Topics.availableShows, shows.map { show -> show.name }) {}\n        selectedShowChannel = pubSub.publish(Topics.selectedShow, shows[0].name) { selectedShow ->\n            this.selectedShow = shows.find { it.name == selectedShow }!!\n        }\n    }\n\n    suspend fun run(): Show.Renderer {\n        GlobalScope.launch { beatProvider.run() }\n\n        display.listShows(shows)\n        display.selectedShow = selectedShow\n\n        display.onShowChange = { switchToShow(display.selectedShow!!) }\n\n        while (true) {\n            if (mapperIsRunning) {\n                disableDmx()\n                delay(50)\n                continue\n            }\n\n            updateSurfaces()\n\n            networkStats.reset()\n            val elapsedMs = time {\n                drawNextFrame()\n            }\n            display.showFrameMs = elapsedMs.toInt()\n            display.stats = networkStats\n\n            maybeChangeThingsIfUsersAreIdle()\n\n            delay(30)\n        }\n    }\n\n    private fun maybeChangeThingsIfUsersAreIdle() {\n        val now = DateTime.now()\n        val secondsSinceUserInteraction = now.minus(gadgetManager.lastUserInteraction).seconds\n        if (now.minus(selectedNewShowAt).seconds > newShowAfterIdleSeconds\n            && secondsSinceUserInteraction > newShowAfterIdleSeconds\n        ) {\n            switchToShow(shows.random()!!)\n            selectedNewShowAt = now\n        }\n\n        if (secondsSinceUserInteraction > adjustShowAfterIdleSeconds) {\n            gadgetManager.adjustSomething()\n        }\n    }\n\n    private fun switchToShow(nextShow: Show) {\n        this.selectedShow = nextShow\n        selectedShowChannel.onChange(nextShow.name)\n    }\n\n    internal fun updateSurfaces() {\n        if (pendingBrainInfos.isNotEmpty()) {\n            val brainSurfacesToRemove = mutableListOf<ShowRunner.SurfaceReceiver>()\n            val brainSurfacesToAdd = mutableListOf<ShowRunner.SurfaceReceiver>()\n\n            pendingBrainInfos.forEach { (brainId, incomingBrainInfo) ->\n                val priorBrainInfo = brainInfos[brainId]\n                if (priorBrainInfo != null) {\n                    brainSurfacesToRemove.add(priorBrainInfo.surfaceReceiver)\n                }\n\n                if (incomingBrainInfo.hadException) {\n                    // Existing Brain has had exceptions so we're forgetting about it.\n                    brainInfos.remove(brainId)\n                } else {\n                    brainSurfacesToAdd.add(incomingBrainInfo.surfaceReceiver)\n                    brainInfos[brainId] = incomingBrainInfo\n                }\n            }\n\n            showRunner.surfacesChanged(brainSurfacesToAdd, brainSurfacesToRemove)\n\n            pendingBrainInfos.clear()\n        }\n\n        display.brainCount = brainInfos.size\n    }\n\n    internal fun drawNextFrame() {\n        aroundNextFrame {\n            showRunner.nextFrame()\n        }\n    }\n\n    private fun disableDmx() {\n        dmxUniverse.allOff()\n    }\n\n    override fun receive(fromAddress: Network.Address, fromPort: Int, bytes: ByteArray) {\n        val message = parse(bytes)\n        when (message) {\n            is BrainHelloMessage -> foundBrain(fromAddress, message)\n            is MapperHelloMessage -> {\n                logger.debug { \"Mapper isRunning=${message.isRunning}\" }\n                mapperIsRunning = message.isRunning\n            }\n            is PingMessage -> if (message.isPong) receivedPong(message, fromAddress)\n        }\n    }\n\n    private fun foundBrain(\n        brainAddress: Network.Address,\n        msg: BrainHelloMessage\n    ) {\n        val brainId = BrainId(msg.brainId)\n        val surfaceName = msg.surfaceName\n\n        logger.info { \"Hello from ${brainId.uuid} at $brainAddress: $msg\" }\n        if (firmwareDaddy.doesntLikeThisVersion(msg.firmwareVersion)) {\n            // You need the new hotness bro\n            logger.info { \"The firmware daddy doesn't like $brainId having ${msg.firmwareVersion}\" +\n                    \" so we'll send ${firmwareDaddy.urlForPreferredVersion}\" }\n            val newHotness = UseFirmwareMessage(firmwareDaddy.urlForPreferredVersion)\n            udpSocket.sendUdp(brainAddress, Ports.BRAIN, newHotness)\n        }\n\n\n        // println(\"Heard from brain $brainId at $brainAddress for $surfaceName\")\n        val dataFor = mappingResults.dataFor(brainId) ?: findMappingInfo_CHEAT(surfaceName, brainId)\n\n        val surface = dataFor?.let {\n            val pixelLocations = dataFor.pixelLocations?.map { it ?: Vector3F(0f, 0f, 0f) } ?: emptyList()\n            val pixelCount = dataFor.pixelLocations?.size ?: SparkleMotion.MAX_PIXEL_COUNT\n\n            if (msg.surfaceName != dataFor.surface.name) {\n                val mappingMsg = BrainMappingMessage(\n                    brainId, dataFor.surface.name, null, Vector2F(0f, 0f),\n                    Vector2F(0f, 0f), pixelCount, pixelLocations\n                )\n                udpSocket.sendUdp(brainAddress, Ports.BRAIN, mappingMsg)\n            }\n\n            IdentifiedSurface(dataFor.surface, pixelCount, dataFor.pixelLocations)\n        } ?: AnonymousSurface(brainId)\n\n\n        val priorBrainInfo = brainInfos[brainId]\n        if (priorBrainInfo != null) {\n            if (priorBrainInfo.brainId == brainId && priorBrainInfo.surface == surface) {\n                // Duplicate packet?\n//                logger.debug(\n//                    \"Ignore ${priorBrainInfo.brainId} ${priorBrainInfo.surface.describe()} ->\" +\n//                            \" ${surface.describe()} because probably duplicate?\"\n//                )\n                return\n            }\n\n//            logger.debug(\n//                \"Remapping ${priorBrainInfo.brainId} from ${priorBrainInfo.surface.describe()} ->\" +\n//                        \" ${surface.describe()}\"\n//            )\n        }\n\n        val sendFn: (Shader.Buffer) -> Unit = { shaderBuffer ->\n            val message = BrainShaderMessage(shaderBuffer.shader, shaderBuffer).toBytes()\n            try {\n                udpSocket.sendUdp(brainAddress, Ports.BRAIN, message)\n            } catch (e: Exception) {\n                // Couldn't send to Brain? Schedule to remove it.\n                val brainInfo = brainInfos[brainId]!!\n                brainInfo.hadException = true\n                pendingBrainInfos[brainId] = brainInfo\n\n                logger.error(\"Error sending to $brainId, will take offline\", e)\n            }\n\n            networkStats.packetsSent++\n            networkStats.bytesSent += message.size\n        }\n\n        val surfaceReceiver = if (prerenderPixels) {\n            PrerenderingSurfaceReceiver(surface, sendFn)\n        } else {\n            ShowRunner.SurfaceReceiver(surface, sendFn)\n        }\n\n        val brainInfo = BrainInfo(brainAddress, brainId, surface, msg.firmwareVersion, msg.idfVersion, surfaceReceiver)\n//        logger.debug(\"Map ${brainInfo.brainId} to ${brainInfo.surface.describe()}\")\n        pendingBrainInfos[brainId] = brainInfo\n\n        // Decide whether or not to tell this brain it should use a different firmware\n\n    }\n\n    private fun findMappingInfo_CHEAT(surfaceName: String?, brainId: BrainId): MappingResults.Info? {\n        val modelSurface = surfaceName?.let { model.findModelSurface(surfaceName) } ?: brainToSurfaceMap_CHEAT[brainId]\n        return if (modelSurface != null) {\n            MappingResults.Info(modelSurface, surfaceToPixelLocationMap_CHEAT[modelSurface])\n        } else {\n            null\n        }\n    }\n\n    /** If we want a pong back from a [BrainShaderMessage], send this. */\n    private fun generatePongPayload(): ByteArray {\n        return ByteArrayWriter().apply {\n            writeLong(getTimeMillis())\n        }.toBytes()\n    }\n\n    private fun receivedPong(message: PingMessage, fromAddress: Network.Address) {\n        val originalSentAt = ByteArrayReader(message.data).readLong()\n        val elapsedMs = getTimeMillis() - originalSentAt\n        logger.debug { \"Shader pong from $fromAddress took ${elapsedMs}ms\" }\n    }\n\n    fun providePanelMapping_CHEAT(brainId: BrainId, surface: Model.Surface) {\n        brainToSurfaceMap_CHEAT[brainId] = surface\n    }\n\n    fun providePixelMapping_CHEAT(surface: Model.Surface, pixelLocations: List<Vector3F>) {\n        surfaceToPixelLocationMap_CHEAT[surface] = pixelLocations\n    }\n\n    inner class PinkyBeatDisplayer(val beatSource: BeatSource) {\n        suspend fun run() {\n            while (true) {\n               val beatData = beatSource.getBeatData()\n                display.beat = beatData.beatWithinMeasure(clock).toInt()\n                display.bpm = beatData.bpm\n                display.beatConfidence = beatData.confidence\n                delay(10)\n            }\n        }\n    }\n\n    class NetworkStats(var bytesSent: Int = 0, var packetsSent: Int = 0) {\n        internal fun reset() {\n            bytesSent = 0\n            packetsSent = 0\n        }\n    }\n\n    private inner class PrerenderingSurfaceReceiver(surface: Surface, sendFn: (Shader.Buffer) -> Unit) :\n        ShowRunner.SurfaceReceiver(surface, sendFn) {\n        var currentRenderTree: Brain.RenderTree<*>? = null\n        private var currentPoolKey: Any? = null\n        var pixels: PixelsAdapter? = null\n        var currentBuffer: Shader.Buffer? = null\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun send(shaderBuffer: Shader.Buffer) {\n            val shader = shaderBuffer.shader as Shader<Shader.Buffer>\n            var renderTree = currentRenderTree\n            if (renderTree == null || renderTree.shader != shader) {\n                val priorPoolKey = currentPoolKey\n                var newPoolKey: Any? = null\n\n                val renderer = shader.createRenderer(surface, object : RenderContext {\n                    override fun <T : PooledRenderer> registerPooled(key: Any, fn: () -> T): T {\n                        newPoolKey = key\n                        return poolingRenderContext.registerPooled(key, fn)\n                    }\n                })\n\n                if (newPoolKey != priorPoolKey) {\n                    if (priorPoolKey != null) {\n                        poolingRenderContext.decrement(priorPoolKey)\n                    }\n                    currentPoolKey = newPoolKey\n                }\n\n                renderTree = Brain.RenderTree(shader, renderer, shaderBuffer)\n                currentRenderTree = renderTree\n\n                if (pixels == null) {\n                    val pixelBuffer = PixelShader(PixelShader.Encoding.DIRECT_RGB).createBuffer(surface)\n                    pixels = PixelsAdapter(pixelBuffer)\n                }\n            }\n\n            val renderer = currentRenderTree!!.renderer as Shader.Renderer<Shader.Buffer>\n            renderer.beginFrame(shaderBuffer, pixels!!.size)\n\n            // we need to reorder the draw cycle, so don't do the rest of the render yet!\n            currentBuffer = shaderBuffer\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        fun actuallySend() {\n            val renderTree = currentRenderTree\n            if (renderTree != null) {\n                val renderer = renderTree.renderer as Shader.Renderer<Shader.Buffer>\n                val pixels = pixels!!\n                val currentBuffer = currentBuffer!!\n\n                for (i in pixels.indices) {\n                    pixels[i] = renderer.draw(currentBuffer, i)\n                }\n                this.currentBuffer = null\n\n                renderer.endFrame()\n                pixels.finishedFrame()\n\n                renderTree.draw(pixels)\n\n                super.send(pixels.buffer)\n            }\n        }\n    }\n\n    var poolingRenderContext = PoolingRenderContext()\n    var lastSentAt: Long = 0\n\n    private fun aroundNextFrame(callNextFrame: () -> Unit) {\n        /**\n         * [ShowRunner.SurfaceReceiver.send] is called here; if [prerenderPixels] is true, it won't\n         * actually send; we need to do that ourselves.\n         */\n        callNextFrame()\n\n        if (prerenderPixels) {\n            val preDrawElapsed = timeSync {\n                poolingRenderContext.preDraw()\n            }\n\n            val sendElapsed = timeSync {\n                brainInfos.values.forEach { brainInfo ->\n                    val surfaceReceiver = brainInfo.surfaceReceiver as PrerenderingSurfaceReceiver\n                    surfaceReceiver.actuallySend()\n                }\n            }\n\n//            println(\"preDraw took ${preDrawElapsed}ms, send took ${sendElapsed}ms\")\n        }\n        val now = getTimeMillis()\n        val elapsedMs = now - lastSentAt\n//        println(\"It's been $elapsedMs\")\n        lastSentAt = now\n    }\n\n\n    class PoolingRenderContext : RenderContext {\n        private val pooledRenderers = hashMapOf<Any, Holder<*>>()\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun <T : PooledRenderer> registerPooled(key: Any, fn: () -> T): T {\n            val holder = pooledRenderers.getOrPut(key) { Holder(fn()) }\n            holder.count++\n            return holder.pooledRenderer as T\n        }\n\n        fun decrement(key: Any) {\n            val holder = pooledRenderers[key]!!\n            holder.count--\n            if (holder.count == 0) {\n                logger.debug { \"Removing pooled renderer for $key\" }\n                pooledRenderers.remove(key)\n            }\n        }\n\n        fun preDraw() {\n            pooledRenderers.values.forEach { holder ->\n                holder.pooledRenderer.preDraw()\n            }\n        }\n\n        class Holder<T : PooledRenderer>(val pooledRenderer: T, var count: Int = 0)\n    }\n\n    private class PixelsAdapter(internal val buffer: PixelShader.Buffer) : Pixels {\n        override val size: Int = buffer.colors.size\n\n        override fun get(i: Int): Color = buffer.colors[i]\n\n        override fun set(i: Int, color: Color) {\n            buffer.colors[i] = color\n        }\n\n        override fun set(colors: Array<Color>) {\n            for (i in 0 until min(colors.size, size)) {\n                buffer.colors[i] = colors[i]\n            }\n        }\n    }\n\n    companion object {\n        val logger = Logger(\"Pinky\")\n    }\n}\n\ndata class BrainId(val uuid: String)\n\nclass BrainInfo(\n    val address: Network.Address,\n    val brainId: BrainId,\n    val surface: Surface,\n    val firmwareVersion: String?,\n    val idfVersion: String?,\n    val surfaceReceiver: ShowRunner.SurfaceReceiver,\n    var hadException: Boolean = false\n)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the contents of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\npublic actual fun String.toBoolean(): Boolean = toLowerCase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.toLowerCase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> =\n    this.toDouble().rangeTo(that.toDouble()).unsafeCast<ClosedFloatingPointRange<Float>>()\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun ByteArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun ShortArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun IntArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun LongArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun FloatArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun CharArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","package baaahs.io\n\nimport kotlin.math.min\n\nclass ByteArrayReader(val bytes: ByteArray, offset: Int = 0) {\n    var offset = offset\n        set(value) {\n            if (value > bytes.size) {\n                throw IllegalStateException(\"array index out of bounds\")\n            }\n            field = value\n        }\n\n    fun readBoolean(): Boolean = bytes[offset++].toInt() != 0\n\n    fun readByte(): Byte = bytes[offset++]\n\n    fun readShort(): Short =\n        (bytes[offset++].toInt() and 0xff shl 8)\n            .or(bytes[offset++].toInt() and 0xff).toShort()\n\n    fun readChar(): Char = readShort().toChar()\n\n    fun readInt(): Int =\n        (bytes[offset++].toInt() and 0xff shl 24)\n            .or(bytes[offset++].toInt() and 0xff shl 16)\n            .or(bytes[offset++].toInt() and 0xff shl 8)\n            .or(bytes[offset++].toInt() and 0xff)\n\n    fun readLong(): Long =\n        (readInt().toLong() and 0xffffffff shl 32)\n            .or(readInt().toLong() and 0xffffffff)\n\n    fun readFloat(): Float = Float.fromBits(readInt())\n\n    @UseExperimental(ExperimentalStdlibApi::class)\n    fun readString(): String = readBytes().decodeToString()\n\n    fun readNullableString(): String? = if (readBoolean()) readString() else null\n\n    fun readBytes(): ByteArray {\n        val count = readInt()\n        return readNBytes(count)\n    }\n\n    fun readNBytes(count: Int): ByteArray {\n        val bytes = bytes.copyOfRange(offset, offset + count)\n        offset += count\n        return bytes\n    }\n\n    fun readNBytes(dest: ByteArray): ByteArray {\n        val bytes = bytes.copyInto(dest,\n            destinationOffset = 0, startIndex = offset, endIndex = offset + dest.size)\n        offset += dest.size\n        return bytes\n    }\n\n    /**\n     * Reads up to as many bytes as are present in `buffer`, or as many bytes are available in the incoming byte array,\n     * and returns the number of bytes actually read. Any unread incoming bytes are skipped.\n     */\n    fun readBytes(buffer: ByteArray): Int {\n        val count = readInt()\n        val toCopy = min(buffer.size, count)\n        bytes.copyInto(buffer, 0, offset, offset + toCopy)\n        offset += count\n        return toCopy\n    }\n\n    fun hasMoreBytes(): Boolean = offset < bytes.size\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size)))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    val set = LinkedHashSet<Byte>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    val set = LinkedHashSet<Short>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    val set = LinkedHashSet<Int>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    val set = LinkedHashSet<Long>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    val set = LinkedHashSet<Float>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    val set = LinkedHashSet<Double>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    val set = LinkedHashSet<Boolean>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    val set = LinkedHashSet<Char>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ByteArray.max(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ShortArray.max(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun IntArray.max(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun LongArray.max(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun CharArray.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ByteArray.min(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ShortArray.min(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun IntArray.min(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun LongArray.min(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun CharArray.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package baaahs.mapper\n\nimport baaahs.Logger\nimport baaahs.imaging.Bitmap\nimport baaahs.net.Network\nimport com.soywiz.klock.DateTime\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.MainScope\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlinx.serialization.json.*\nimport kotlinx.serialization.list\nimport kotlinx.serialization.serializer\n\n@UseExperimental(ExperimentalStdlibApi::class)\nclass MapperClient(link: Network.Link, address: Network.Address) : Network.WebSocketListener,\n    CoroutineScope by MainScope() {\n    private lateinit var tcpConnection: Network.TcpConnection\n    private var connected = false\n    private lateinit var responses: Channel<ByteArray>\n\n    init {\n        link.connectWebSocket(address, 0, \"/ws/mapper\", this)\n    }\n\n    suspend fun listSessions(): List<String> {\n        return MapperEndpoint.json.fromJson(String.serializer().list, sendCommand(\"listSessions\"))\n    }\n\n    suspend fun saveImage(sessionStartTime: DateTime, name: String, bitmap: Bitmap): String {\n        val filename = \"${Storage.formatDateTime(sessionStartTime)}/$name.webp\"\n        val dataUrl = bitmap.toDataUrl()\n        val startOfData = \";base64,\"\n        val i = dataUrl.indexOf(startOfData)\n        if (i == -1) {\n            throw IllegalArgumentException(\"failed to save image $dataUrl\")\n        }\n\n        sendCommand(\n            \"saveImage\",\n            JsonPrimitive(filename),\n            JsonPrimitive(dataUrl.substring(i + startOfData.length))\n        )\n\n        return filename\n    }\n\n    suspend fun saveSession(mappingSession: MappingSession) {\n        sendCommand(\"saveSession\", MapperEndpoint.json.toJson(MappingSession.serializer(), mappingSession))\n    }\n\n    private suspend fun sendCommand(command: String, vararg args: JsonElement): JsonElement {\n        val content = jsonArray {\n            +command\n            args.forEach { +it }\n        }\n        while (!connected) {\n            delay(5)\n        }\n        tcpConnection.send(MapperEndpoint.json.stringify(JsonArraySerializer, content).encodeToByteArray())\n\n        val responseJsonStr = responses.receive().decodeToString()\n        try {\n            val responseJson = MapperEndpoint.json.parseJson(responseJsonStr)\n            val status = responseJson.jsonObject.getPrimitive(\"status\")\n            val response = responseJson.jsonObject.getValue(\"response\")\n            when (status.contentOrNull) {\n                \"success\" -> return response\n                \"error\" -> throw RuntimeException(response.contentOrNull)\n            }\n            return responseJson\n        } catch (e: JsonParsingException) {\n            logger.error { \"can't parse response to $command $args: $responseJsonStr\" }\n            throw e\n        }\n    }\n\n    override fun connected(tcpConnection: Network.TcpConnection) {\n        println(\"Mapper connected to Pinky!\")\n        this.tcpConnection = tcpConnection\n        responses = Channel(1)\n        connected = true\n    }\n\n    override fun receive(tcpConnection: Network.TcpConnection, bytes: ByteArray) {\n        println(\"Received ${bytes.decodeToString()}\")\n        launch { responses.send(bytes) }\n    }\n\n    override fun reset(tcpConnection: Network.TcpConnection) {\n        responses.close()\n        println(\"Mapper disconnected from Pinky!\")\n    }\n\n    companion object {\n        val logger = Logger(\"MapperClient\")\n    }\n}\n",null,"package baaahs.shows\n\nimport baaahs.*\nimport baaahs.gadgets.PalettePicker\nimport baaahs.gadgets.Slider\nimport baaahs.shaders.CompositingMode\nimport baaahs.shaders.CompositorShader\nimport baaahs.shaders.SolidShader\nimport baaahs.shaders.SparkleShader\n\nobject PanelTweenShow : Show(\"PanelTweenShow\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        val initialColors = listOf(\n            Color.from(\"#FF8A47\"),\n            Color.from(\"#FC6170\"),\n            Color.from(\"#8CEEEE\"),\n            Color.from(\"#26BFBF\"),\n            Color.from(\"#FFD747\")\n        )\n\n        return object : Renderer {\n            val palettePicker = showRunner.getGadget(\"palette\", PalettePicker(\"Palette\", initialColors))\n            val slider = showRunner.getGadget(\"sparkliness\", Slider(\"Sparkliness\", 0f, 0f, 1f, 0.01f ))\n\n            val solidShader = SolidShader()\n            val sparkleShader = SparkleShader()\n\n            val shaderBuffers = showRunner.allSurfaces.map { surface ->\n                val solidShaderBuffer = showRunner.getShaderBuffer(surface, solidShader)\n                val sparkleShaderBuffer = showRunner.getShaderBuffer(surface, sparkleShader)\n                val compositorShaderBuffer = showRunner.getCompositorBuffer(\n                    surface, solidShaderBuffer, sparkleShaderBuffer, CompositingMode.ADD, 1f\n                )\n\n                Shaders(solidShaderBuffer, sparkleShaderBuffer, compositorShaderBuffer)\n            }\n            val fadeTimeMs = 500\n\n            override fun nextFrame() {\n                val now = getTimeMillis().and(0xfffffff).toInt()\n                val colors = palettePicker.colors\n                shaderBuffers.forEachIndexed() { number, bufs ->\n                    val colorIndex = (now / fadeTimeMs + number) % colors.size\n                    val startColor = colors[colorIndex]\n                    val endColor = colors[(colorIndex + 1) % colors.size]\n                    val tweenedColor = startColor.fade(endColor, (now % fadeTimeMs) / fadeTimeMs.toFloat())\n\n                    bufs.apply {\n                        solidShader.color = tweenedColor\n\n                        sparkleShader.color = Color.WHITE\n                        sparkleShader.sparkliness = slider.value\n                    }\n                }\n            }\n        }\n    }\n\n    class Shaders(\n        val solidShader: SolidShader.Buffer,\n        val sparkleShader: SparkleShader.Buffer,\n        val compositorShader: CompositorShader.Buffer\n    )\n\n    val SheepModel.Panel.number: Int\n        get() = Regex(\"\\\\d+\").find(name)?.value?.toInt() ?: -1\n}\n","package baaahs\n\nimport baaahs.geom.Vector3F\nimport baaahs.proto.Ports\nimport baaahs.shows.AllShows\nimport baaahs.sim.FakeDmxUniverse\nimport baaahs.sim.FakeFs\nimport baaahs.sim.FakeMediaDevices\nimport baaahs.sim.FakeNetwork\nimport baaahs.visualizer.SwirlyPixelArranger\nimport baaahs.visualizer.Visualizer\nimport baaahs.visualizer.VizPanel\nimport decodeQueryParams\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonConfiguration\nimport org.w3c.dom.WebSocket\nimport kotlin.browser.document\nimport kotlin.browser.window\nimport kotlin.js.Date\n\nclass SheepSimulator {\n    private val display = JsDisplay()\n    private val network = FakeNetwork(display = display.forNetwork())\n    private val dmxUniverse = FakeDmxUniverse()\n    private val sheepModel = SheepModel().apply { load() }\n    private val shows = AllShows.allShows\n    private val visualizer = Visualizer(sheepModel, display.forVisualizer())\n    private val fs = FakeFs()\n    private val beatSource: BeatSource = BridgedBeatSource(\"${window.location.hostname}:${Ports.SIMULATOR_BRIDGE_TCP}\")\n    private val pinky = Pinky(sheepModel, shows, network, dmxUniverse, beatSource, JsClock(), fs,\n        PermissiveFirmwareDaddy(), display.forPinky(),\n        prerenderPixels = true)\n\n    fun start() = doRunBlocking {\n        val queryParams = decodeQueryParams(document.location!!)\n\n        pinkyScope.launch { pinky.run() }\n\n        val launcher = Launcher(document.getElementById(\"launcher\")!!)\n        launcher.add(\"Web UI\") {\n            val webUiClientLink = network.link()\n            val pubSub = PubSub.Client(webUiClientLink, pinky.address, Ports.PINKY_UI_TCP).apply {\n                install(gadgetModule)\n            }\n            document.asDynamic().createUiApp(pubSub)\n        }.also { delay(1000); it.click() }\n\n        launcher.add(\"Mapper\") {\n            val mapperUi = JsMapperUi(visualizer)\n            val mediaDevices = FakeMediaDevices(visualizer)\n            val mapper = Mapper(network, sheepModel, mapperUi, mediaDevices, pinky.address)\n            mapperScope.launch { mapper.start() }\n\n            mapperUi\n        }\n\n        val pixelDensity = queryParams.getOrElse(\"pixelDensity\") { \"0.2\" }.toFloat()\n        val pixelSpacing = queryParams.getOrElse(\"pixelSpacing\") { \"3\" }.toFloat()\n        val pixelArranger = SwirlyPixelArranger(pixelDensity, pixelSpacing)\n        var totalPixels = 0\n\n        sheepModel.panels.sortedBy(SheepModel.Panel::name).forEachIndexed { index, panel ->\n            //            if (panel.name != \"17L\") return@forEachIndexed\n\n            val vizPanel = visualizer.addPanel(panel)\n            val pixelPositions = pixelArranger.arrangePixels(vizPanel)\n            vizPanel.vizPixels = VizPanel.VizPixels(vizPanel, pixelPositions)\n\n            totalPixels += pixelPositions.size\n            document.getElementById(\"visualizerPixelCount\").asDynamic().innerText = totalPixels.toString()\n\n            // This part is cheating... TODO: don't cheat!\n            val pixelLocations = vizPanel.getPixelLocationsInModelSpace()!!.map {\n                Vector3F(it.x.toFloat(), it.y.toFloat(), it.z.toFloat())\n            }\n            pinky.providePixelMapping_CHEAT(panel, pixelLocations)\n\n            val brain = Brain(\"brain//$index\", network, display.forBrain(), vizPanel.vizPixels ?: NullPixels)\n            pinky.providePanelMapping_CHEAT(BrainId(brain.id), panel)\n            brainScope.launch { randomDelay(1000); brain.run() }\n        }\n\n        sheepModel.eyes.forEach { eye ->\n            visualizer.addMovingHead(eye, dmxUniverse)\n        }\n\n//        val users = storage.users.transaction { store -> store.getAll() }\n//        println(\"users = ${users}\")\n\n        doRunBlocking {\n            delay(200000L)\n        }\n    }\n\n    object NullPixels : Pixels {\n        override val size = 0\n\n        override fun get(i: Int): Color = Color.BLACK\n        override fun set(i: Int, color: Color) {}\n        override fun set(colors: Array<Color>) {}\n    }\n\n    private val pinkyScope = CoroutineScope(Dispatchers.Main)\n    private val brainScope = CoroutineScope(Dispatchers.Main)\n    private val mapperScope = CoroutineScope(Dispatchers.Main)\n}\n\nclass JsClock : Clock {\n    override fun now(): Time = Date.now()\n}\n\nclass BridgedBeatSource(url: String) : BeatSource {\n    private var beatData = BeatData(0.0, 0, confidence = 0f)\n\n    override fun getBeatData(): BeatData = beatData\n\n    val l = window.location;\n    private val webSocket = WebSocket(\"${if (l.protocol == \"https:\") \"wss:\" else \"ws:\"}//$url/bridge/beatSource\")\n    private val json = Json(JsonConfiguration.Stable)\n\n    init {\n        webSocket.onopen = {\n            console.log(\"WebSocket open!\", it)\n        }\n\n        webSocket.onmessage = {\n            // TODO: be less woefully inefficient...\n            val buf = it.data as String\n            println(\"buf is $buf\")\n            beatData = json.parse(BeatData.serializer(), buf)\n            null\n        }\n\n        webSocket.onerror = {\n            beatData = BeatData(0.0, 500, 4, 0.0f)\n            console.log(\"WebSocket error!\", it)\n        }\n        webSocket.onclose = { console.log(\"WebSocket close!\", it) }\n    }\n}\n","package baaahs.glsl\n\nimport baaahs.Color\nimport baaahs.IdentifiedSurface\nimport baaahs.getTimeMillis\nimport baaahs.shaders.GlslShader\nimport baaahs.shaders.GlslShader.AdjustableValue.Type.FLOAT\nimport baaahs.shaders.GlslShader.AdjustableValue.Type.INT\nimport baaahs.shaders.GlslShader.AdjustableValue.Type.VEC3\nimport baaahs.timeSync\nimport org.khronos.webgl.ArrayBufferView\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.Uint32Array\nimport org.khronos.webgl.Uint8Array\nimport org.khronos.webgl.WebGLBuffer\nimport org.khronos.webgl.WebGLProgram\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.khronos.webgl.WebGLShader\nimport org.khronos.webgl.WebGLUniformLocation\nimport org.khronos.webgl.get\nimport org.w3c.dom.HTMLCanvasElement\nimport kotlin.browser.document\nimport kotlin.browser.window\n\nactual object GlslBase {\n    actual val manager: GlslManager by lazy { JsGlslManager() }\n}\n\nclass JsGlslManager : GlslManager {\n    override fun createRenderer(program: String, adjustableValues: List<GlslShader.AdjustableValue>) =\n        JsGlslRenderer(program, adjustableValues)\n}\n\npublic external abstract class WebGL2RenderingContext : WebGLRenderingContext {\n    companion object {\n        val RED: Int = definedExternally\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int = definedExternally\n        val R32F: Int = definedExternally\n        val RG32F: Int = definedExternally\n        val DEPTH_COMPONENT32F: Int = definedExternally\n    }\n}\n\n\nclass JsGlslRenderer(\n    fragShader: String,\n    adjustableValues: List<GlslShader.AdjustableValue>\n) : GlslRenderer(fragShader, adjustableValues) {\n    val canvas = document.createElement(\"canvas\") as HTMLCanvasElement\n    var gl: WebGL2RenderingContext = canvas.getContext(\"webgl2\")!! as WebGL2RenderingContext\n\n    private val program: WebGLProgram?\n    private val quad: Quad\n\n    init {\n        gl { gl.clearColor(0f, .5f, 0f, 1f) }\n\n        program = createShaderProgram()\n        quad = Quad()\n\n        findUniforms()\n\n        instance = createInstance(1, FloatArray(2), nextSurfaceOffset)\n    }\n\n    override fun getUniformLocation(name: String, required: Boolean): Uniform {\n        val loc = gl { gl.getUniformLocation(program, name) }\n        if (loc == null && required)\n            throw IllegalStateException(\"Couldn't find uniform $name\")\n\n        return Uniform(loc)\n    }\n\n    inner class Quad {\n        private val vertices = arrayOf(\n            // First triangle:\n            1.0f, 1.0f,\n            -1.0f, 1.0f,\n            -1.0f, -1.0f,\n            // Second triangle:\n            -1.0f, -1.0f,\n            1.0f, -1.0f,\n            1.0f, 1.0f\n        )\n\n        private var quadVertexBuffer: WebGLBuffer? = null\n\n        init {\n            quadVertexBuffer = gl.createBuffer()\n            gl { gl.bindBuffer(GL.ARRAY_BUFFER, quadVertexBuffer) }\n            gl { gl.bufferData(GL.ARRAY_BUFFER, Float32Array(vertices), GL.STATIC_DRAW); }\n\n            val vertexAttr = gl { gl.getAttribLocation(program, \"Vertex\") }\n            gl { gl.vertexAttribPointer(vertexAttr, 2, GL.FLOAT, false, 0, 0) }\n            gl { gl.enableVertexAttribArray(vertexAttr) }\n\n            gl { gl.bindBuffer(GL.ARRAY_BUFFER, null) }\n        }\n\n        internal fun render() {\n            gl { gl.bindBuffer(GL.ARRAY_BUFFER, quadVertexBuffer) }\n\n            // Draw the triangles\n            gl { gl.drawArrays(GL.TRIANGLES, 0, 6) }\n\n            gl { gl.bindBuffer(GL.ARRAY_BUFFER, null) }\n        }\n\n        private fun release() {\n            gl { gl.deleteBuffer(quadVertexBuffer) }\n        }\n    }\n\n    override fun createSurfacePixels(surface: IdentifiedSurface, pixelOffset: Int): baaahs.glsl.SurfacePixels =\n        SurfacePixels(surface, pixelOffset)\n\n    override fun createInstance(pixelCount: Int, uvCoords: FloatArray, surfaceCount: Int): GlslRenderer.Instance =\n        Instance(pixelCount, uvCoords, surfaceCount)\n\n    override fun draw() {\n        withGlContext {\n            val addSurfacesMs = timeSync { incorporateNewSurfaces() }\n\n            val bindFbMs = timeSync { instance.bindFramebuffer() }\n            val renderMs = timeSync { render() }\n\n            val readPxMs = timeSync {\n                instance.copyToPixelBuffer()\n            }\n\n            gl { gl.finish() }\n//            gl { glfwSwapBuffers(window) }\n\n//            println(\"Render of $pixelCount took: \" +\n//                    \"addSurface=${addSurfacesMs}ms \" +\n//                    \"bindFbMs=${bindFbMs}ms \" +\n//                    \"renderMs=${renderMs}ms \" +\n//                    \"readPxMs=${readPxMs}ms \" +\n//                    \"$this\")\n        }\n    }\n\n    private fun render() {\n        val thisTime = (getTimeMillis() and 0x7ffffff).toFloat() / 1000.0f\n\n        gl { gl.uniform2f(resolutionLocation.location, 1f, 1f) }\n        gl { gl.uniform1f(timeLocation.location, thisTime) }\n\n        instance.bindUvCoordTexture(uvCoordTextureIndex, uvCoordsLocation!!)\n        instance.bindUniforms()\n\n        gl { gl.viewport(0, 0, pixelCount.bufWidth, pixelCount.bufHeight) }\n        gl { gl.clear(GL.COLOR_BUFFER_BIT or GL.DEPTH_BUFFER_BIT) }\n\n        quad.render()\n\n        gl { gl.finish() }\n\n        val programLog = gl { gl.getProgramInfoLog(program) }\n        if (programLog != null && programLog.isNotEmpty()) println(\"ProgramInfoLog: $programLog\")\n    }\n\n    inner class SurfacePixels(\n        surface: IdentifiedSurface, pixel0Index: Int\n    ) : baaahs.glsl.SurfacePixels(surface, pixel0Index) {\n        override fun get(i: Int): Color = instance.getPixel(pixel0Index + i)\n    }\n\n    private fun createShaderProgram(): WebGLProgram? {\n        // Create a simple shader program\n        val program = gl { gl.createProgram() }\n        val vs = gl { gl.createShader(GL.VERTEX_SHADER) }\n        gl {\n            gl.shaderSource(\n                vs,\n                \"\"\"#version 300 es\n\nprecision lowp float;\n\n// xy = vertex position in normalized device coordinates ([-1,+1] range).\nin vec2 Vertex;\n\nconst vec2 scale = vec2(0.5, 0.5);\n\nvoid main()\n{\n    vec2 vTexCoords  = Vertex * scale + scale; // scale vertex attribute to [0,1] range\n    gl_Position = vec4(Vertex, 0.0, 1.0);\n}\n\"\"\"\n            )\n        }\n        compileShader(vs)\n\n        gl { gl.attachShader(program, vs) }\n        val fs = gl { gl.createShader(GL.FRAGMENT_SHADER) }\n\n        val src = \"\"\"#version 300 es\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform sampler2D sm_uvCoords;\nuniform float sm_uScale;\nuniform float sm_vScale;\nuniform float sm_startOfMeasure;\nuniform float sm_beat;\n\nout vec4 sm_fragColor;\n\n${fragShader\n            .replace(\n                Regex(\"void main\\\\s*\\\\(\\\\s*(void\\\\s*)?\\\\)\"),\n                \"void sm_main(vec2 sm_pixelCoord)\"\n            )\n            .replace(\"gl_FragCoord\", \"sm_pixelCoord\")\n            .replace(\"gl_FragColor\", \"sm_fragColor\")\n        }\n\n// Coming in, `gl_FragCoord` is a vec2 where `x` and `y` correspond to positions in `sm_uvCoords`.\n// We look up the `u` and `v` coordinates (which should be floats `[0..1]` in the mapping space) and\n// pass them to the shader's original `main()` method.\nvoid main(void) {\n    int uvX = int(gl_FragCoord.x);\n    int uvY = int(gl_FragCoord.y);\n    \n    vec2 pixelCoord = vec2(\n        texelFetch(sm_uvCoords, ivec2(uvX * 2, uvY), 0).r * sm_uScale,    // u\n        texelFetch(sm_uvCoords, ivec2(uvX * 2 + 1, uvY), 0).r * sm_vScale // v\n    );\n\n    sm_main(pixelCoord);\n}\n\"\"\"\n\n        println(src)\n        gl { gl.shaderSource(fs, src) }\n\n        compileShader(fs)\n\n        gl { gl.attachShader(program, fs) }\n        gl { gl.linkProgram(program) }\n        if (gl.getProgramParameter(program, GL.LINK_STATUS) == false) {\n            throw RuntimeException(\"ProgramInfoLog: ${gl.getProgramInfoLog(program)}\")\n        }\n\n        gl { gl.useProgram(program) }\n        return program\n    }\n\n    private fun compileShader(shader: WebGLShader?) {\n        gl { gl.compileShader(shader) }\n        if (gl.getShaderParameter(shader, GL.COMPILE_STATUS) == false) {\n            window.alert(\n                \"Failed to compile shader: ${gl.getShaderInfoLog(shader)}\\n\" +\n                        \"Version: ${gl.getParameter(GL.VERSION)}\\n\" +\n                        \"GLSL Version: ${gl.getParameter(GL.SHADING_LANGUAGE_VERSION)}\\n\"\n            )\n            throw RuntimeException(\"Failed to compile shader: ${gl.getShaderInfoLog(shader)}\")\n        }\n    }\n\n    fun <T> gl(fn: () -> T): T {\n        val result = fn.invoke()\n        checkForGlError(gl)\n        return result\n    }\n\n    override fun <T> withGlContext(fn: () -> T): T = fn()\n\n    companion object {\n        val GL = WebGLRenderingContext\n        val GL2 = WebGL2RenderingContext\n\n        fun checkForGlError(gl: WebGLRenderingContext) {\n            while (true) {\n                val error = gl.getError()\n                val code = when (error) {\n                    GL.INVALID_ENUM -> \"GL_INVALID_ENUM\"\n                    GL.INVALID_VALUE -> \"GL_INVALID_VALUE\"\n                    GL.INVALID_OPERATION -> \"GL_INVALID_OPERATION\"\n                    GL.INVALID_FRAMEBUFFER_OPERATION -> \"GL_INVALID_FRAMEBUFFER_OPERATION\"\n                    GL2.FRAMEBUFFER_INCOMPLETE_ATTACHMENT -> \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\"\n                    GL.CONTEXT_LOST_WEBGL -> \"GL_CONTEXT_LOST_WEBGL\"\n                    GL.OUT_OF_MEMORY -> \"GL_OUT_OF_MEMORY\"\n                    else -> \"unknown error $error\"\n                }\n                if (error != 0) throw RuntimeException(\"OpenGL Error: $code\") else return\n            }\n        }\n    }\n\n    inner class UnifyingAdjustableUniform(\n        val adjustableValue: GlslShader.AdjustableValue, val surfaceCount: Int\n    ) : AdjustibleUniform {\n        val uniformLocation = gl { getUniformLocation(adjustableValue.varName) }\n        var buffer: Any? = null\n\n        override fun bind() {\n            if (buffer != null) {\n                val location = uniformLocation.location\n\n                when (adjustableValue.valueType) {\n                    INT -> gl { gl.uniform1i(location, buffer as Int) }\n                    FLOAT -> gl { gl.uniform1f(location, buffer as Float) }\n                    VEC3 -> {\n                        val color = buffer as Color\n                        gl { gl.uniform3f(location, color.redF, color.greenF, color.blueF) }\n                    }\n                }\n            }\n        }\n\n        // last one wins!\n        override fun setValue(surfaceOrdinal: Int, value: Any?) {\n            buffer = value\n        }\n    }\n\n    inner class AwesomerAdjustableUniform(val adjustableValue: GlslShader.AdjustableValue, val surfaceCount: Int) {\n        // TODO: we should save these in an array, one for each surface, but let's keep it simple for now.\n        val elementCount: Int\n            get() = when (adjustableValue.valueType) {\n                INT -> surfaceCount\n                FLOAT -> surfaceCount\n                VEC3 -> surfaceCount * 3\n            }\n\n        val internalFormat: Int\n            get() = when (adjustableValue.valueType) {\n                INT -> GL.INT\n                FLOAT -> GL2.R32F\n                VEC3 -> GL.RGB\n            }\n\n        val buffer: ArrayBufferView = when (adjustableValue.valueType) {\n            INT -> Uint32Array(elementCount)\n            FLOAT -> Float32Array(elementCount)\n            VEC3 -> Float32Array(elementCount)\n        }\n\n        var texture = gl { gl.createTexture() }\n        val textureIndex = adjustableValueUniformIndices[adjustableValue.ordinal]\n        val uniformLocation = gl { gl.getUniformLocation(program, adjustableValue.varName) }\n\n        init {\n            gl { gl.activeTexture(GL.TEXTURE0 + textureIndex) }\n            gl { gl.bindTexture(GL.TEXTURE_2D, texture) }\n            gl { gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST) }\n            gl { gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST) }\n            gl {\n                gl.texImage2D(\n                    GL.TEXTURE_2D, 0, GL2.R32F, elementCount, 1, 0,\n                    GL2.RED, GL.FLOAT, null\n                )\n            }\n            gl { gl.uniform1i(uvCoordsLocation.location, textureIndex) }\n        }\n    }\n\n    inner class Instance(\n        pixelCount: Int, uvCoords: FloatArray, surfaceCount: Int\n    ) : GlslRenderer.Instance(pixelCount, uvCoords, surfaceCount) {\n        override val adjustableUniforms: Map<Int, AdjustibleUniform> =\n            adjustableValues.associate { adjustableValue ->\n                adjustableValue.ordinal to UnifyingAdjustableUniform(adjustableValue, surfaceCount)\n            }\n\n        private var uvCoordTexture = gl { gl.createTexture() }\n        private val frameBuffer = gl { gl.createFramebuffer() }\n        private val renderBuffer = gl { gl.createRenderbuffer() }\n        val pixelBuffer: Uint8Array = Uint8Array(pixelCount.bufSize * 4)\n\n        private val uvCoordsFloat32 = Float32Array(uvCoords.toTypedArray())\n\n        override fun bindFramebuffer() {\n            gl { gl.bindFramebuffer(GL.FRAMEBUFFER, frameBuffer) }\n\n            gl { gl.bindRenderbuffer(GL.RENDERBUFFER, renderBuffer) }\n//            console.error(\"pixel count: $pixelCount (${pixelCount.bufWidth} x ${pixelCount.bufHeight} = ${pixelCount.bufSize})\")\n            gl { gl.renderbufferStorage(GL.RENDERBUFFER, GL.RGBA4, pixelCount.bufWidth, pixelCount.bufHeight) }\n            gl { gl.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.RENDERBUFFER, renderBuffer) }\n\n            val status = gl { gl.checkFramebufferStatus(GL.FRAMEBUFFER) }\n            if (status != GL.FRAMEBUFFER_COMPLETE) {\n                throw RuntimeException(\"FrameBuffer huh? $status\")\n            }\n        }\n\n        override fun bindUvCoordTexture(textureIndex: Int, uvCoordsLocation: Uniform) {\n            gl { gl.activeTexture(GL.TEXTURE0 + textureIndex) }\n            gl { gl.bindTexture(GL.TEXTURE_2D, uvCoordTexture) }\n            gl { gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST) }\n            gl { gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST) }\n            gl {\n                gl.texImage2D(\n                    GL.TEXTURE_2D, 0, GL2.R32F, pixelCount.bufWidth * 2, pixelCount.bufHeight, 0,\n                    GL2.RED, GL.FLOAT, uvCoordsFloat32\n                )\n            }\n            gl { gl.uniform1i(uvCoordsLocation.location, textureIndex) }\n        }\n\n        override fun getPixel(pixelIndex: Int): Color {\n            val offset = pixelIndex * 4\n            return Color(\n                red = pixelBuffer[offset],\n                green = pixelBuffer[offset + 1],\n                blue = pixelBuffer[offset + 2],\n                alpha = pixelBuffer[offset + 3]\n            )\n        }\n\n        override fun copyToPixelBuffer() {\n            gl {\n                gl.readPixels(\n                    0,\n                    0,\n                    pixelCount.bufWidth,\n                    pixelCount.bufHeight,\n                    GL.RGBA,\n                    GL.UNSIGNED_BYTE,\n                    pixelBuffer\n                )\n            }\n        }\n\n        override fun release() {\n            println(\"Release $this with $pixelCount pixels and ${uvCoords.size} uvs\")\n\n            gl { gl.bindRenderbuffer(GL.RENDERBUFFER, null) }\n            gl { gl.bindFramebuffer(GL.FRAMEBUFFER, null) }\n            gl { gl.bindTexture(GL.TEXTURE_2D, null) }\n\n            gl { gl.deleteFramebuffer(frameBuffer) }\n            gl { gl.deleteRenderbuffer(renderBuffer) }\n            gl { gl.deleteTexture(uvCoordTexture) }\n        }\n    }\n\n    private val Uniform?.location: WebGLUniformLocation? get() = this?.locationInternal as WebGLUniformLocation?\n}\n","package baaahs\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\n\n@Serializable\ndata class BeatData(\n    /** Some moment in history when we saw a beat 1. */\n    val measureStartTimeMs: Time,\n\n    val beatIntervalMs: Int,\n\n    val beatsPerMeasure: Int = 4,\n\n    val confidence: Float = 1f\n) {\n    @Transient val bpm: Float\n        get() {\n            if (beatIntervalMs == 0) return 0.0.toFloat()\n            return (60_000 / beatIntervalMs).toFloat()\n        }\n\n    fun beatWithinMeasure(clock: Clock): Float {\n        val elapsedSinceStartOfMeasure = clock.now() - measureStartTimeMs\n        return ((elapsedSinceStartOfMeasure / beatIntervalMs).toFloat()) % beatsPerMeasure\n    }\n\n    fun timeSinceMeasure(clock: Clock): Float {\n        val elapsedSinceStartOfMeasure = clock.now() - measureStartTimeMs\n        return (elapsedSinceStartOfMeasure / beatIntervalMs).toFloat()\n    }\n\n    /** Returns 1.0 if we're on a beat, 0.0 when we're furthest from the last beat,\n     * and anywhere in between otherwise. */\n    fun fractionTilNextBeat(clock: Clock): Float =\n        1 - beatWithinMeasure(clock) % 1.0f\n\n    /** Returns 1.0 if we're on the start of the measure, 0.0 when we're furthest from the start of the measure,\n     * and anywhere in between otherwise. */\n    fun fractionTilNextMeasure(clock: Clock): Float =\n        1 - timeSinceMeasure(clock)\n}\n\n\ninterface BeatSource {\n    fun getBeatData(): BeatData\n}\n\ntypealias Time = Double\n\ninterface Clock {\n    fun now(): Time\n}\n",null,"package baaahs\n\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlinx.serialization.*\nimport kotlinx.serialization.internal.IntDescriptor\nimport kotlin.js.JsName\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sqrt\nimport kotlin.random.Random\n\n/**\n * Canonical representation of a color.\n */\n@Serializable\ndata class Color(val argb: Int) {\n    /** Values are bounded at `0f..1f`. */\n    constructor(red: Float, green: Float, blue: Float, alpha: Float = 1f) : this(asArgb(red, green, blue, alpha))\n\n    /** Values are bounded at `0..255`. */\n    constructor(red: Int, green: Int, blue: Int, alpha: Int = 255) : this(asArgb(red, green, blue, alpha))\n\n    /** Values are bounded at `0..255` (but really `-128..127` because signed). */\n    // TODO: use UByte.\n    constructor(red: Byte, green: Byte, blue: Byte, alpha: Byte = 255.toByte()) : this(asArgb(red, green, blue, alpha))\n\n    fun serialize(writer: ByteArrayWriter) = writer.writeInt(argb)\n\n    @Transient\n    val alphaB: Byte\n        get() = alphaI(argb).toByte()\n    @Transient\n    val redB: Byte\n        get() = redI(argb).toByte()\n    @Transient\n    val greenB: Byte\n        get() = greenI(argb).toByte()\n    @Transient\n    val blueB: Byte\n        get() = blueI(argb).toByte()\n\n    @Transient\n    val alphaI: Int\n        get() = alphaI(argb)\n    @Transient\n    val redI: Int\n        get() = redI(argb)\n    @Transient\n    val greenI: Int\n        get() = greenI(argb)\n    @Transient\n    val blueI: Int\n        get() = blueI(argb)\n\n    @Transient\n    val alphaF: Float\n        get() = alphaI.toFloat() / 255\n    @Transient\n    val redF: Float\n        get() = redI.toFloat() / 255\n    @Transient\n    val greenF: Float\n        get() = greenI.toFloat() / 255\n    @Transient\n    val blueF: Float\n        get() = blueI.toFloat() / 255\n\n    fun alphaI(value: Int) = value shr 24 and 0xff\n    fun redI(value: Int) = value shr 16 and 0xff\n    fun greenI(value: Int) = value shr 8 and 0xff\n    fun blueI(value: Int) = value and 0xff\n\n    val rgb: Int get() = argb and 0xffffff\n    fun toInt(): Int = argb\n\n    @JsName(\"toHexString\")\n    fun toHexString() =\n        \"#\" + maybe(alphaI) + redI.toHexString() + greenI.toHexString() + blueI.toHexString()\n\n    private fun maybe(alphaI: Int): String = if (alphaI == 255) \"\" else alphaI.toHexString()\n\n    fun Int.toHexString(): String {\n        if (this < 0) {\n            throw Exception(\"can't toHexString() negative ints\")\n        }\n\n        if (this < 16) {\n            return \"0\" + toString(16)\n        } else {\n            return toString(16)\n        }\n    }\n\n    /** Super-naive approximation of desaturation. */\n    fun withSaturation(saturation: Float): Color {\n        val desaturation = 1 - saturation\n        return Color(\n            redF + (1 - redF) * desaturation,\n            greenF + (1 - greenF) * desaturation,\n            blueF + (1 - blueF) * desaturation,\n            alphaF\n        )\n    }\n\n    fun distanceTo(other: Color): Float {\n        val dist = square(other.redF - redF) + square(other.greenF - greenF) + square(other.blueF - blueF)\n        return sqrt(dist / 3)\n    }\n\n    private fun square(f: Float) = f * f\n\n    fun plus(other: Color): Color =\n        Color(redI + other.redI, greenI + other.greenI, blueI + other.blueI, alphaI)\n\n    fun fade(other: Color, amount: Float = 0.5f): Color {\n        val amountThis = 1 - amount\n\n        return Color(\n            redF * amountThis + other.redF * amount,\n            greenF * amountThis + other.greenF * amount,\n            blueF * amountThis + other.blueF * amount,\n            alphaF * amountThis + other.alphaF * amount\n        )\n    }\n\n    fun opaque(): Color = Color(argb or 0xff000000.toInt())\n\n    override fun toString(): String {\n        return \"Color(${toHexString()})\"\n    }\n\n    @Serializer(forClass = Color::class)\n    companion object : KSerializer<Color> {\n        val BLACK = Color(0, 0, 0)\n        val WHITE = Color(255, 255, 255)\n        val RED = Color(255, 0, 0)\n        val ORANGE = Color(255, 127, 0)\n        val YELLOW = Color(255, 255, 0)\n        val GREEN = Color(0, 255, 0)\n        val CYAN = Color(0, 255, 255)\n        val BLUE = Color(0, 0, 255)\n        val MAGENTA = Color(255, 0, 255)\n        val PURPLE = Color(200, 0, 212)\n        val TRANSPARENT = Color(0, 0, 0, 0)\n\n        fun random() = Color(\n            Random.nextInt() and 0xff,\n            Random.nextInt() and 0xff,\n            Random.nextInt() and 0xff\n        )\n\n        fun parse(reader: ByteArrayReader) = Color(reader.readInt())\n\n        @JsName(\"fromInt\")\n        fun from(i: Int) = Color(i)\n\n        @JsName(\"fromInts\")\n        fun from(r: Int, g: Int, b: Int) = Color(r, g, b)\n\n        @JsName(\"fromString\")\n        fun from(hex: String): Color {\n            var hexDigits = hex.trimStart('#')\n            val alpha = if (hexDigits.length == 8) {\n                hexDigits.substring(0, 2).toInt(16).also { hexDigits = hexDigits.substring(2) }\n            } else {\n                0xff\n            }\n\n            if (hexDigits.length == 6) {\n                // huh? that's not an Int already? I'm supposed to do twos-complement math and negate? blech Kotlin.\n                return Color(alpha shl 24 or hexDigits.toInt(16))\n            }\n            throw IllegalArgumentException(\"unknown color \\\"$hex\\\"\")\n        }\n\n        private fun asArgb(red: Float, green: Float, blue: Float, alpha: Float = 1f): Int {\n            val asArgb = asArgb(asInt(red), asInt(green), asInt(blue), asInt(alpha))\n            return asArgb\n        }\n\n        private fun asArgb(red: Int, green: Int, blue: Int, alpha: Int = 255): Int {\n            return ((bounded(alpha) shl 24)\n                    or (bounded(red) shl 16)\n                    or (bounded(green) shl 8)\n                    or (bounded(blue)))\n        }\n\n        private fun asArgb(red: Byte, green: Byte, blue: Byte, alpha: Byte = 255.toByte()): Int {\n            return ((bounded(alpha) shl 24)\n                    or (bounded(red) shl 16)\n                    or (bounded(green) shl 8)\n                    or (bounded(blue)))\n        }\n\n        private fun bounded(f: Float): Float = max(0f, min(1f, f))\n        private fun bounded(i: Int): Int = max(0, min(255, i))\n        private fun bounded(b: Byte): Int = b.toInt() and 0xff\n        private fun asInt(f: Float): Int = (bounded(f) * 255).toInt()\n\n        override val descriptor: SerialDescriptor = IntDescriptor.withName(\"Color\")\n        override fun serialize(encoder: Encoder, obj: Color) = encoder.encodeInt(obj.argb)\n        override fun deserialize(decoder: Decoder): Color = Color(decoder.decodeInt())\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","package baaahs\n\npublic class Config {\n    companion object {\n        val DMX_DEVICES: Map<String, Int> = mapOf(\n            Pair(\"leftEye\", 1),\n            Pair(\"rightEye\", 17)\n        )\n    }\n\n\n    class MovingHeadConfig(val deviceType: Dmx.DeviceType, val baseChannel: Int)\n}\n","package baaahs\n\nimport baaahs.net.Network\n\ninterface Display {\n    fun forNetwork(): NetworkDisplay\n    fun forPinky(): PinkyDisplay\n    fun forBrain(): BrainDisplay\n    fun forVisualizer(): VisualizerDisplay\n}\n\ninterface NetworkDisplay {\n    var packetLossRate: Float\n    fun receivedPacket()\n    fun droppedPacket()\n}\n\ninterface PinkyDisplay {\n    fun listShows(shows: List<Show>)\n\n    var brainCount: Int\n    var beat: Int\n    var bpm: Float\n    var beatConfidence: Float\n    var onShowChange: (() -> Unit)\n    var selectedShow: Show?\n    var showFrameMs: Int\n    var stats: Pinky.NetworkStats?\n}\n\nopen class StubPinkyDisplay : PinkyDisplay {\n    override fun listShows(shows: List<Show>) {\n    }\n\n    override var brainCount = 0\n    override var beat = 0\n    override var bpm = 0.0f\n    override var beatConfidence = 0.0f\n    override var onShowChange: () -> Unit = { }\n    override var selectedShow: Show? = null\n    override var showFrameMs: Int = 0\n    override var stats: Pinky.NetworkStats? = null\n}\n\ninterface BrainDisplay {\n    var id: String?\n    var surface: Surface?\n    var onReset: suspend () -> Unit\n    fun haveLink(link: Network.Link)\n}\n\ninterface VisualizerDisplay {\n    var renderMs: Int\n}","package baaahs\n\ninterface Dmx {\n    abstract class Universe {\n        abstract fun writer(baseChannel: Int, channelCount: Int): Buffer\n        abstract fun sendFrame()\n        abstract fun allOff()\n    }\n\n    class Buffer(private val channels: ByteArray, val baseChannel: Int, val channelCount: Int) {\n        operator fun get(channel: Channel): Byte = get(channel.offset)\n\n        operator fun get(index: Int): Byte {\n            boundsCheck(index)\n            return channels[baseChannel + index]\n        }\n\n        operator fun set(channel: Channel, value: Byte) = set(channel.offset, value)\n\n        operator fun set(index: Int, value: Byte) {\n            boundsCheck(index)\n            channels[baseChannel + index] = value\n        }\n\n        private fun boundsCheck(index: Int) {\n            if (index < 0 || index >= channelCount) {\n                throw Exception(\"index out of bounds: $index >= ${channelCount}\")\n            }\n        }\n    }\n\n    interface Channel {\n        val offset: Int\n    }\n\n    open class DeviceType(val channelCount: Int)\n}\n","package baaahs\n\ninterface FirmwareDaddy {\n    fun doesntLikeThisVersion(firmwareVersion: String?): Boolean\n\n    val urlForPreferredVersion: String\n}\n\nclass PermissiveFirmwareDaddy : FirmwareDaddy {\n    override fun doesntLikeThisVersion(firmwareVersion: String?): Boolean {\n        // False indicates this permissive daddy likes all firmwares\n        return false;\n    }\n\n    override val urlForPreferredVersion: String\n        get() = \"\"\n}\n\nclass StrictFirmwareDaddy(private val version: String, private val url: String) : FirmwareDaddy {\n    override fun doesntLikeThisVersion(firmwareVersion: String?): Boolean {\n        return version == firmwareVersion;\n    }\n\n    override val urlForPreferredVersion: String\n        get() = url\n}\n","package baaahs\n\nimport baaahs.gadgets.ColorPicker\nimport baaahs.gadgets.PalettePicker\nimport baaahs.gadgets.Slider\nimport kotlinx.serialization.*\nimport kotlinx.serialization.internal.ReferenceArraySerializer\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonConfiguration\nimport kotlinx.serialization.json.JsonElement\nimport kotlinx.serialization.modules.SerializersModule\nimport kotlin.js.JsName\nimport kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KClass\nimport kotlin.reflect.KProperty\n\n/**\n * Base class for user input gadgets.\n *\n * Gadgets may be requested by a [Show]:\n *\n * ```kotlin\n * val sparklinessSlider = showRunner.getGadget(Slider(\"Sparkliness\"))\n *\n * fun nextFrame() {\n *   println(\"Sparkliness is ${sparklinessSlider.value}.\")\n * }\n * ```\n *\n * Mutable values in a gadget should be declared like this:\n *\n * ```kotlin\n *     var value: Float by updatable(\"value\", initialValue, Float.serializer())\n * ```\n *\n * Mutable values _should not_ be included in tests for equality.\n */\nopen class Gadget {\n    @Transient\n    private val listeners = mutableSetOf<GadgetListener>()\n\n    @JsName(\"listen\")\n    fun listen(gadgetListener: GadgetListener) {\n        if (!listeners.add(gadgetListener)) throw IllegalStateException(\"$gadgetListener already listening to $this\")\n    }\n\n    @JsName(\"unlisten\")\n    fun unlisten(gadgetListener: GadgetListener) {\n        if (!listeners.remove(gadgetListener)) throw IllegalStateException(\"$gadgetListener isn't listening to $this\")\n    }\n\n    fun changed() = listeners.forEach { it.invoke(this) }\n\n    fun withoutTriggering(gadgetListener: GadgetListener, fn: () -> Unit) {\n        unlisten(gadgetListener)\n        try {\n            fn()\n        } finally {\n            listen(gadgetListener)\n        }\n    }\n\n    protected fun <T> updatable(name: String, initialValue: T, serializer: KSerializer<T>) =\n        GadgetValueObserver(name, initialValue, serializer, state) { changed() }\n\n    /**\n     * Implementing child classes should change their state a little bit in some valid way, as if a user had done it.\n     */\n    open fun adjustALittleBit() {\n    }\n\n    val state: MutableMap<String, JsonElement> = hashMapOf()\n}\n\ntypealias GadgetListener = (Gadget) -> Unit\n\nclass GadgetValueObserver<T>(\n    val name: String,\n    val initialValue: T,\n    private val serializer: KSerializer<T>,\n    val data: MutableMap<String, JsonElement>,\n    val onChange: () -> Unit\n) : ReadWriteProperty<Gadget, T> {\n    override fun getValue(thisRef: Gadget, property: KProperty<*>): T {\n        val value = data[name]\n        return if (value == null) initialValue else {\n            jsonParser.fromJson(serializer, value)\n        }\n    }\n\n    override fun setValue(thisRef: Gadget, property: KProperty<*>, value: T) {\n        if (getValue(thisRef, property) != value) {\n            data[name] = jsonParser.toJson(serializer, value)\n            onChange()\n        }\n    }\n}\n\n@Serializable()\nclass GadgetData(val name: String, @Polymorphic var gadget: Gadget, val topicName: String)\n\nval GadgetDataSerializer = (String.serializer() to JsonElement.serializer()).map\n\nclass GadgetDisplay(pubSub: PubSub.Client, onUpdatedGadgets: (Array<GadgetData>) -> Unit) {\n    val activeGadgets = mutableListOf<GadgetData>()\n    val channels = hashMapOf<String, PubSub.Channel<Map<String, JsonElement>>>()\n\n    init {\n        pubSub.subscribe(Topics.activeGadgets) { gadgetDatas ->\n            activeGadgets.clear()\n            channels.forEach { it.value.unsubscribe() }\n            channels.clear()\n\n            gadgetDatas.forEach { gadgetData ->\n                val gadget = gadgetData.gadget\n                val topicName = gadgetData.topicName\n\n                val listener: GadgetListener = {\n                    val observer = channels[topicName]\n                    if (observer == null) {\n                        println(\"Huh, no observer for $topicName; discarding update (know about ${channels.keys})\")\n                    } else {\n                        observer.onChange(it.state)\n                    }\n                }\n                gadget.listen(listener)\n\n                channels[topicName] =\n                    pubSub.subscribe(PubSub.Topic(topicName, GadgetDataSerializer)) { json ->\n                        gadget.apply {\n                            withoutTriggering(listener) {\n                                gadget.state.putAll(json)\n                                gadget.changed()\n                            }\n                        }\n                    }\n\n                activeGadgets.add(gadgetData)\n            }\n\n            onUpdatedGadgets(activeGadgets.toTypedArray())\n        }\n    }\n}\n\nval gadgetModule = SerializersModule {\n    polymorphic(Gadget::class) {\n        ColorPicker::class with ColorPicker.serializer()\n        PalettePicker::class with PalettePicker.serializer()\n        Slider::class with Slider.serializer()\n    }\n}\n\nprivate val jsonParser = Json(JsonConfiguration.Stable)\n\nfun <T : Any> KSerializer<T>.array(kKlass: KClass<T>): KSerializer<Array<T>> = ReferenceArraySerializer(kKlass, this)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxBy(selector)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWith(comparator)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minBy(selector)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWith(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n","package baaahs\n\nimport com.soywiz.klock.DateTime\nimport kotlinx.serialization.json.JsonElement\nimport kotlin.random.Random\n\nclass GadgetManager(private val pubSub: PubSub.Server) {\n    private val activeGadgets = mutableListOf<GadgetData>()\n    private val activeGadgetChannel = pubSub.publish(Topics.activeGadgets, activeGadgets) { }\n\n    private val gadgets = mutableMapOf<String, GadgetInfo>()\n    private val priorRequestedGadgets = mutableListOf<Pair<String, Gadget>>()\n    var lastUserInteraction = DateTime.now()\n\n    fun clear() {\n        gadgets.values.forEach { gadgetChannel -> gadgetChannel.channel.unsubscribe() }\n        gadgets.clear()\n        activeGadgets.clear()\n    }\n\n    fun sync(\n        requestedGadgets: List<Pair<String, Gadget>>,\n        restoreState: Map<String, Map<String, JsonElement>> = emptyMap()\n    ) {\n        // First, update state on new gadgets.\n        requestedGadgets.forEach { (name, gadget) ->\n            restoreState[name]?.let { state -> gadget.state.putAll(state) }\n        }\n\n        if (priorRequestedGadgets == requestedGadgets) {\n            requestedGadgets.zip(priorRequestedGadgets).forEach { (new, old) ->\n                val (name, oldGadget) = old\n                val newGadget = new.second\n\n                val gadgetInfo = gadgets[name]!!\n                gadgetInfo.channel.replaceOnUpdate { updated -> newGadget.state.putAll(updated) }\n                gadgetInfo.gadgetData.gadget.unlisten(gadgetInfo.gadgetChannelListener)\n                gadgetInfo.gadgetData.gadget = newGadget\n                newGadget.listen(gadgetInfo.gadgetChannelListener)\n\n                if (oldGadget.state != newGadget.state) {\n                    gadgetInfo.channel.onChange(newGadget.state)\n                }\n            }\n        } else {\n            logger.debug {\n                \"Gadgets don't match!\\n\" +\n                        \"old: ${priorRequestedGadgets}\\n\" +\n                        \"new: ${requestedGadgets}\"\n            }\n            activeGadgets.clear()\n            requestedGadgets.forEach { (name, gadget) ->\n                val topic =\n                    PubSub.Topic(\"/gadgets/$name\", GadgetDataSerializer)\n\n                val channel = pubSub.publish(topic, gadget.state) { updated -> gadget.state.putAll(updated) }\n                val gadgetData = GadgetData(name, gadget, topic.name)\n\n                activeGadgets.add(gadgetData)\n                val gadgetChannelListener: (Gadget) -> Unit = { gadget1 ->\n                    lastUserInteraction = DateTime.now()\n                    channel.onChange(gadget1.state)\n                }\n                gadgets[name] = GadgetInfo(topic, channel, gadgetData, gadgetChannelListener)\n                gadget.listen(gadgetChannelListener)\n            }\n            activeGadgetChannel.onChange(activeGadgets)\n        }\n\n        priorRequestedGadgets.clear()\n        priorRequestedGadgets.addAll(requestedGadgets)\n    }\n\n    fun getGadgetsState(): Map<String, Map<String, JsonElement>> {\n        return activeGadgets.associate { gadgetData ->\n            gadgetData.name to gadgetData.gadget.state\n        }\n    }\n\n    internal fun findGadget(name: String) = gadgets[name]?.gadgetData?.gadget\n    internal fun findGadgetInfo(name: String) = gadgets[name]\n\n    fun adjustSomething() {\n        activeGadgets.forEach { gadgetData ->\n            if (Random.nextFloat() < .1) {\n                gadgetData.gadget.adjustALittleBit()\n                gadgetData.gadget.changed()\n            }\n        }\n    }\n\n    class GadgetInfo(\n        val topic: PubSub.Topic<Map<String, JsonElement>>,\n        val channel: PubSub.Channel<Map<String, JsonElement>>,\n        val gadgetData: GadgetData,\n        val gadgetChannelListener: (Gadget) -> Unit\n    )\n\n    companion object {\n        val logger = Logger(\"GadgetManager\")\n    }\n}","package baaahs\n\nimport baaahs.imaging.Bitmap\nimport baaahs.imaging.Image\nimport kotlin.math.*\n\ninterface MediaDevices {\n    fun getCamera(): Camera\n\n    interface Camera {\n        var onImage: (image: Image) -> Unit\n\n        fun close()\n    }\n\n    data class Region(val x0: Int, val y0: Int, val x1: Int, val y1: Int) {\n        val width = x1 - x0\n        val height = y1 - y0\n\n        val centerX = (x1 - x0) / 2 + x0\n        val centerY = (y1 - y0) / 2 + y0\n\n        val xRange = x0 until x1\n        val yRange = y0 until y1\n\n        fun distanceTo(other: Region): Float {\n            val dX = centerX - other.centerX\n            val dY = centerY - other.centerY\n\n            return sqrt((dX * dX + dY * dY).toDouble()).toFloat()\n        }\n\n        fun intersectionWith(other: Region): Region {\n            val leftX = max(x0, other.x0)\n            val rightX = min(x1, x1)\n            val topY = max(y0, other.y0)\n            val bottomY = min(y1, other.y1)\n\n            return if (leftX < rightX && topY < bottomY) {\n                Region(leftX, topY, rightX, bottomY)\n            } else {\n                EMPTY\n            }\n        }\n\n        fun sqPix(): Float = sqrt((x1 - x0.toDouble()).pow(2) + (y1 - y0.toDouble()).pow(2)).toFloat()\n        fun scaled(fromX: Int, fromY: Int, toX: Int, toY: Int): Region {\n            return Region(\n                (x0.toFloat() / fromX * toX).toInt(),\n                (y0.toFloat() / fromX * toX).toInt(),\n                (x1.toFloat() / fromY * toY).toInt(),\n                (y1.toFloat() / fromY * toY).toInt()\n            )\n        }\n\n        fun isEmpty(): Boolean = width <= 0 || height <= 0\n\n        companion object {\n            val EMPTY = Region(-1, -1, -1, -1)\n\n            fun containing(bitmap: Bitmap) = Region(0, 0, bitmap.width, bitmap.height)\n            fun containing(image: Image) = Region(0, 0, image.width, image.height)\n        }\n    }\n}\n","package baaahs\n\nimport baaahs.dmx.Shenzarpy\nimport baaahs.geom.Vector3F\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class MovingHead(val name: String, val origin: Vector3F/*, val heading: Vector3F*/) {\n    enum class ColorMode {\n        ColorWheel,\n        RGB,\n        RGBW\n    }\n\n    interface Buffer {\n        val buffer: Dmx.Buffer\n        val panChannel: Dmx.Channel\n        val panFineChannel: Dmx.Channel?\n        val tiltChannel: Dmx.Channel\n        val tiltFineChannel: Dmx.Channel?\n        val dimmerChannel: Dmx.Channel\n\n        val supportsFinePositioning: Boolean\n            get() = panFineChannel != null && tiltFineChannel != null\n\n        var pan: Float\n            get() = getFloat(panChannel, panFineChannel)\n            set(value) = setFloat(panChannel, panFineChannel, value)\n\n        var tilt: Float\n            get() = getFloat(tiltChannel, tiltFineChannel)\n            set(value) = setFloat(tiltChannel, tiltFineChannel, value)\n\n        var dimmer: Float\n            get() = getFloat(dimmerChannel)\n            set(value) = setFloat(dimmerChannel, value)\n\n        var color: Color\n        val colorMode: ColorMode\n        val colorWheelColors: List<Shenzarpy.WheelColor>\n\n        fun closestColorFor(color: Color): Byte {\n            var bestMatch = Shenzarpy.WheelColor.WHITE\n            var bestDistance = 1f\n\n            colorWheelColors.forEach { wheelColor ->\n                val distance = wheelColor.color.distanceTo(color)\n                if (distance < bestDistance) {\n                    bestMatch = wheelColor\n                    bestDistance = distance\n                }\n            }\n\n            return bestMatch.ordinal.toByte()\n        }\n\n        private fun getFloat(channel: Dmx.Channel): Float {\n            val byteVal = buffer[channel].toInt() and 0xff\n            return ((byteVal shl 8) + byteVal) / 65535f\n        }\n\n        private fun getFloat(coarseChannel: Dmx.Channel, fineChannel: Dmx.Channel?): Float {\n            if (fineChannel == null) {\n                return getFloat(coarseChannel)\n            }\n\n            val firstByte = buffer[coarseChannel].toInt() and 0xff\n            val secondByte = buffer[fineChannel].toInt() and 0xff\n            val scaled = firstByte * 256 + secondByte\n            return scaled / 65535f\n        }\n\n        private fun setFloat(channel: Dmx.Channel, value: Float) {\n            val scaled = (value * 65535).toInt()\n            buffer[channel] = (scaled shr 8).toByte()\n        }\n\n        private fun setFloat(coarseChannel: Dmx.Channel, fineChannel: Dmx.Channel?, value: Float) {\n            if (fineChannel == null) {\n                return setFloat(coarseChannel, value)\n            }\n\n            val scaled = (value * 65535).toInt()\n            buffer[coarseChannel] = (scaled shr 8).toByte()\n            buffer[fineChannel] = (scaled and 0xff).toByte()\n        }\n    }\n\n    @Serializable\n    data class MovingHeadPosition(\n        val x: Int,\n        val y: Int\n    )\n}","package baaahs\n\nimport baaahs.io.Fs\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonConfiguration\nimport kotlin.js.JsName\n\nclass MovingHeadManager(private val fs: Fs, private val pubSub: PubSub.Server, movingHeads: List<MovingHead>) {\n    private val movingHeadsChannel = pubSub.publish(Topics.movingHeads, movingHeads) { }\n    private val defaultPosition = MovingHead.MovingHeadPosition(127, 127)\n    private val currentPositions = mutableMapOf<MovingHead, MovingHead.MovingHeadPosition>()\n    private val listeners = mutableMapOf<MovingHead, (MovingHead.MovingHeadPosition) -> Unit>()\n\n    private val movingHeadPresets = mutableMapOf<String, MovingHead.MovingHeadPosition>()\n    private val json = Json(JsonConfiguration.Stable)\n\n    private val presetsFileName = \"presets/moving-head-positions.json\"\n\n    init {\n        val presetsJson = fs.loadFile(presetsFileName)\n        if (presetsJson != null) {\n            val map = json.parse(Topics.movingHeadPresets.serializer, presetsJson)\n            movingHeadPresets.putAll(map)\n        }\n    }\n\n    private val movingHeadPresetsChannel =\n        pubSub.publish(\n            Topics.movingHeadPresets, mutableMapOf(\n                \"Disco Balls\" to MovingHead.MovingHeadPosition(123, 200)\n            )\n        ) { map ->\n            fs.createFile(presetsFileName, json.stringify(Topics.movingHeadPresets.serializer, map), true)\n            println(\"Saved $map to disk!\")\n        }\n\n    init {\n        movingHeads.map { movingHead ->\n            val topic = PubSub.Topic(\"movingHead/${movingHead.name}\", MovingHead.MovingHeadPosition.serializer())\n\n            currentPositions[movingHead] = defaultPosition\n            pubSub.publish(topic, defaultPosition) { onUpdate ->\n                currentPositions[movingHead] = onUpdate\n                listeners[movingHead]?.invoke(onUpdate)\n            }\n        }\n    }\n\n    fun listen(movingHead: MovingHead, onUpdate: (MovingHead.MovingHeadPosition) -> Unit) {\n        listeners[movingHead] = onUpdate\n    }\n}\n\nclass MovingHeadDisplay(val pubSub: PubSub.Client, onUpdatedMovingHeads: (Array<Wrapper>) -> Unit) {\n    init {\n        pubSub.subscribe(Topics.movingHeads) { movingHeads ->\n            val wrappers = movingHeads.map { movingHead -> Wrapper(movingHead, pubSub) }\n            onUpdatedMovingHeads(wrappers.toTypedArray())\n        }\n    }\n\n    private val presets = mutableMapOf<String, MovingHead.MovingHeadPosition>()\n    private val presetsListeners = mutableListOf<(String) -> Unit>()\n\n    private val movingHeadPresetsChannel =\n        pubSub.subscribe(Topics.movingHeadPresets) { map ->\n            presets.clear()\n            presets.putAll(map)\n            notifyPresetsListeners()\n        }\n\n    private fun notifyPresetsListeners() {\n        val json = Json.stringify(Topics.movingHeadPresets.serializer, presets)\n        presetsListeners.forEach { it.invoke(json) }\n    }\n\n    @JsName(\"savePreset\")\n    fun savePreset(name: String, position: MovingHead.MovingHeadPosition) {\n        presets[name] = position\n        movingHeadPresetsChannel.onChange(presets)\n        notifyPresetsListeners()\n    }\n\n    @JsName(\"addPresetsListener\")\n    fun addPresetsListener(callback: (String) -> Unit) {\n        presetsListeners.add(callback)\n    }\n\n    @JsName(\"removePresetsListener\")\n    fun removePresetsListener(callback: (String) -> Unit) {\n        presetsListeners.remove(callback)\n    }\n\n    class Wrapper(val movingHead: MovingHead, pubSub: PubSub.Client) {\n        private val topic = PubSub.Topic(\"movingHead/${movingHead.name}\", MovingHead.MovingHeadPosition.serializer())\n        private val listeners = mutableListOf<(MovingHead.MovingHeadPosition) -> Unit>()\n        private val channel: PubSub.Channel<MovingHead.MovingHeadPosition>? =\n            pubSub.subscribe(topic) { onUpdate ->\n                // TODO: the second time a moving head editor opens, this fires before channel has been set;\n                // TODO: onUpdate should be deferred until after subscribe() exits.\n                position = onUpdate\n            }\n\n        @JsName(\"name\")\n        val name: String\n            get() = movingHead.name\n\n        @JsName(\"position\")\n        var position: MovingHead.MovingHeadPosition? = null\n            set(value) {\n                field = value\n                if (value != null) notifyListeners(value)\n            }\n\n        private fun notifyListeners(value: MovingHead.MovingHeadPosition) {\n            // TODO: channel.onChange() is causing circular updates to PubSub server\n            channel?.onChange(value)\n            listeners.forEach { it.invoke(value) }\n        }\n\n        @JsName(\"addListener\")\n        fun addListener(callback: (MovingHead.MovingHeadPosition) -> Unit) {\n            listeners.add(callback)\n        }\n\n        @JsName(\"removeListener\")\n        fun removeListener(callback: (MovingHead.MovingHeadPosition) -> Unit) {\n            listeners.remove(callback)\n        }\n    }\n\n}\n","package baaahs\n\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport baaahs.net.Network\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.json.*\nimport kotlinx.serialization.modules.EmptyModule\nimport kotlinx.serialization.modules.SerialModule\nimport kotlinx.serialization.modules.plus\nimport kotlin.js.JsName\n\nabstract class PubSub {\n\n    companion object {\n        fun listen(httpServer: Network.HttpServer): Server {\n            return Server(httpServer)\n        }\n\n        fun connect(networkLink: Network.Link, address: Network.Address, port: Int): Client {\n            return Client(networkLink, address, port)\n        }\n\n        val logger = Logger(\"PubSub\")\n    }\n\n    open class Origin\n\n    interface Channel<T> {\n        @JsName(\"onChange\")\n        fun onChange(t: T)\n\n        fun replaceOnUpdate(onUpdate: (T) -> Unit)\n\n        fun unsubscribe()\n    }\n\n    data class Topic<T>(\n        val name: String,\n        val serializer: KSerializer<T>\n    )\n\n    abstract class Listener(private val origin: Origin) {\n        fun onUpdate(data: JsonElement, fromOrigin: Origin) {\n            if (origin !== fromOrigin) {\n                onUpdate(data)\n            }\n        }\n\n        abstract fun onUpdate(data: JsonElement)\n    }\n\n    class TopicInfo(val name: String, var data: JsonElement = JsonNull) {\n        val listeners: MutableList<Listener> = mutableListOf()\n\n        fun notify(jsonData: JsonElement, origin: Origin) {\n            if (jsonData != data) {\n                data = jsonData\n                listeners.forEach { listener -> listener.onUpdate(jsonData, origin) }\n            }\n        }\n    }\n\n    open class Connection(\n        private val name: String,\n        private val topics: MutableMap<String, TopicInfo>,\n        private val json: Json\n    ) : Origin(), Network.WebSocketListener {\n        protected var connection: Network.TcpConnection? = null\n        private val toSend: MutableList<ByteArray> = mutableListOf()\n        private val cleanup: MutableList<() -> Unit> = mutableListOf()\n\n        override fun connected(tcpConnection: Network.TcpConnection) {\n            debug(\"connection $this established\")\n            connection = tcpConnection\n            toSend.forEach { tcpConnection.send(it) }\n            toSend.clear()\n        }\n\n        override fun receive(tcpConnection: Network.TcpConnection, bytes: ByteArray) {\n            val reader = ByteArrayReader(bytes)\n            when (val command = reader.readString()) {\n                \"sub\" -> {\n                    val topicName = reader.readString()\n                    val topicInfo = topics[topicName] ?:\n                            throw IllegalArgumentException(\"Unknown topic $topicName\")\n\n                    val listener = object : Listener(this) {\n                        override fun onUpdate(data: JsonElement) = sendTopicUpdate(topicName, data)\n                    }\n                    topicInfo.listeners.add(listener)\n                    cleanup.add {\n                        topicInfo.listeners.remove(listener)\n                    }\n\n                    val topicData = topicInfo.data\n                    if (topicData != JsonNull) {\n                        listener.onUpdate(topicData)\n                    }\n                }\n\n                \"update\" -> {\n                    val topicName = reader.readString()\n                    val data = json.parseJson(reader.readString())\n                    val topicInfo = topics[topicName]\n                    topicInfo?.notify(data, this)\n                }\n\n                else -> {\n                    throw IllegalArgumentException(\"huh? don't know what to do with $command\")\n                }\n            }\n        }\n\n        fun sendTopicUpdate(name: String, data: JsonElement) {\n            debug(\"update $name $data\")\n\n            val writer = ByteArrayWriter()\n            writer.writeString(\"update\")\n            writer.writeString(name)\n            writer.writeString(json.stringify(JsonElementSerializer, data))\n            sendCommand(writer.toBytes())\n        }\n\n        fun sendTopicSub(topicName: String) {\n            debug(\"sub $topicName\")\n\n            val writer = ByteArrayWriter()\n            writer.writeString(\"sub\")\n            writer.writeString(topicName)\n            sendCommand(writer.toBytes())\n        }\n\n        override fun reset(tcpConnection: Network.TcpConnection) {\n            logger.info { \"PubSub client $name disconnected.\" }\n            cleanup.forEach { it.invoke() }\n        }\n\n        private fun sendCommand(bytes: ByteArray) {\n            val tcpConnection = connection\n            if (tcpConnection == null) {\n                toSend.add(bytes)\n            } else {\n                tcpConnection.send(bytes)\n            }\n        }\n\n        private fun debug(message: String) {\n            logger.debug { \"[PubSub $name -> ${connection?.toAddress ?: \"(deferred)\"}]: $message\" }\n        }\n    }\n\n    open class Endpoint {\n        var serialModule: SerialModule = EmptyModule\n        var json = Json(JsonConfiguration.Stable, serialModule)\n\n        fun install(toInstall: SerialModule) {\n            serialModule = serialModule.plus(toInstall)\n            json = Json(JsonConfiguration.Stable, serialModule)\n        }\n    }\n\n    class Server(httpServer: Network.HttpServer) : Endpoint() {\n        private val topics: MutableMap<String, TopicInfo> = hashMapOf()\n\n        init {\n            httpServer.listenWebSocket(\"/sm/ws\") { incomingConnection ->\n                Connection(\"server at ${incomingConnection.toAddress}\", topics, json)\n            }\n        }\n\n        fun <T : Any> publish(topic: Topic<T>, data: T, onUpdate: (T) -> Unit): Channel<T> {\n            val publisher = Origin()\n            val topicName = topic.name\n            val jsonData = json.toJson(topic.serializer, data)\n            val topicInfo = topics.getOrPut(topicName) { TopicInfo(topicName) }\n            val listener = PublisherListener(topic, publisher, onUpdate)\n            topicInfo.listeners.add(listener)\n            topicInfo.notify(jsonData, publisher)\n\n            return object : Channel<T> {\n                override fun onChange(t: T) {\n                    topicInfo.notify(json.toJson(topic.serializer, t), publisher)\n                }\n\n                override fun replaceOnUpdate(onUpdate: (T) -> Unit) {\n                    listener.onUpdate = onUpdate\n                }\n\n                override fun unsubscribe() {\n                    // TODO(\"${CLASS_NAME}.unsubscribe not implemented\")\n                }\n            }\n        }\n\n        internal fun getTopicInfo(topicName: String) = topics[topicName]\n\n        inner class PublisherListener<T : Any>(\n            private val topic: Topic<T>,\n            origin: Origin,\n            var onUpdate: (T) -> Unit\n        ) : Listener(origin) {\n            override fun onUpdate(data: JsonElement) {\n                onUpdate(json.fromJson(topic.serializer, data))\n            }\n        }\n    }\n\n    class Client(link: Network.Link, serverAddress: Network.Address, port: Int) : Endpoint() {\n        private val topics: MutableMap<String, TopicInfo> = hashMapOf()\n        private var server: Connection = Connection(\"client at ${link.myAddress}\", topics, json)\n\n        init {\n            link.connectWebSocket(serverAddress, port, \"/sm/ws\", server)\n        }\n\n        @JsName(\"subscribe\")\n        fun <T> subscribe(topic: Topic<T>, onUpdate: (T) -> Unit): Channel<T> {\n            val subscriber = Origin()\n\n            val topicName = topic.name\n            val topicInfo = topics.getOrPut(topicName) {\n                TopicInfo(topicName)\n                    .apply {\n                        listeners.add(object : Listener(server) {\n                            override fun onUpdate(data: JsonElement) = server.sendTopicUpdate(topicName, data)\n                        })\n                    }\n                    .also { server.sendTopicSub(topicName) }\n            }\n\n            val listener = object : Listener(subscriber) {\n                override fun onUpdate(data: JsonElement) = onUpdate(json.fromJson(topic.serializer, data))\n            }\n            topicInfo.listeners.add(listener)\n            val data = topicInfo.data\n            if (data != JsonNull) {\n                listener.onUpdate(data)\n            }\n\n            return object : Channel<T> {\n                override fun onChange(t: T) {\n                    val jsonData = json.toJson(topic.serializer, t)\n                    topicInfo.notify(jsonData, subscriber)\n                }\n\n                override fun replaceOnUpdate(onUpdate: (T) -> Unit) {\n                    TODO(\"Client.channel.replaceOnUpdate not implemented\")\n                }\n\n                override fun unsubscribe() {\n                    // TODO(\"${CLASS_NAME}.unsubscribe not implemented\")\n                }\n            }\n        }\n    }\n}","package baaahs\n\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport baaahs.shaders.*\n\nenum class ShaderId(val reader: ShaderReader<*>) {\n    SOLID(SolidShader),\n    PIXEL(PixelShader),\n    SINE_WAVE(SineWaveShader),\n    COMPOSITOR(CompositorShader),\n    SPARKLE(SparkleShader),\n    SIMPLE_SPATIAL(SimpleSpatialShader),\n    HEART(HeartShader),\n    RANDOM(RandomShader),\n    GLSL_SHADER(GlslShader);\n\n    companion object {\n        val values = values()\n        fun get(i: Byte): ShaderId {\n            if (i > values.size || i < 0) {\n                throw Throwable(\"bad index for ShaderId: $i\")\n            }\n            return values[i.toInt()]\n        }\n    }\n}\n\ninterface ShaderReader<T : Shader<*>> {\n    fun parse(reader: ByteArrayReader): T\n}\n\ninterface RenderContext {\n    fun <T : PooledRenderer> registerPooled(key: Any, fn: () -> T): T\n}\n\nabstract class Shader<B : Shader.Buffer>(val id: ShaderId) {\n    open fun createRenderer(surface: Surface, renderContext: RenderContext): Renderer<B> {\n        return createRenderer(surface)\n    }\n\n    abstract fun createRenderer(surface: Surface): Renderer<B>\n\n    abstract fun createBuffer(surface: Surface): B\n\n    val descriptorBytes: ByteArray by lazy { toBytes() }\n\n    fun serialize(writer: ByteArrayWriter) {\n        writer.writeByte(id.ordinal.toByte())\n        serializeConfig(writer)\n    }\n\n    /** Override if your shader has static configuration that needs to be shared with the Renderer. */\n    open fun serializeConfig(writer: ByteArrayWriter) {\n    }\n\n    private fun toBytes(): ByteArray {\n        val writer = ByteArrayWriter()\n        serialize(writer)\n        return writer.toBytes()\n    }\n\n    abstract fun readBuffer(reader: ByteArrayReader): B\n\n    companion object {\n        fun parse(reader: ByteArrayReader): Shader<*> {\n            val shaderTypeI = reader.readByte()\n            val shaderType = ShaderId.get(shaderTypeI)\n            return shaderType.reader.parse(reader)\n        }\n    }\n\n    interface Buffer {\n        val shader: Shader<*>\n\n        fun serialize(writer: ByteArrayWriter)\n\n        /**\n         * Read new data into an existing buffer (as efficiently as possible).\n         */\n        fun read(reader: ByteArrayReader)\n    }\n\n    interface Renderer<B : Buffer> {\n        fun beginFrame(buffer: B, pixelCount: Int) {}\n        fun draw(buffer: B, pixelIndex: Int): Color\n        fun endFrame() {}\n    }\n}\n\n/**\n * If a [Shader.Renderer] implements [PooledRenderer] and pixel prerendering is enabled on Pinky,\n * then the drawing cycle will look like this:\n *\n * - shader.createRenderer()\n * - rendererN*.beginFrame()\n * - pooledRenderer.preDraw()\n * - rendererN*.draw()\n * - rendererN*.endFrame()\n */\ninterface PooledRenderer {\n    fun preDraw()\n}\n\ninterface Pixels : Iterable<Color> {\n    val size: Int\n\n    val indices: IntRange\n        get() = IntRange(0, size - 1)\n\n    operator fun get(i: Int): Color\n    operator fun set(i: Int, color: Color)\n\n    fun set(colors: Array<Color>)\n\n    fun finishedFrame() {}\n\n    override fun iterator(): Iterator<Color> {\n        return object : Iterator<Color> {\n            private var i = 0\n\n            override fun hasNext(): Boolean = i < size\n\n            override fun next(): Color = get(i++)\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","package baaahs\n\nimport baaahs.geom.Vector3F\nimport baaahs.geom.center\nimport baaahs.geom.extents\n\nabstract class Model<T : Model.Surface> {\n    abstract val movingHeads: List<MovingHead>\n    abstract val allSurfaces: List<T>\n\n    private val allSurfacesByName: Map<String, T> by lazy { allSurfaces.associateBy { it.name } }\n\n    fun findModelSurface(name: String) =\n        allSurfacesByName[name] ?: throw RuntimeException(\"no such model surface $name\")\n\n    val allVertices by lazy {\n        val allVertices = hashSetOf<Vector3F>()\n        allSurfaces.map { allVertices.addAll(it.allVertices()) }\n        allVertices\n    }\n    val modelExtents by lazy {\n        extents(allVertices)\n    }\n\n    val modelCenter by lazy {\n        center(allVertices)\n    }\n\n    /** A named surface in the geometry model. */\n    interface Surface {\n        val name: String\n        val description: String\n        fun allVertices(): Collection<Vector3F>\n    }\n}\n\nclass SheepModel : Model<SheepModel.Panel>() {\n    lateinit var vertices: List<Vector3F>\n    lateinit var panels: List<Panel>\n\n    lateinit var eyes: List<MovingHead>\n\n    val allPanels: List<Panel>\n        get() = panels\n    val partySide: List<Panel>\n        get() = panels.filter { panel -> Regex(\"P$\").matches(panel.name) }\n\n    override val movingHeads: List<MovingHead> get() = eyes\n    override val allSurfaces get() = allPanels\n    lateinit var panelNeighbors: Map<Panel, List<Panel>>\n\n    fun load() {\n        val vertices: MutableList<Vector3F> = mutableListOf()\n        val panels: MutableList<Panel> = mutableListOf()\n        var currentPanel = Panel(\"initial\")\n\n        val panelsByEdge = mutableMapOf<List<Int>, MutableList<Panel>>()\n        val edgesByPanel = mutableMapOf<Panel, MutableList<List<Int>>>()\n\n        getResource(\"baaahs-model.obj\")\n            .split(\"\\n\")\n            .map { it.trim() }\n            .forEach { line ->\n                val parts = line.split(\" \")\n                val args = parts.subList(1, parts.size)\n\n                when (parts[0]) {\n                    \"v\" -> {\n                        if (args.size != 3) throw Exception(\"invalid vertex line: $line\")\n                        val coords = args.map { it.toFloat() }\n                        vertices.add(Vector3F(coords[0], coords[1], coords[2]))\n                    }\n                    \"o\" -> {\n                        val name = args.joinToString(\" \")\n                        currentPanel = Panel(name)\n                        panels.add(currentPanel)\n                    }\n                    \"f\" -> {\n                        val verts = args.map { it.toInt() - 1 }\n                        currentPanel.faces.faces.add(Face(verts))\n                    }\n                    \"l\" -> {\n                        val verts = args.map { it.toInt() - 1 }\n                        val points = mutableListOf<Vector3F>()\n                        for (vi in verts) {\n                            val v = vertices[vi]\n                            points.add(v)\n                        }\n\n                        val sortedVerts = verts.sorted()\n                        panelsByEdge.getOrPut(sortedVerts) { mutableListOf() }.add(currentPanel)\n                        edgesByPanel.getOrPut(currentPanel) { mutableListOf() }.add(sortedVerts)\n\n                        currentPanel.lines.add(Line(points))\n                    }\n                }\n            }\n\n        println(\"Sheep model has ${panels.size} panels (and ${vertices.size} vertices)!\")\n        this.vertices = vertices\n        this.panels = panels\n\n        fun neighborsOf(panel: Panel): List<Panel> {\n            return edgesByPanel[panel]\n                ?.flatMap { panelsByEdge[it]?.toList() ?: emptyList() }\n                ?.filter { it != panel }\n                ?: emptyList()\n        }\n\n        panelNeighbors = allPanels.associateWith { neighborsOf(it) }\n\n        eyes = arrayListOf(\n            MovingHead(\"leftEye\", Vector3F(0f, 204.361f, 48.738f)),\n            MovingHead(\"rightEye\", Vector3F(0f, 204.361f, -153.738f))\n        )\n    }\n\n    fun neighborsOf(panel: Panel) = panelNeighbors[panel] ?: emptyList()\n\n    data class Line(val vertices: List<Vector3F>)\n\n    class Face(val vertexIds: List<Int>)\n\n    class Faces {\n        val faces: MutableList<Face> = mutableListOf()\n    }\n\n    class Panel(override val name: String) : Surface {\n        val faces = Faces()\n        val lines = mutableListOf<Line>()\n\n        override fun allVertices(): Collection<Vector3F> {\n            val vertices = hashSetOf<Vector3F>()\n            vertices.addAll(lines.flatMap { it.vertices })\n            return vertices\n        }\n\n        override val description: String = \"Panel $name\"\n        override fun equals(other: Any?): Boolean = other is Panel && name == other.name\n        override fun hashCode(): Int = name.hashCode()\n    }\n\n}\n\n","package baaahs\n\n/** A show takes input from gadgets and uses it to configure shaders, creating pretty stuff on surfaces. */\nabstract class Show(val name: String) {\n\n    abstract fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer\n\n    interface Renderer {\n        /**\n         * Renders the next frame of the show.\n         *\n         * Try to keep this under 30ms or so.\n         */\n        fun nextFrame()\n\n        /**\n         * Called when surfaces are newly or no longer available to the show.\n         *\n         * If the show is able to reconfigure itself for the new set of shaders, it should do so and return `true`.\n         *\n         * @return true if the show should be reinitialized.\n         */\n        fun surfacesChanged(newSurfaces: List<Surface>, removedSurfaces: List<Surface>): Unit =\n            throw RestartShowException()\n    }\n\n    class RestartShowException : Exception()\n}\n","package baaahs\n\nimport baaahs.dmx.LixadaMiniMovingHead\nimport baaahs.shaders.CompositingMode\nimport baaahs.shaders.CompositorShader\n\nclass ShowRunner(\n    private val model: Model<*>,\n    initialShow: Show,\n    private val gadgetManager: GadgetManager,\n    private val beatSource: BeatSource,\n    private val dmxUniverse: Dmx.Universe,\n    private val movingHeadManager: MovingHeadManager,\n    internal val clock: Clock\n) {\n    var nextShow: Show? = initialShow\n    private var currentShow: Show? = null\n    private var currentShowRenderer: Show.Renderer? = null\n    private val changedSurfaces = mutableListOf<SurfacesChanges>()\n    private var totalSurfaceReceivers = 0\n\n    val allSurfaces: List<Surface> get() = surfaceReceivers.keys.toList()\n    val allUnusedSurfaces: List<Surface> get() = allSurfaces.minus(shaderBuffers.keys)\n\n    val allMovingHeads: List<MovingHead> get() = model.movingHeads\n\n    private val shaderBuffers: MutableMap<Surface, MutableList<Shader.Buffer>> = hashMapOf()\n\n    private var requestedGadgets: LinkedHashMap<String, Gadget> = linkedMapOf()\n\n    private var shadersLocked = true\n    private var gadgetsLocked = true\n\n    // Continuous from [0.0 ... 3.0] (0 is first beat in a measure, 3 is last)\n    val currentBeat: Float\n        get() = beatSource.getBeatData().beatWithinMeasure(clock)\n\n    fun getBeatSource(): BeatSource = beatSource\n\n    private fun recordShader(surface: Surface, shaderBuffer: Shader.Buffer) {\n        val buffersForSurface = shaderBuffers.getOrPut(surface) { mutableListOf() }\n\n        if (shaderBuffer is CompositorShader.Buffer) {\n            if (!buffersForSurface.remove(shaderBuffer.bufferA)\n                || !buffersForSurface.remove(shaderBuffer.bufferB)\n            ) {\n                throw IllegalStateException(\"Composite of unknown shader buffers!\")\n            }\n        }\n\n        buffersForSurface += shaderBuffer\n    }\n\n    /**\n     * Obtain a shader buffer which can be used to control the illumination of a surface.\n     *\n     * @param surface The surface we're shading.\n     * @param shader The type of shader.\n     * @return A shader buffer of the appropriate type.\n     */\n    fun <B : Shader.Buffer> getShaderBuffer(surface: Surface, shader: Shader<B>): B {\n        if (shadersLocked) throw IllegalStateException(\"Shaders can't be obtained during #nextFrame()\")\n        val buffer = shader.createBuffer(surface)\n        recordShader(surface, buffer)\n        return buffer\n    }\n\n    /**\n     * Obtain a compositing shader buffer which can be used to blend two other shaders together.\n     *\n     * The shaders must already have been obtained using [getShaderBuffer].\n     */\n    fun getCompositorBuffer(\n        surface: Surface,\n        bufferA: Shader.Buffer,\n        bufferB: Shader.Buffer,\n        mode: CompositingMode = CompositingMode.NORMAL,\n        fade: Float = 0.5f\n    ): CompositorShader.Buffer {\n        if (shadersLocked) throw IllegalStateException(\"Shaders can't be obtained during #nextFrame()\")\n        return CompositorShader(bufferA.shader, bufferB.shader)\n            .createBuffer(bufferA, bufferB)\n            .also {\n                it.mode = mode\n                it.fade = fade\n                recordShader(surface, it)\n            }\n    }\n\n    private fun getDmxBuffer(baseChannel: Int, channelCount: Int): Dmx.Buffer =\n        dmxUniverse.writer(baseChannel, channelCount)\n\n    fun getMovingHeadBuffer(movingHead: MovingHead): MovingHead.Buffer {\n        if (shadersLocked) throw IllegalStateException(\"Moving heads can't be obtained during #nextFrame()\")\n        val baseChannel = Config.DMX_DEVICES[movingHead.name]!!\n        val movingHeadBuffer = LixadaMiniMovingHead(getDmxBuffer(baseChannel, 16))\n\n        movingHeadManager.listen(movingHead) { updated ->\n            println(\"Moving head ${movingHead.name} moved to ${updated.x} ${updated.y}\")\n            movingHeadBuffer.pan = updated.x / 255f\n            movingHeadBuffer.tilt = updated.y / 255f\n        }\n\n        return movingHeadBuffer\n    }\n\n    /**\n     * Obtain a gadget that can be used to receive input from a user. The gadget will be displayed in the show's UI.\n     *\n     * @param name Symbolic name for this gadget; must be unique within the show.\n     * @param gadget The gadget to display.\n     */\n    fun <T : Gadget> getGadget(name: String, gadget: T): T {\n        if (gadgetsLocked) throw IllegalStateException(\"Gadgets can't be obtained during #nextFrame()\")\n        val oldValue = requestedGadgets.put(name, gadget)\n        if (oldValue != null) throw IllegalStateException(\"Gadget names must be unique ($name)\")\n        return gadget\n    }\n\n    fun surfacesChanged(addedSurfaces: Collection<SurfaceReceiver>, removedSurfaces: Collection<SurfaceReceiver>) {\n        changedSurfaces.add(SurfacesChanges(ArrayList(addedSurfaces), ArrayList(removedSurfaces)))\n    }\n\n    fun nextFrame() {\n        // Always generate and send the next frame right away, then perform any housekeeping tasks immediately\n        // afterward, to avoid frame lag.\n        currentShowRenderer?.let {\n            it.nextFrame()\n            send()\n        }\n\n        housekeeping()\n    }\n\n    private val surfaceReceivers = mutableMapOf<Surface, MutableList<SurfaceReceiver>>()\n\n    private fun housekeeping() {\n        for ((added, removed) in changedSurfaces) {\n            println(\"ShowRunner surfaces changed! ${added.size} added, ${removed.size} removed\")\n            for (receiver in removed) removeReceiver(receiver)\n            for (receiver in added) addReceiver(receiver)\n\n            if (nextShow == null) {\n                shadersLocked = false\n                try {\n                    currentShowRenderer?.surfacesChanged(added.map { it.surface }, removed.map { it.surface })\n\n                    logger.info {\n                        \"Show ${currentShow!!.name} updated; \" +\n                                \"${shaderBuffers.size} surfaces\"\n                    }\n                } catch (e: Show.RestartShowException) {\n                    // Show doesn't support changing surfaces, just restart it cold.\n                    nextShow = currentShow ?: nextShow\n                }\n                shadersLocked = true\n            }\n        }\n        changedSurfaces.clear()\n\n        if (totalSurfaceReceivers > 0) {\n            nextShow?.let { startingShow ->\n                createShowRenderer(startingShow)\n\n                currentShow = nextShow\n                nextShow = null\n            }\n        }\n    }\n\n    private fun createShowRenderer(startingShow: Show) {\n        shaderBuffers.clear()\n\n        val restartingSameShow = nextShow == currentShow\n        val gadgetsState = if (restartingSameShow) gadgetManager.getGadgetsState() else emptyMap()\n\n        unlockShadersAndGadgets {\n            currentShowRenderer = startingShow.createRenderer(model, this)\n        }\n\n        logger.info {\n            \"New show ${startingShow.name} created; \" +\n                    \"${shaderBuffers.size} surfaces \" +\n                    \"and ${requestedGadgets.size} gadgets\"\n        }\n\n        gadgetManager.sync(requestedGadgets.toList(), gadgetsState)\n        requestedGadgets.clear()\n    }\n\n    private fun unlockShadersAndGadgets(fn: () -> Unit) {\n        shadersLocked = false\n        gadgetsLocked = false\n\n        try {\n            fn()\n        } finally {\n            shadersLocked = true\n            gadgetsLocked = true\n        }\n    }\n\n    private fun addReceiver(receiver: SurfaceReceiver) {\n        receiversFor(receiver.surface).add(receiver)\n        totalSurfaceReceivers++\n    }\n\n    private fun removeReceiver(receiver: SurfaceReceiver) {\n        receiversFor(receiver.surface).remove(receiver)\n        shaderBuffers.remove(receiver.surface)\n        totalSurfaceReceivers--\n    }\n\n    private fun receiversFor(surface: Surface): MutableList<SurfaceReceiver> {\n        return surfaceReceivers.getOrPut(surface) { mutableListOf() }\n    }\n\n    fun send() {\n        shaderBuffers.forEach { (surface, shaderBuffers) ->\n            if (shaderBuffers.size != 1) {\n                throw IllegalStateException(\"Too many shader buffers for ${surface.describe()}: $shaderBuffers\")\n            }\n            val shaderBuffer = shaderBuffers.first()\n\n            receiversFor(surface).forEach { receiver ->\n                // TODO: The send might return an error, at which point this receiver should be nuked\n                // from the list of receivers for this surface. I'm not quite sure the best way to do\n                // that so I'm leaving this note.\n                receiver.send(shaderBuffer)\n            }\n        }\n\n        dmxUniverse.sendFrame()\n    }\n\n    fun shutDown() {\n        gadgetManager.clear()\n    }\n\n    data class SurfacesChanges(val added: Collection<SurfaceReceiver>, val removed: Collection<SurfaceReceiver>)\n\n    open class SurfaceReceiver(val surface: Surface, private val sendFn: (Shader.Buffer) -> Unit) {\n        open fun send(shaderBuffer: Shader.Buffer) = sendFn(shaderBuffer)\n    }\n\n    companion object {\n        val logger = Logger(\"ShowRunner\")\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n","package baaahs\n\nobject SparkleMotion {\n    const val MAX_PIXEL_COUNT = 2048\n    const val DEFAULT_PIXEL_COUNT = 512\n    const val PIXEL_COUNT_UNKNOWN = -1\n}","package baaahs\n\nimport baaahs.geom.Vector3F\n\n/**\n * Represents a surface whose lighting can be controlled.\n *\n * May or may not be associated with a [Model.Surface].\n */\ninterface Surface {\n    val pixelCount: Int\n\n    fun describe(): String\n}\n\n/**\n * A surface which has been associated with a specific [Model.Surface].\n */\nclass IdentifiedSurface(\n    val modelSurface: Model.Surface,\n    override val pixelCount: Int,\n    /** Each pixel's location in the global 3d model. */\n    val pixelLocations: List<Vector3F?>? = emptyList()\n) : Surface {\n    val name: String = modelSurface.name\n    override fun describe(): String = modelSurface.description\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null || this::class != other::class) return false\n\n        other as IdentifiedSurface\n\n        if (modelSurface != other.modelSurface) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        return modelSurface.hashCode()\n    }\n\n\n}\n\n/**\n * A surface whose identity isn't known.\n */\nclass AnonymousSurface(val brainId: BrainId) : Surface {\n    override val pixelCount = SparkleMotion.MAX_PIXEL_COUNT\n\n    override fun describe(): String = \"Anonymous surface at $brainId\"\n    override fun equals(other: Any?): Boolean = other is AnonymousSurface && brainId.equals(other.brainId)\n    override fun hashCode(): Int = brainId.hashCode()\n}\n","package baaahs\n\nimport kotlinx.serialization.list\nimport kotlinx.serialization.map\nimport kotlinx.serialization.serializer\n\nobject Topics {\n    val availableShows = PubSub.Topic(\"availableShows\", String.serializer().list)\n    val selectedShow = PubSub.Topic(\"selectedShow\", String.serializer())\n    val activeGadgets = PubSub.Topic(\"activeGadgets\", GadgetData.serializer().list)\n    val movingHeads = PubSub.Topic(\"movingHeads\", MovingHead.serializer().list)\n\n    val movingHeadPresets = PubSub.Topic(\n        \"movingHeadPresets\",\n        (String.serializer() to MovingHead.MovingHeadPosition.serializer()).map\n    )\n}","package baaahs.dmx\n\nimport baaahs.Color\nimport baaahs.Dmx\nimport baaahs.MovingHead\n\nclass LixadaMiniMovingHead(override val buffer: Dmx.Buffer) : Dmx.DeviceType(9), MovingHead.Buffer {\n    override val panChannel get() = Channel.PAN\n    override val panFineChannel: Dmx.Channel? get() = null /*Channel.PAN_FINE*/\n    override val tiltChannel: Dmx.Channel get() = Channel.TILT\n    override val tiltFineChannel: Dmx.Channel? get() = null /*Channel.TILT_FINE*/\n    override val dimmerChannel: Dmx.Channel get() = Channel.DIMMER\n    override var color: Color\n        get() = Color(buffer[Channel.RED], buffer[Channel.GREEN], buffer[Channel.BLUE])\n        set(value) {\n            buffer[Channel.RED] = value.redI.toByte()\n            buffer[Channel.GREEN] = value.greenI.toByte()\n            buffer[Channel.BLUE] = value.blueI.toByte()\n        }\n\n    override val colorMode: MovingHead.ColorMode get() = MovingHead.ColorMode.RGBW\n    override val colorWheelColors: List<Shenzarpy.WheelColor>\n        get() = throw UnsupportedOperationException()\n\n    init {\n        dimmer = 134 * 256 / 65535f\n        buffer[Channel.WHITE] = 255.toByte()\n        buffer[Channel.RED] = 255.toByte()\n        buffer[Channel.GREEN] = 255.toByte()\n        buffer[Channel.BLUE] = 255.toByte()\n    }\n\n    enum class Channel: Dmx.Channel {\n        PAN,\n//        PAN_FINE,\n        TILT,\n//        TILT_FINE,\n        DIMMER,\n        RED,\n        GREEN,\n        BLUE,\n        WHITE,\n        PAN_TILT_SPEED,\n//        COLOR_11,\n//        COLOR_12,\n//        COLOR_CONTROL,\n        COLOR_RESET;\n\n        override val offset = ordinal\n    }\n}","package baaahs.dmx\n\nimport baaahs.Color\nimport baaahs.Dmx\nimport baaahs.MovingHead\nimport baaahs.toRadians\n\nclass Shenzarpy(override val buffer: Dmx.Buffer) : Dmx.DeviceType(16), MovingHead.Buffer {\n    override val panChannel get() = Channel.PAN\n    override val panFineChannel: Dmx.Channel? get() = Channel.PAN_FINE\n    override val tiltChannel: Dmx.Channel get() = Channel.TILT\n    override val tiltFineChannel: Dmx.Channel? get() = Channel.TILT_FINE\n    override val dimmerChannel: Dmx.Channel get() = Channel.DIMMER\n    override var color: Color\n        get() = WheelColor.values[colorWheel.toInt()].color\n        set(value) { colorWheel = closestColorFor(value) }\n\n    override val colorMode: MovingHead.ColorMode get() = MovingHead.ColorMode.ColorWheel\n    override val colorWheelColors: List<WheelColor> = WheelColor.values.toList()\n\n    companion object {\n        val panRange = toRadians(0f)..toRadians(540f)\n        val tiltRange = toRadians(-110f)..toRadians(110f)\n    }\n\n    enum class WheelColor(val color: Color) {\n        RED(Color.from(0xc21e22)),\n        ORANGE(Color.from(0xeb8236)),\n        AQUAMARINE(Color.from(0x7cbc84)),\n        DEEP_GREEN(Color.from(0x12812f)),\n        LIGHT_GREEN(Color.from(0x9fc13f)),\n        LAVENDER(Color.from(0x8f74ab)),\n        PINK(Color.from(0xeb8182)),\n        YELLOW(Color.from(0xfeeb34)),\n        MAGENTA(Color.from(0xe11382)),\n        CYAN(Color.from(0x1ba7e8)),\n        CTO2(Color.from(0xf4c651)),\n        CTO1(Color.from(0xf4d88a)),\n        CTB(Color.from(0x97c7b8)),\n        DARK_BLUE(Color.from(0x085197)),\n        WHITE(Color.from(0xffffff));\n\n        companion object {\n            val values = values()\n            fun get(i: Byte) = values[i.toInt()]\n        }\n    }\n\n    enum class Channel : Dmx.Channel {\n        COLOR_WHEEL,\n        SHUTTER,\n        DIMMER,\n        GOBO_WHEEL,\n        PRISM,\n        PRISM_ROTATION,\n        MACRO,\n        FROST,\n        FOCUS,\n        PAN,\n        PAN_FINE,\n        TILT,\n        TILT_FINE,\n        PAN_TILT_SPEED,\n        RESET,\n        LAMP_CONTROL,\n        BLANK,\n        COLOR_WHEEL_SPEED,\n        DIM_PRISM_ATOM_SPEED,\n        GOBO_WHEEL_SPEED;\n\n\n        companion object {\n            val values = values()\n            fun get(i: Byte) = values[i.toInt()]\n        }\n\n        override val offset = ordinal\n    }\n\n    var colorWheel: Byte\n        get() = buffer[Channel.COLOR_WHEEL]\n        set(value) {\n            buffer[Channel.COLOR_WHEEL] = value\n        }\n\n    init {\n        dimmer = 1f\n    }\n}","package baaahs.gadgets\n\nimport baaahs.Color\nimport baaahs.Gadget\nimport kotlinx.serialization.Serializable\nimport kotlin.js.JsName\nimport kotlin.random.Random\n\n/** A gadget for picking a single color for a color palette. */\n@Serializable\ndata class ColorPicker(\n    /** The name for this color picker. */\n    val name: String,\n\n    /** The initial value for this color picker. */\n    val initialValue: Color = Color.WHITE\n) : Gadget() {\n\n    /** The selected color. */\n    @JsName(\"color\")\n    var color: Color by updatable(\"color\", initialValue, Color.serializer())\n\n    override fun adjustALittleBit() {\n        fun randomAmount() = Random.nextFloat() * .1f - .05f\n        color = Color(color.redF + randomAmount(), color.greenF + randomAmount(), color.blueF + randomAmount())\n    }\n}","package baaahs.gadgets\n\nimport baaahs.Color\nimport baaahs.Gadget\nimport baaahs.array\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.internal.ReferenceArraySerializer\nimport kotlinx.serialization.list\n\n/** A gadget for picking multiple colors. */\n@Serializable\ndata class PalettePicker(\n    /** The name for the palette picker. */\n    val name: String,\n\n    val initialColors: List<Color> = emptyList()\n) : Gadget() {\n    var colors: List<Color> by updatable(\"colors\", initialColors, Color.serializer().list)\n}\n","package baaahs.gadgets\n\nimport baaahs.Gadget\nimport baaahs.constrain\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.serializer\nimport kotlin.js.JsName\nimport kotlin.random.Random\n\n/** A gadget for adjusting a value using a slider. */\n@Serializable\ndata class Slider(\n    /** The name for this slider. */\n    val name: String,\n\n    /** The initial value for this slider. */\n    val initialValue: Float = 1f,\n\n    /** The minimum value for this slider. */\n    val minValue: Float = 0f,\n\n    /** The maximum value for this slider. */\n    val maxValue: Float = 1f,\n\n    /** The step value for the slider. Only used if minValue and maxValue are used. */\n    val stepValue: Float = 0.01f\n) : Gadget() {\n    /** The selected value. */\n    @JsName(\"value\")\n    var value: Float by updatable(\"value\", initialValue, Float.serializer())\n\n    override fun adjustALittleBit() {\n        val spread = maxValue - minValue\n        val amount = Random.nextFloat() * spread * .25f - spread * .125f\n        value = constrain(value + amount, minValue, maxValue)\n    }\n}","package baaahs.geom\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\nclass Matrix4(val elements: Array<Double>)","package baaahs.geom\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\nclass Vector2F(val x: Float, val y: Float) {\n    operator fun component1() = x\n    operator fun component2() = y\n\n    override fun toString(): String = \"Vector2F(x=$x, y=$y)\"\n}","package baaahs.geom\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.min\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\n@Serializable\ndata class Vector3F(val x: Float, val y: Float, val z: Float) {\n    fun min(other: Vector3F): Vector3F = Vector3F(min(x, other.x), min(y, other.y), min(z, other.z))\n\n    fun max(other: Vector3F): Vector3F = Vector3F(max(x, other.x), max(y, other.y), max(z, other.z))\n\n    fun plus(other: Vector3F): Vector3F = Vector3F(x + other.x, y + other.y, z + other.z)\n\n    fun minus(other: Vector3F): Vector3F = Vector3F(x - other.x, y - other.y, z - other.z)\n\n    fun times(scalar: Float): Vector3F = Vector3F(x * scalar, y * scalar, z * scalar)\n\n    fun normalize(): Vector3F {\n        val invLength = 1.0f / length()\n        return Vector3F(x * invLength, y * invLength, z * invLength)\n    }\n\n    fun length(): Float {\n        return sqrt(lengthSquared().toDouble()).toFloat()\n    }\n\n    private fun lengthSquared(): Float {\n        return x * x + y * y + z * z\n    }\n\n}\n\nfun center(vectors: Collection<Vector3F>): Vector3F {\n    val (min, max) = boundingBox(vectors)\n    val diff = max.minus(min)\n    return diff.times(0.5f).plus(min)\n}\n\nfun extents(vectors: Collection<Vector3F>): Vector3F {\n    val (min, max) = boundingBox(vectors)\n    return max.minus(min)\n}\n\nprivate fun boundingBox(vectors: Collection<Vector3F>): Pair<Vector3F, Vector3F> {\n    val min = vectors.reduce { acc, vector3F -> acc.min(vector3F) }\n    val max = vectors.reduce { acc, vector3F -> acc.max(vector3F) }\n    return Pair(min, max)\n}","package baaahs.glsl\n\nimport baaahs.Color\nimport baaahs.IdentifiedSurface\nimport baaahs.Model\nimport baaahs.Pixels\nimport baaahs.Surface\nimport baaahs.shaders.GlslShader\nimport kotlin.math.PI\nimport kotlin.math.abs\nimport kotlin.math.atan2\nimport kotlin.math.max\nimport kotlin.math.min\n\nexpect object GlslBase {\n    val manager: GlslManager\n}\n\ninterface GlslManager {\n    fun createRenderer(program: String, adjustableValues: List<GlslShader.AdjustableValue>): GlslRenderer\n}\n\nabstract class GlslRenderer(\n    val fragShader: String,\n    val adjustableValues: List<GlslShader.AdjustableValue>\n) {\n    val surfacesToAdd: MutableList<GlslSurface> = mutableListOf()\n    var pixelCount: Int = 0\n    var nextPixelOffset: Int = 0\n    var nextSurfaceOffset: Int = 0\n\n    val glslSurfaces: MutableList<GlslSurface> = mutableListOf()\n\n    val uvCoordTextureIndex = 0\n    var surfaceOrdinalTextureIndex = 1\n    var nextTextureIndex = 2\n    val adjustableValueUniformIndices = adjustableValues.map { nextTextureIndex++ }\n\n    // uniforms\n    internal var uvCoordsLocation: Uniform? = null\n    internal var matLocation: Uniform? = null\n    internal var resolutionLocation: Uniform? = null\n    internal var timeLocation: Uniform? = null\n\n    lateinit var instance: Instance\n\n    fun findUniforms() {\n        uvCoordsLocation = getUniformLocation(\"sm_uvCoords\", required = true)\n        resolutionLocation = getUniformLocation(\"resolution\")\n        timeLocation = getUniformLocation(\"time\")\n    }\n\n    fun addSurface(surface: Surface, uvTranslator: UvTranslator): GlslSurface? {\n        if (surface is IdentifiedSurface && surface.pixelLocations != null) {\n            val glslSurface = GlslSurface(\n                createSurfacePixels(surface, nextPixelOffset),\n                Uniforms(nextSurfaceOffset++),\n                uvTranslator\n            )\n            surfacesToAdd.add(glslSurface)\n            nextPixelOffset += surface.pixelCount\n            return glslSurface\n        }\n\n        return null\n    }\n\n    abstract fun createSurfacePixels(surface: IdentifiedSurface, pixelOffset: Int): SurfacePixels\n\n    abstract fun createInstance(pixelCount: Int, uvCoords: FloatArray, surfaceCount: Int): Instance\n\n    abstract fun draw()\n\n    abstract fun <T> withGlContext(fn: () -> T): T\n\n    abstract fun getUniformLocation(name: String, required: Boolean = false): Uniform\n\n    protected fun incorporateNewSurfaces() {\n        if (surfacesToAdd.isNotEmpty()) {\n            val oldUvCoords = instance.uvCoords\n            val newPixelCount = nextPixelOffset\n\n            withGlContext {\n                instance.release()\n            }\n\n            val newUvCoords = FloatArray(newPixelCount.bufSize * 2)\n            oldUvCoords.copyInto(newUvCoords)\n\n            surfacesToAdd.forEach {\n                val surface = it.pixels.surface\n                val uvTranslator = it.uvTranslator.forSurface(surface)\n\n                for (i in 0 until surface.pixelCount) {\n                    val uvOffset = (it.pixels.pixel0Index + i) * 2\n                    val (u, v) = uvTranslator.getUV(i)\n                    newUvCoords[uvOffset] = u     // u\n                    newUvCoords[uvOffset + 1] = v // v\n                }\n            }\n\n            withGlContext {\n                instance = createInstance(newPixelCount, newUvCoords, nextSurfaceOffset)\n                instance.bindUvCoordTexture(uvCoordTextureIndex, uvCoordsLocation!!)\n            }\n\n            pixelCount = newPixelCount\n            println(\"Now managing $pixelCount pixels.\")\n\n            glslSurfaces.addAll(surfacesToAdd)\n            surfacesToAdd.clear()\n        }\n    }\n\n    interface AdjustibleUniform {\n        fun bind()\n        fun setValue(surfaceOrdinal: Int, value: Any?)\n    }\n\n    abstract inner class Instance(val pixelCount: Int, val uvCoords: FloatArray, val surfaceCount: Int) {\n        abstract val adjustableUniforms: Map<Int, AdjustibleUniform>\n\n        abstract fun bindFramebuffer()\n        abstract fun bindUvCoordTexture(textureIndex: Int, uvCoordsLocation: Uniform)\n        abstract fun getPixel(pixelIndex: Int): Color\n        abstract fun copyToPixelBuffer()\n        abstract fun release()\n\n        fun bindUniforms() {\n            adjustableUniforms.forEach { (key, value) -> value.bind() }\n        }\n\n        fun setUniform(adjustableValue: GlslShader.AdjustableValue, surfaceOrdinal: Int, value: Any?) {\n            adjustableUniforms[adjustableValue.ordinal]!!.setValue(surfaceOrdinal, value)\n        }\n    }\n\n    class Uniform(val locationInternal: Any?)\n\n    val Int.bufWidth: Int get() = max(1, min(this, 1024))\n    val Int.bufHeight: Int get() = this / 1024 + 1\n    val Int.bufSize: Int get() = bufWidth * bufHeight\n\n    inner class Uniforms(internal val surfaceOrdinal: Int) {\n        fun updateFrom(values: Array<Any?>) {\n            adjustableValues.forEach {\n                instance.setUniform(it, surfaceOrdinal, values[it.ordinal])\n            }\n        }\n    }\n}\n\nclass GlslSurface(\n    val pixels: SurfacePixels,\n    val uniforms: GlslRenderer.Uniforms,\n    val uvTranslator: UvTranslator\n)\n\ninterface UvTranslator {\n    fun forSurface(surface: IdentifiedSurface): SurfaceUvTranslator\n\n    interface SurfaceUvTranslator {\n        fun getUV(pixelIndex: Int): Pair<Float, Float>\n    }\n}\n\nobject PanelSpaceUvTranslator : UvTranslator {\n    override fun forSurface(surface: IdentifiedSurface): UvTranslator.SurfaceUvTranslator {\n        val pixelLocations = surface.pixelLocations!!\n        return object : UvTranslator.SurfaceUvTranslator {\n            override fun getUV(pixelIndex: Int): Pair<Float, Float> {\n                val vector3F = pixelLocations[pixelIndex]\n                return (vector3F?.x ?: 0f) to (vector3F?.y ?: 0f)\n            }\n        }\n    }\n}\n\nclass ModelSpaceUvTranslator(val model: Model<*>) : UvTranslator {\n    val modelCenter = model.modelCenter\n    val modelExtents = model.modelExtents\n\n    override fun forSurface(surface: IdentifiedSurface): UvTranslator.SurfaceUvTranslator {\n        val pixelLocations = surface.pixelLocations!!\n        return object : UvTranslator.SurfaceUvTranslator {\n            override fun getUV(pixelIndex: Int): Pair<Float, Float> {\n                val pixelLocation = pixelLocations[pixelIndex] ?: modelCenter\n\n                val normalDelta = pixelLocation.minus(modelCenter).normalize()\n                var theta = atan2(abs(normalDelta.z), normalDelta.x) // theta in range [-\u03c0,\u03c0]\n                if (theta < 0.0f) theta += (2.0f * PI.toFloat()) // theta in range [0,2\u03c0)\n                val u = theta / (2.0f * PI.toFloat()) // u in range [0,1)\n                val v = (pixelLocation.minus(modelCenter).y + modelExtents.y / 2.0f) / modelExtents.y\n                return u to v\n            }\n        }\n    }\n}\n\nabstract class SurfacePixels(val surface: IdentifiedSurface, val pixel0Index: Int) : Pixels {\n    override val size: Int = surface.pixelCount\n    override fun set(i: Int, color: Color): Unit = TODO(\"set not implemented\")\n    override fun set(colors: Array<Color>): Unit = TODO(\"set not implemented\")\n}","package baaahs.imaging\n\nimport baaahs.MediaDevices\n\npublic interface Image {\n    val width: Int\n    val height: Int\n\n    fun toBitmap(): Bitmap\n}\n\npublic interface Bitmap {\n    val width: Int\n    val height: Int\n\n    fun drawImage(image: Image)\n\n    fun drawImage(\n        image: Image,\n        sX: Int, sY: Int, sWidth: Int, sHeight: Int,\n        dX: Int, dY: Int, dWidth: Int, dHeight: Int\n    )\n\n    fun copyFrom(other: Bitmap)\n\n    fun lighten(other: Bitmap)\n\n    fun darken(other: Bitmap)\n\n    fun subtract(other: Bitmap)\n\n    fun withData(\n        region: MediaDevices.Region = MediaDevices.Region.containing(this),\n        fn: (data: UByteClampedArray) -> Boolean\n    )\n\n    fun asImage(): Image\n    fun toDataUrl(): String\n\n    fun clone(): Bitmap\n}\n\ninterface UByteClampedArray {\n    val size: Int\n    operator fun get(index: Int): Int\n    operator fun set(index: Int, value: UByte)\n}\n\nexpect class NativeBitmap(width: Int, height: Int) : Bitmap","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()","package baaahs.io\n\nclass ByteArrayWriter(private var bytes: ByteArray = ByteArray(128), var offset: Int = 0) {\n    constructor(size: Int) : this(ByteArray(size))\n\n    fun writeBoolean(b: Boolean) {\n        growIfNecessary(1)\n        bytes[offset++] = if (b) 1 else 0\n    }\n\n    fun writeByte(b: Byte) {\n        growIfNecessary(1)\n        bytes[offset++] = b\n    }\n\n    fun writeShort(i: Int) {\n        if (i and 0xffff != i) {\n            throw IllegalArgumentException(\"$i doesn't fit in a short\")\n        }\n        writeShort(i.toShort())\n    }\n\n    fun writeShort(s: Short) {\n        growIfNecessary(2)\n        bytes[offset++] = s.toInt().shr(8).and(0xff).toByte()\n        bytes[offset++] = s.toInt().and(0xff).toByte()\n    }\n\n    fun writeChar(c: Char) = writeShort(c.toShort())\n\n    fun writeInt(i: Int) {\n        growIfNecessary(4)\n        bytes[offset++] = i.shr(24).and(0xff).toByte()\n        bytes[offset++] = i.shr(16).and(0xff).toByte()\n        bytes[offset++] = i.shr(8).and(0xff).toByte()\n        bytes[offset++] = i.and(0xff).toByte()\n    }\n\n    fun writeLong(l: Long) {\n        growIfNecessary(8)\n        writeInt(l.shr(32).and(0xffffffff).toInt())\n        writeInt(l.and(0xffffffff).toInt())\n    }\n\n    fun writeFloat(f: Float) {\n        writeInt(f.toBits())\n    }\n\n    @UseExperimental(ExperimentalStdlibApi::class)\n    fun writeString(s: String) {\n        writeBytes(s.encodeToByteArray())\n    }\n\n    fun writeNullableString(s: String?) {\n        writeBoolean(s != null)\n        if (s != null) {\n            writeString(s)\n        }\n    }\n\n    fun writeBytes(data: ByteArray, startIndex: Int = 0, endIndex: Int = data.size) {\n        val size = endIndex - startIndex\n\n        growIfNecessary(4 + size)\n        writeInt(size)\n\n        data.copyInto(bytes, offset, startIndex, endIndex)\n        offset += size\n    }\n\n    fun writeNBytes(data: ByteArray, startIndex: Int = 0, endIndex: Int = data.size) {\n        val size = endIndex - startIndex\n\n        growIfNecessary(size)\n\n        data.copyInto(bytes, offset, startIndex, endIndex)\n        offset += size\n    }\n\n    fun toBytes(): ByteArray {\n        return bytes.copyOf(offset)\n    }\n\n    private fun growIfNecessary(by: Int) {\n        if (offset + by > bytes.size) {\n            var newSize = bytes.size * 2\n            while (offset + by > newSize) newSize *= 2\n            bytes = bytes.copyOf(newSize)\n        }\n    }\n}","package baaahs.io\n\ninterface Fs {\n    fun listFiles(path: String): List<String>\n    fun loadFile(path: String): String?\n    fun createFile(path: String, content: ByteArray, allowOverwrite: Boolean = false)\n    fun createFile(path: String, content: String, allowOverwrite: Boolean = false)\n}\n","package baaahs.mapper\n\nimport com.soywiz.klock.DateTime\nimport kotlinx.serialization.Decoder\nimport kotlinx.serialization.Encoder\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.internal.StringDescriptor\nimport kotlinx.serialization.withName\n\nobject DateTimeSerializer : KSerializer<DateTime> {\n    override val descriptor = StringDescriptor.withName(\"DateTime\")\n\n    override fun deserialize(decoder: Decoder): DateTime {\n        return DateTime(decoder.decodeDouble())\n    }\n\n    override fun serialize(encoder: Encoder, obj: DateTime) {\n        encoder.encodeDouble(obj.unixMillis)\n    }\n}","package baaahs.mapper\n\nimport baaahs.Mapper\nimport baaahs.MediaDevices\nimport baaahs.imaging.Bitmap\nimport kotlin.math.max\n\nclass ImageProcessing {\n\n    class Histogram(val data: IntArray, val total: Int) {\n        fun sumValues(range: IntRange): Int {\n            var total = 0\n            for (i in range) {\n                total += data[i]\n            }\n            return total\n        }\n    }\n\n    companion object {\n        val rgbaPixelDetectionIndex = 1 // green\n\n        fun channelHistogram(\n            channel: Int,\n            bitmap: Bitmap\n        ): Histogram {\n            val hist = IntArray(256) { 0 }\n            bitmap.withData {\n                val totalBytes = it.size\n                for (i in channel until totalBytes step 4) {\n                    hist[it[i].toInt() and 0xFF]++\n                }\n                false\n            }\n            return Histogram(hist, bitmap.width * bitmap.height)\n        }\n\n        /**\n         * @param newBitmap Newly-captured bitmap from camera with some element lit.\n         * @param baseBitmap Base bitmap from camera with all elements off.\n         * @param deltaBitmap Bitmap to receive diff.\n         * @param withinRegion Region within which to find changes.\n         */\n        fun diff(\n            newBitmap: Bitmap,\n            baseBitmap: Bitmap,\n            deltaBitmap: Bitmap,\n            maskBitmap: Bitmap? = null,\n            withinRegion: MediaDevices.Region = MediaDevices.Region.containing(baseBitmap)\n        ): Analysis {\n            deltaBitmap.copyFrom(baseBitmap)\n            deltaBitmap.subtract(newBitmap)\n            if (maskBitmap != null) {\n                deltaBitmap.darken(maskBitmap)\n            }\n\n            return analyze(deltaBitmap, withinRegion)\n        }\n\n        @UseExperimental(ExperimentalUnsignedTypes::class)\n        fun pixels(\n            bitmap: Bitmap,\n            regionOfInterest: MediaDevices.Region = MediaDevices.Region.containing(bitmap),\n            fn: (x: Int, y: Int, value: Int) -> Unit\n        ) {\n            bitmap.withData { data ->\n                for (y in regionOfInterest.yRange) {\n                    for (x in regionOfInterest.xRange) {\n                        val pixelByteIndex = (x + y * bitmap.width) * 4\n                        val pixValue = data[pixelByteIndex + rgbaPixelDetectionIndex].toInt()\n                        fn(x, y, pixValue)\n                    }\n                }\n\n                false\n            }\n        }\n\n        @UseExperimental(ExperimentalUnsignedTypes::class)\n        fun analyze(\n            bitmap: Bitmap,\n            regionOfInterest: MediaDevices.Region = MediaDevices.Region.containing(bitmap)\n        ): Analysis {\n            val hist = IntArray(256) { 0 }\n            val xMin = ShortArray(bitmap.width) { if (regionOfInterest.xRange.contains(it)) 0xFF else 0 }\n            val xMax = ShortArray(bitmap.width) { 0x00 }\n            val yMin = ShortArray(bitmap.height) { if (regionOfInterest.yRange.contains(it)) 0xFF else 0 }\n            val yMax = ShortArray(bitmap.height) { 0x00 }\n\n            bitmap.withData { data ->\n                // Get histogram and per-row and -column min and max diffs.\n\n                for (y in regionOfInterest.yRange) {\n                    for (x in regionOfInterest.xRange) {\n                        val pixelByteIndex = (x + y * bitmap.width) * 4\n                        val pixValue = data[pixelByteIndex + rgbaPixelDetectionIndex].toShort()\n\n                        if (pixValue < xMin[x]) xMin[x] = pixValue\n                        if (pixValue > xMax[x]) xMax[x] = pixValue\n                        if (pixValue < yMin[y]) yMin[y] = pixValue\n                        if (pixValue > yMax[y]) yMax[y] = pixValue\n                        hist[pixValue.toInt()]++\n                    }\n                }\n\n                false\n            }\n\n            return Analysis(\n                bitmap.width,\n                bitmap.height,\n                regionOfInterest,\n                Histogram(hist, bitmap.width * bitmap.height),\n                xMin,\n                xMax,\n                yMin,\n                yMax\n            )\n        }\n\n        fun Collection<Int>.histogram(range: IntRange): IntArray {\n            val hist = IntArray(range.last - range.first)\n            forEach { i -> hist[i - range.first]++ }\n            return hist\n        }\n    }\n\n    class Analysis(\n        val width: Int,\n        val height: Int,\n        val regionOfInterest: MediaDevices.Region,\n        val hist: Histogram,\n        val xMin: ShortArray,\n        val xMax: ShortArray,\n        val yMin: ShortArray,\n        val yMax: ShortArray\n    ) {\n        val minValue: Int by lazy { xMin.copyOfRange(regionOfInterest.xRange).min()!!.toInt() }\n        val maxValue: Int by lazy { xMax.copyOfRange(regionOfInterest.xRange).max()!!.toInt() }\n\n        val minChangeToDetect = 10f\n        val scale: Float by lazy { max(minChangeToDetect, (maxValue - minValue).toFloat()) }\n        fun thresholdValueFor(threshold: Float) = (threshold * scale).toShort() + minValue\n\n        fun detectChangeRegion(\n            threshold: Float\n        ): MediaDevices.Region {\n//            val b255 = 255.toUByte()\n\n            val thresholdValue = thresholdValueFor(threshold)\n            val minX = xMax.indexOfFirst { rowMaxValue -> rowMaxValue >= thresholdValue }\n            val minY = yMax.indexOfFirst { colMaxValue -> colMaxValue >= thresholdValue }\n            val maxX = xMax.indexOfLast { rowMaxValue -> rowMaxValue >= thresholdValue }\n            val maxY = yMax.indexOfLast { colMaxValue -> colMaxValue >= thresholdValue }\n            return MediaDevices.Region(minX, minY, maxX, maxY)\n        }\n\n        private fun ShortArray.copyOfRange(intRange: IntRange): ShortArray {\n            return copyOfRange(intRange.first, intRange.last)\n        }\n\n        fun hasBrightSpots(): Boolean {\n            this.hist.data.reduce { acc, i ->\n                if (i - acc > 3) { // one or two brigher pixels don't count\n                    return true\n                }\n                i\n            }\n            return false\n        }\n    }\n}\n\n","package baaahs.mapper\n\nimport baaahs.Logger\nimport baaahs.decodeBase64\nimport baaahs.net.Network\nimport kotlinx.serialization.json.*\nimport kotlinx.serialization.list\nimport kotlinx.serialization.serializer\n\nclass MapperEndpoint(val storage: Storage) : Network.WebSocketListener {\n    companion object {\n        val json = Json(JsonConfiguration.Stable)\n\n        val logger = Logger(\"MapperEndpoint\")\n    }\n\n    override fun connected(tcpConnection: Network.TcpConnection) {\n        println(\"Received connection from ${tcpConnection.fromAddress}\")\n    }\n\n    @UseExperimental(ExperimentalStdlibApi::class)\n    override fun receive(tcpConnection: Network.TcpConnection, bytes: ByteArray) {\n        val parts = json.parseJson(bytes.decodeToString()).jsonArray\n        val command = parts.first().contentOrNull\n        var status = \"success\"\n        var response: JsonElement\n\n        try {\n            when (command) {\n                \"listSessions\" -> {\n                    response = json.toJson(String.serializer().list, storage.listSessions())\n                }\n                \"saveImage\" -> {\n                    val name = parts[1].primitive.contentOrNull\n                    val imageDataBase64 = parts[2].primitive.contentOrNull\n                    val imageData = decodeBase64(imageDataBase64!!)\n                    storage.saveImage(name!!, imageData)\n                    response = JsonNull\n                }\n                \"saveSession\" -> {\n                    val mappingSession = json.fromJson(MappingSession.serializer(), parts[1])\n                    storage.saveSession(mappingSession)\n                    response = JsonNull\n                }\n                else -> throw UnsupportedOperationException(\"unknown command \\\"$command\\\"\")\n            }\n        } catch (e: Exception) {\n            status = \"error\"\n            response = JsonPrimitive(e.toString())\n            logger.error { \"Command failed: $parts\" }\n            logger.error { e.toString() }\n        }\n\n        println(\"Command: $parts -> $status $response\")\n        tcpConnection.send(json.stringify(JsonElementSerializer, json {\n            \"status\" to status\n            \"response\" to response\n        }).encodeToByteArray())\n    }\n\n    override fun reset(tcpConnection: Network.TcpConnection) {\n        println(\"MapperEndpoint client disconnected from Pinky!\")\n    }\n}\n","package baaahs.mapper\n\nimport baaahs.BrainId\nimport baaahs.Model\nimport baaahs.geom.Vector3F\n\ninterface MappingResults {\n    fun dataFor(brainId: BrainId): Info?\n\n    class Info(\n        val surface: Model.Surface,\n\n        /** Pixel's estimated position within the model. */\n        val pixelLocations: List<Vector3F?>?\n    )\n}\n\nclass SessionMappingResults(model: Model<*>, mappingSession: MappingSession?) : MappingResults {\n    val brainData = mutableMapOf<BrainId, MappingResults.Info>()\n\n    init {\n        if (mappingSession != null) {\n            mappingSession.surfaces.forEach { surfaceData ->\n                val brainId = BrainId(surfaceData.brainId)\n                val surfaceName = surfaceData.surfaceName\n                val modelSurface = model.findModelSurface(surfaceName)\n                val pixelLocations = surfaceData.pixels.map { it?.modelPosition }\n\n                brainData[brainId] = MappingResults.Info(modelSurface, pixelLocations)\n            }\n        }\n    }\n\n    override fun dataFor(brainId: BrainId): MappingResults.Info? = brainData[brainId]\n}","package baaahs.mapper\n\nimport baaahs.geom.Matrix4\nimport baaahs.geom.Vector2F\nimport baaahs.geom.Vector3F\nimport com.soywiz.klock.DateTime\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class MappingSession(\n    val startedAt: Double,\n    val surfaces: List<SurfaceData>,\n    val cameraMatrix: Matrix4,\n    val baseImage: String?,\n    val version: Int = 0,\n    val savedAt: Double = DateTime.nowUnix(),\n    val notes: String? = null\n) {\n    val startedAtDateTime: DateTime get() = DateTime(startedAt)\n\n    @Serializable\n    data class SurfaceData(\n        val brainId: String,\n        val panelName: String, // TODO: rename to surfaceName\n        val pixels: List<PixelData?>,\n        val deltaImage: String?,\n        val screenAreaInSqPixels: Float?,\n        val screenAngle: Float?\n    ) {\n        val surfaceName: String get() = panelName\n\n        @Serializable\n        data class PixelData(\n            val modelPosition: Vector3F?,\n            val screenPosition: Vector2F?,\n            val deltaImage: String?\n        )\n    }\n}","package baaahs.mapper;\n\nimport baaahs.Model\nimport baaahs.io.Fs\nimport com.soywiz.klock.DateFormat\nimport com.soywiz.klock.DateTime\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonConfiguration\n\nclass Storage(val fs: Fs) {\n\n    companion object {\n        val json = Json(JsonConfiguration.Stable.copy(strictMode = false))\n\n        private val format = DateFormat(\"yyyy''MM''dd'-'HH''mm''ss\")\n\n        fun formatDateTime(dateTime: DateTime): String {\n            return dateTime.format(format)\n        }\n    }\n\n    fun listSessions(): List<String> {\n        return fs.listFiles(\"mapping-sessions\").filter { it.endsWith(\".json\") }\n    }\n\n    fun saveSession(mappingSession: MappingSession) {\n        fs.createFile(\n            \"mapping-sessions/${formatDateTime(mappingSession.startedAtDateTime)}-v${mappingSession.version}.json\",\n            json.stringify(MappingSession.serializer(), mappingSession)\n        )\n    }\n\n    fun saveImage(name: String, imageData: ByteArray) {\n        fs.createFile(\"mapping-sessions/images/$name\", imageData)\n    }\n\n    fun loadMappingData(model: Model<*>): MappingResults {\n        val mappingJson = fs.loadFile(\"mapping-presets.json\")\n        if (mappingJson != null) {\n            return SessionMappingResults(model, json.parse(MappingSession.serializer(), mappingJson))\n        } else {\n            return SessionMappingResults(model, null)\n        }\n    }\n}\n","package baaahs.net\n\nimport baaahs.Logger\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.math.min\n\nclass FragmentingUdpLink(private val wrappedLink: Network.Link) : Network.Link {\n    override val myAddress: Network.Address get() = wrappedLink.myAddress\n    override val udpMtu: Int get() = wrappedLink.udpMtu\n\n    /**\n     * Header is 12 bytes long; format is:\n     * * message ID (short)\n     * * this frame size (short)\n     * * total payload size (long)\n     * * this frame offset (long)\n     */\n    companion object {\n        const val headerSize = 12\n\n        val logger = Logger(\"FragmentingUdpLink\")\n    }\n\n    private val mtu = wrappedLink.udpMtu\n    private var nextMessageId: Short = 0\n\n    private var fragments = arrayListOf<Fragment>()\n\n    class Fragment(val messageId: Short, val offset: Int, val bytes: ByteArray) {\n        override fun toString(): String {\n            return \"Fragment(messageId=$messageId, offset=$offset, bytes=${bytes.size})\"\n        }\n    }\n\n    override fun listenUdp(port: Int, udpListener: Network.UdpListener): Network.UdpSocket {\n        return FragmentingUdpSocket(wrappedLink.listenUdp(port, object : Network.UdpListener {\n            override fun receive(fromAddress: Network.Address, fromPort: Int, bytes: ByteArray) {\n                // reassemble fragmented payloads...\n                val reader = ByteArrayReader(bytes)\n                val messageId = reader.readShort()\n                val size = reader.readShort().toInt()\n                val totalSize = reader.readInt()\n                val offset = reader.readInt()\n//                println(\"Received UDP: messageId=$messageId thisFrameSize=${size} totalSize=${totalSize} offset=${offset} packetSize=${bytes.size}\")\n\n                if (size + headerSize > bytes.size) {\n                    logger.debug { \"Discarding short UDP message: ${size + headerSize} > ${bytes.size} available\" }\n                    return\n                }\n\n                val frameBytes = reader.readNBytes(size)\n                if (offset == 0 && size == totalSize) {\n                    udpListener.receive(fromAddress, fromPort, frameBytes)\n                } else {\n                    val thisFragment = Fragment(messageId, offset, frameBytes)\n                    synchronized(fragments) {\n                        fragments.add(thisFragment)\n                    }\n\n//                        println(\"received fragment: ${thisFragment}\")\n                    if (offset + size == totalSize) {\n                        // final fragment, try to reassemble\u2026\n\n                        val myFragments = removeMessageId(messageId)\n\n                        val actualTotalSize = myFragments.map { it.bytes.size }.reduce { acc, i -> acc + i }\n                        if (actualTotalSize == totalSize) {\n                            val reassembleBytes = ByteArray(totalSize)\n                            myFragments.forEach {\n                                it.bytes.copyInto(reassembleBytes, it.offset)\n                            }\n\n                            udpListener.receive(fromAddress, fromPort, reassembleBytes)\n                        } else {\n                            // todo: this should probably be a warn, not an error...\n                            logger.warn {\n                                \"incomplete fragmented UDP packet from $fromAddress:$fromPort:\" +\n                                        \" actualTotalSize=$actualTotalSize != totalSize=$totalSize\" +\n                                        \" for messageId=$messageId\" +\n                                        \" (have ${myFragments.map { it.bytes.size }.joinToString(\",\")})\"\n                            }\n\n                            synchronized(fragments) {\n                                fragments.addAll(myFragments)\n                            }\n                        }\n\n                    }\n                }\n            }\n        }))\n    }\n\n    private fun removeMessageId(messageId: Short): List<Fragment> {\n        val myFragments = arrayListOf<Fragment>()\n\n        synchronized(fragments) {\n            fragments.removeAll { fragment ->\n                val remove = fragment.messageId == messageId\n                if (remove) myFragments.add(fragment)\n                remove\n            }\n\n            val offsets = hashSetOf<Int>()\n            myFragments.removeAll { fragment ->\n                val alreadyThere = !offsets.add(fragment.offset)\n                if (alreadyThere) {\n                    println(\"already there: ${fragment}\")\n                    println(\"from: $myFragments\")\n                }\n                alreadyThere // duplicate, ignore\n            }\n\n            if (myFragments.isEmpty()) {\n                println(\"remaining fragments = ${fragments}\")\n            }\n        }\n\n        return myFragments.sortedBy { it.offset }\n    }\n\n    inner class FragmentingUdpSocket(private val delegate: Network.UdpSocket) : Network.UdpSocket {\n        override val serverPort: Int get() = delegate.serverPort\n\n        /** Sends payloads which might be larger than the network's MTU. */\n        override fun sendUdp(toAddress: Network.Address, port: Int, bytes: ByteArray) {\n            transmitMultipartUdp(bytes) { fragment -> delegate.sendUdp(toAddress, port, fragment) }\n        }\n\n        /** Broadcasts payloads which might be larger than the network's MTU. */\n        override fun broadcastUdp(port: Int, bytes: ByteArray) {\n            transmitMultipartUdp(bytes) { fragment -> delegate.broadcastUdp(port, fragment) }\n        }\n\n        /** Sends payloads which might be larger than the network's MTU. */\n        private fun transmitMultipartUdp(bytes: ByteArray, fn: (bytes: ByteArray) -> Unit) {\n            val maxSize = 65535 * 2 // arbitrary but probably sensible\n            if (bytes.size > maxSize) {\n                throw IllegalArgumentException(\"buffer too big! ${bytes.size} must be < $maxSize\")\n            }\n\n            val messageId = nextMessageId++\n            val messageCount = (bytes.size - 1) / (mtu - headerSize) + 1\n            val buf = ByteArray(mtu)\n            var offset = 0\n            for (i in 0 until messageCount) {\n                val writer = ByteArrayWriter(buf)\n                val thisFrameSize = min((mtu - headerSize), bytes.size - offset)\n                writer.writeShort(messageId)\n                writer.writeShort(thisFrameSize.toShort())\n                writer.writeInt(bytes.size)\n                writer.writeInt(offset)\n                writer.writeNBytes(bytes, offset, offset + thisFrameSize)\n                fn(writer.toBytes())\n\n//                println(\"Sending UDP: messageId=$messageId thisFrameSize=${thisFrameSize.toShort()} totalSize=${bytes.size} offset=${offset}\")\n\n                offset += thisFrameSize\n            }\n        }\n    }\n\n    override fun startHttpServer(port: Int): Network.HttpServer =\n        wrappedLink.startHttpServer(port)\n\n    override fun connectWebSocket(\n        toAddress: Network.Address,\n        port: Int,\n        path: String,\n        webSocketListener: Network.WebSocketListener\n    ): Network.TcpConnection =\n        wrappedLink.connectWebSocket(toAddress, port, path, webSocketListener)\n\n}\n","package baaahs.net\n\nimport baaahs.proto.Message\n\ninterface Network {\n    fun link(): Link\n\n    interface Link {\n        val myAddress: Address\n\n        val udpMtu: Int\n        fun listenUdp(port: Int, udpListener: UdpListener): UdpSocket\n\n        fun startHttpServer(port: Int): HttpServer\n        fun connectWebSocket(\n            toAddress: Address,\n            port: Int,\n            path: String,\n            webSocketListener: WebSocketListener\n        ): TcpConnection\n    }\n\n    interface Address\n\n    interface UdpListener {\n        fun receive(fromAddress: Address, fromPort: Int, bytes: ByteArray)\n    }\n\n    interface UdpSocket {\n        val serverPort: Int\n\n        fun sendUdp(toAddress: Address, port: Int, bytes: ByteArray)\n        fun sendUdp(toAddress: Address, port: Int, message: Message) = sendUdp(toAddress, port, message.toBytes())\n        fun broadcastUdp(port: Int, bytes: ByteArray)\n        fun broadcastUdp(port: Int, message: Message) = broadcastUdp(port, message.toBytes())\n    }\n\n    interface TcpConnection {\n        val fromAddress: Address\n        val toAddress: Address\n        val port: Int\n\n        fun send(bytes: ByteArray)\n\n        fun send(message: Message) {\n            send(message.toBytes())\n        }\n    }\n\n    interface HttpServer {\n        fun listenWebSocket(path: String, webSocketListener: WebSocketListener) {\n            listenWebSocket(path) { webSocketListener }\n        }\n\n        fun listenWebSocket(path: String, onConnect: (incomingConnection: TcpConnection) -> WebSocketListener)\n    }\n\n    interface WebSocketListener {\n        fun connected(tcpConnection: TcpConnection)\n        fun receive(tcpConnection: TcpConnection, bytes: ByteArray)\n        fun reset(tcpConnection: TcpConnection)\n    }\n\n    object UdpProxy {\n        val BROADCAST_OP = 'B'\n        val LISTEN_OP = 'L'\n        val SEND_OP = 'S'\n        val RECEIVE_OP = 'R'\n    }\n}","package baaahs.proto\n\nimport baaahs.BrainId\nimport baaahs.Shader\nimport baaahs.geom.Vector2F\nimport baaahs.geom.Vector3F\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\n\nobject Ports {\n    const val PINKY = 8002\n    const val BRAIN = 8003\n\n    const val PINKY_UI_TCP = 8004\n    const val PINKY_MAPPER_TCP = 8005\n    const val SIMULATOR_BRIDGE_TCP = 8006\n}\n\nenum class Type {\n    // UDP:\n    BRAIN_HELLO,\n    BRAIN_PANEL_SHADE,\n    MAPPER_HELLO,\n    BRAIN_ID_REQUEST,\n    BRAIN_MAPPING,\n    PING,\n    USE_FIRMWARE;\n\n    companion object {\n        val values = values()\n        fun get(i: Byte) = values[i.toInt()]\n    }\n}\n\nfun parse(bytes: ByteArray): Message {\n    val reader = ByteArrayReader(bytes)\n    return when (Type.get(reader.readByte())) {\n        Type.BRAIN_HELLO -> BrainHelloMessage.parse(reader)\n        Type.BRAIN_PANEL_SHADE -> BrainShaderMessage.parse(reader)\n        Type.MAPPER_HELLO -> MapperHelloMessage.parse(reader)\n        Type.BRAIN_ID_REQUEST -> BrainIdRequest.parse(reader)\n        Type.BRAIN_MAPPING -> BrainMappingMessage.parse(reader)\n        Type.PING -> PingMessage.parse(reader)\n        Type.USE_FIRMWARE -> UseFirmwareMessage.parse(reader)\n    }\n}\n\nclass BrainHelloMessage(val brainId: String, val surfaceName: String?, val firmwareVersion: String? = null,\n                        val idfVersion: String? = null) : Message(Type.BRAIN_HELLO) {\n    companion object {\n        fun parse(reader: ByteArrayReader): BrainHelloMessage {\n            val brainId = reader.readString()\n            val surfaceName = reader.readNullableString()\n            val firmwareVersion = if (reader.hasMoreBytes()) reader.readNullableString() else null\n            val idfVersion = if (reader.hasMoreBytes()) reader.readNullableString() else null\n            return BrainHelloMessage(brainId, surfaceName, firmwareVersion, idfVersion)\n        }\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n        writer.writeString(brainId)\n        writer.writeNullableString(surfaceName)\n        writer.writeNullableString(firmwareVersion)\n        writer.writeNullableString(idfVersion)\n    }\n\n    override fun toString(): String {\n        return \"BrainHello $brainId, $surfaceName, $firmwareVersion, $idfVersion\"\n    }\n}\n\nclass BrainShaderMessage(val shader: Shader<*>, val buffer: Shader.Buffer, val pongData: ByteArray? = null) :\n    Message(Type.BRAIN_PANEL_SHADE) {\n    companion object {\n        /**\n         * Suboptimal parser; on the Brain we'll do better than this.\n         */\n        fun parse(reader: ByteArrayReader): BrainShaderMessage {\n            val pongData = if (reader.readBoolean()) reader.readBytes() else null\n            val shaderDesc = reader.readBytes()\n            val shader = Shader.parse(ByteArrayReader(shaderDesc))\n            val buffer = shader.readBuffer(reader)\n            return BrainShaderMessage(shader, buffer, pongData)\n        }\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n        writer.writeBoolean(pongData != null)\n        if (pongData != null) writer.writeBytes(pongData)\n        writer.writeBytes(shader.descriptorBytes)\n        buffer.serialize(writer)\n    }\n}\n\n/**\n * The message that Pinky will send to a brain when Pinky has decided that\n * the Brain should use a particular firmware. The url can point anywhere,\n * either self hosted by Pinky or out into the nether reaches of the Interwebs.\n * What could possibly go wrong? Pinky would __never__ tell a brain to go\n * download a wikipedia article and use that as a firmware. It just won't\n * be nice.\n */\nclass UseFirmwareMessage(val url: String) :\n    Message(Type.USE_FIRMWARE) {\n    companion object {\n        fun parse(reader: ByteArrayReader): UseFirmwareMessage {\n            return UseFirmwareMessage(reader.readString())\n        }\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n        writer.writeString(url)\n    }\n}\n\nclass MapperHelloMessage(val isRunning: Boolean) : Message(Type.MAPPER_HELLO) {\n    companion object {\n        fun parse(reader: ByteArrayReader): MapperHelloMessage {\n            return MapperHelloMessage(reader.readBoolean())\n        }\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n        writer.writeBoolean(isRunning)\n    }\n}\n\nclass BrainIdRequest : Message(Type.BRAIN_ID_REQUEST) {\n    companion object {\n        fun parse(reader: ByteArrayReader) = BrainIdRequest()\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n    }\n}\n\nclass BrainMappingMessage(\n    val brainId: BrainId,\n    val surfaceName: String?,\n    val uvMapName: String?,\n    val panelUvTopLeft: Vector2F,\n    val panelUvBottomRight: Vector2F,\n    val pixelCount: Int,\n    val pixelLocations: List<Vector3F>\n) : Message(Type.BRAIN_MAPPING) {\n\n    companion object {\n        fun parse(reader: ByteArrayReader) = BrainMappingMessage(\n            BrainId(reader.readString()), // brainId\n            reader.readNullableString(), // surfaceName\n            reader.readNullableString(), // uvMapName\n            reader.readVector2F(), // panelUvTopLeft\n            reader.readVector2F(), // panelUvBottomRight\n            reader.readInt(), // pixelCount\n            reader.readRelativeVerticesList()\n        )\n\n        private fun ByteArrayReader.readVector2F() = Vector2F(readFloat(), readFloat())\n\n        private fun ByteArrayWriter.writeVector2F(v: Vector2F) {\n            writeFloat(v.x)\n            writeFloat(v.y)\n        }\n\n        private fun ByteArrayReader.readRelativeVerticesList(): List<Vector3F> {\n            val vertexCount = readInt()\n            return (0 until vertexCount).map {\n                Vector3F(readFloat(), readFloat(), readFloat())\n            }\n        }\n\n        private fun ByteArrayWriter.writeRelativeVerticesList(pixelLocations: List<Vector3F>) {\n            writeInt(pixelLocations.size)\n            pixelLocations.forEach { vertex ->\n                writeFloat(vertex.x)\n                writeFloat(vertex.y)\n                writeFloat(vertex.z)\n            }\n        }\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n        writer.writeString(brainId.uuid)\n        writer.writeNullableString(surfaceName)\n        writer.writeNullableString(uvMapName)\n        writer.writeVector2F(panelUvTopLeft)\n        writer.writeVector2F(panelUvBottomRight)\n        writer.writeInt(pixelCount)\n\n        val vertexCount = pixelLocations.size\n        writer.writeInt(vertexCount)\n        writer.writeRelativeVerticesList(pixelLocations)\n    }\n}\n\nclass PingMessage(val data: ByteArray, val isPong: Boolean = false) : Message(Type.PING) {\n    companion object {\n        fun parse(reader: ByteArrayReader): PingMessage {\n            val isPong = reader.readBoolean()\n            val data = reader.readBytes()\n            return PingMessage(data, isPong)\n        }\n    }\n\n    override fun serialize(writer: ByteArrayWriter) {\n        writer.writeBoolean(isPong)\n        writer.writeBytes(data)\n    }\n}\n\nopen class Message(val type: Type) {\n    // TODO: send message length as the first four bytes, plus maybe sequence/reassembly info for UDP\n    fun toBytes(): ByteArray {\n        val writer = ByteArrayWriter(1 + size())\n        writer.writeByte(type.ordinal.toByte())\n        serialize(writer)\n        return writer.toBytes()\n    }\n\n    open fun serialize(writer: ByteArrayWriter) {\n    }\n\n    open fun size(): Int = 127\n}\n","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\n\n/**\n * A shader which combines the results of two sub-shaders according to a specified compositing mode and cross-fade\n * value.\n */\nclass CompositorShader(val aShader: Shader<*>, val bShader: Shader<*>) :\n    Shader<CompositorShader.Buffer>(ShaderId.COMPOSITOR) {\n\n    override fun createBuffer(surface: Surface) = Buffer(aShader.createBuffer(surface), bShader.createBuffer(surface))\n\n    override fun serializeConfig(writer: ByteArrayWriter) {\n        aShader.serialize(writer)\n        bShader.serialize(writer)\n    }\n\n    override fun createRenderer(surface: Surface, renderContext: RenderContext): Shader.Renderer<Buffer> {\n        val rendererA: Shader.Renderer<*> = aShader.createRenderer(surface, renderContext)\n        val rendererB: Shader.Renderer<*> = bShader.createRenderer(surface, renderContext)\n        return Renderer(rendererA, rendererB)\n    }\n\n    override fun createRenderer(surface: Surface): Shader.Renderer<Buffer> {\n        val rendererA: Shader.Renderer<*> = aShader.createRenderer(surface)\n        val rendererB: Shader.Renderer<*> = bShader.createRenderer(surface)\n        return Renderer(rendererA, rendererB)\n    }\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer =\n        Buffer(\n            aShader.readBuffer(reader),\n            bShader.readBuffer(reader),\n            CompositingMode.get(reader.readByte()),\n            reader.readFloat()\n        )\n\n    fun createBuffer(bufferA: Shader.Buffer, bufferB: Shader.Buffer): Buffer =\n        Buffer(bufferA, bufferB)\n\n    companion object : ShaderReader<CompositorShader> {\n        override fun parse(reader: ByteArrayReader): CompositorShader {\n            val shaderA = Shader.parse(reader)\n            val shaderB = Shader.parse(reader)\n            return CompositorShader(shaderA, shaderB)\n        }\n    }\n\n    inner class Buffer(\n        val bufferA: Shader.Buffer, val bufferB: Shader.Buffer,\n        var mode: CompositingMode = CompositingMode.NORMAL,\n        var fade: Float = 0.5f\n    ) : Shader.Buffer {\n        override val shader: Shader<*> = this@CompositorShader\n\n        override fun serialize(writer: ByteArrayWriter) {\n            bufferA.serialize(writer)\n            bufferB.serialize(writer)\n            writer.writeByte(mode.ordinal.toByte())\n            writer.writeFloat(fade)\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            bufferA.read(reader)\n            bufferB.read(reader)\n            mode = CompositingMode.get(reader.readByte())\n            fade = reader.readFloat()\n        }\n    }\n\n    class Renderer<A : Shader.Buffer, B : Shader.Buffer>(\n        private val rendererA: Shader.Renderer<A>,\n        private val rendererB: Shader.Renderer<B>\n    ) : Shader.Renderer<Buffer> {\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun beginFrame(buffer: Buffer, pixelCount: Int) {\n            rendererA.beginFrame(buffer.bufferA as A, pixelCount)\n            rendererB.beginFrame(buffer.bufferB as B, pixelCount)\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color {\n            val dest = rendererA.draw(buffer.bufferA as A, pixelIndex)\n            val src = rendererB.draw(buffer.bufferB as B, pixelIndex)\n            return dest.fade(buffer.mode.composite(src, dest), buffer.fade)\n        }\n\n        override fun endFrame() {\n            rendererA.endFrame()\n            rendererB.endFrame()\n        }\n    }\n}\n\nenum class CompositingMode {\n    NORMAL {\n        override fun composite(src: Color, dest: Color) = src\n    },\n    ADD {\n        override fun composite(src: Color, dest: Color) = dest.plus(src)\n    };\n\n    abstract fun composite(src: Color, dest: Color): Color\n\n    companion object {\n        val values = values()\n        fun get(i: Byte): CompositingMode {\n            return values[i.toInt()]\n        }\n    }\n}","package baaahs.shaders\n\nimport baaahs.Color\nimport baaahs.Model\nimport baaahs.RenderContext\nimport baaahs.Shader\nimport baaahs.ShaderId\nimport baaahs.ShaderReader\nimport baaahs.Surface\nimport baaahs.glsl.GlslBase\nimport baaahs.glsl.GlslSurface\nimport baaahs.glsl.ModelSpaceUvTranslator\nimport baaahs.glsl.PanelSpaceUvTranslator\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.json.JsonConfiguration\nimport kotlinx.serialization.json.JsonObject\nimport kotlinx.serialization.json.json\n\nclass GlslShader(\n    val glslProgram: String,\n    val adjustableValues: List<AdjustableValue> = findAdjustableValues(glslProgram)\n) : Shader<GlslShader.Buffer>(ShaderId.GLSL_SHADER) {\n\n    companion object : ShaderReader<GlslShader> {\n        var model_CHEAT: Model<*>? = null\n\n        override fun parse(reader: ByteArrayReader): GlslShader {\n            val glslProgram = reader.readString()\n            val adjustableValueCount = reader.readShort()\n            val adjustableValues = (0 until adjustableValueCount).map { i -> AdjustableValue.parse(reader, i) }\n            return GlslShader(glslProgram, adjustableValues)\n        }\n\n        private val json = Json(JsonConfiguration.Stable.copy(strictMode = false))\n        private val gadgetPattern = Regex(\n            \"\\\\s*//\\\\s*SPARKLEMOTION GADGET:\\\\s*([^\\\\s]+)\\\\s+(\\\\{.*})\\\\s*\\n\" +\n                \"\\\\s*uniform\\\\s+([^\\\\s]+)\\\\s+([^\\\\s]+);\"\n        )\n\n        val extraAdjustables = listOf(\n            AdjustableValue(\"sm_uScale\", \"Slider\", AdjustableValue.Type.FLOAT,\n                json { \"name\" to \"u scale\"; \"minValue\" to 0f; \"maxValue\" to 3f }, 0),\n            AdjustableValue(\"sm_vScale\", \"Slider\", AdjustableValue.Type.FLOAT,\n                json { \"name\" to \"v scale\"; \"minValue\" to 0f; \"maxValue\" to 3f }, 1),\n            AdjustableValue(\"sm_beat\", \"Beat\", AdjustableValue.Type.FLOAT,\n                json { \"name\" to \"beat\" }, 2),\n            AdjustableValue(\"sm_startOfMeasure\", \"StartOfMeasure\", AdjustableValue.Type.FLOAT,\n                json { \"name\" to \"startOfMeasure\"; }, 3)\n        )\n\n        fun findAdjustableValues(glslFragmentShader: String): List<AdjustableValue> {\n            var i = (extraAdjustables.map { it.ordinal }.max() ?: -1) + 1\n\n            return gadgetPattern.findAll(glslFragmentShader).map { matchResult ->\n                println(\"matches: ${matchResult.groupValues}\")\n                val (gadgetType, configJson, valueTypeName, varName) = matchResult.destructured\n                val configData = json.parseJson(configJson)\n                val valueType = when (valueTypeName) {\n                    \"int\" -> AdjustableValue.Type.INT\n                    \"float\" -> AdjustableValue.Type.FLOAT\n                    \"vec3\" -> AdjustableValue.Type.VEC3\n                    else -> throw IllegalArgumentException(\"unsupported type $valueTypeName\")\n                }\n                AdjustableValue(varName, gadgetType, valueType, configData.jsonObject, i++)\n            }.toList() + extraAdjustables\n        }\n    }\n\n    override fun serializeConfig(writer: ByteArrayWriter) {\n        writer.writeString(glslProgram)\n        writer.writeShort(adjustableValues.size)\n        adjustableValues.forEach { it.serializeConfig(writer) }\n    }\n\n    override fun createRenderer(surface: Surface, renderContext: RenderContext): Renderer {\n        val poolKey = GlslShader::class to glslProgram\n        val pooledRenderer = renderContext.registerPooled(poolKey) { PooledRenderer(glslProgram, adjustableValues) }\n        val uvTranslator = ModelSpaceUvTranslator(model_CHEAT!!)\n        val glslSurface = pooledRenderer.glslRenderer.addSurface(surface, uvTranslator)\n        return Renderer(glslSurface)\n    }\n\n    override fun createRenderer(surface: Surface): Renderer {\n        val glslRenderer = GlslBase.manager.createRenderer(glslProgram, adjustableValues)\n        val glslSurface = glslRenderer.addSurface(surface, PanelSpaceUvTranslator)\n        return Renderer(glslSurface)\n    }\n\n    class Renderer(private val glslSurface: GlslSurface?) : Shader.Renderer<Buffer> {\n        override fun beginFrame(buffer: Buffer, pixelCount: Int) {\n            // update uniforms from buffer...\n            if (glslSurface != null) {\n                glslSurface.uniforms.updateFrom(buffer.values)\n            }\n        }\n\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color {\n            return if (glslSurface != null) glslSurface.pixels[pixelIndex] else Color.BLACK\n        }\n    }\n\n    class PooledRenderer(glslProgram: String, adjustableValues: List<AdjustableValue>) : baaahs.PooledRenderer {\n        val glslRenderer = GlslBase.manager.createRenderer(glslProgram, adjustableValues)\n\n        override fun preDraw() {\n            glslRenderer.draw()\n        }\n    }\n\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*> get() = this@GlslShader\n\n        val values = Array<Any?>(adjustableValues.size) { }\n\n        fun update(adjustableValue: AdjustableValue, value: Any) {\n            values[adjustableValue.ordinal] = value\n        }\n\n        override fun serialize(writer: ByteArrayWriter) {\n            adjustableValues.forEach { it.serializeValue(values[it.ordinal], writer) }\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            adjustableValues.forEach { values[it.ordinal] = it.readValue(reader) }\n        }\n    }\n\n    class AdjustableValue(\n        val varName: String,\n        val gadgetType: String,\n        val valueType: Type,\n        val config: JsonObject,\n        val ordinal: Int\n    ) {\n        enum class Type { INT, FLOAT, VEC3 }\n\n        fun serializeConfig(writer: ByteArrayWriter) {\n            writer.writeString(varName)\n            writer.writeByte(valueType.ordinal.toByte())\n        }\n\n        fun serializeValue(value: Any?, writer: ByteArrayWriter) {\n            when (valueType) {\n                Type.INT -> writer.writeInt(value as Int? ?: 0)\n                Type.FLOAT -> writer.writeFloat(value as Float)\n                Type.VEC3 -> writer.writeInt((value as Color? ?: Color.WHITE).argb)\n            }\n        }\n\n        fun readValue(reader: ByteArrayReader): Any {\n            return when (valueType) {\n                Type.INT -> reader.readInt()\n                Type.FLOAT -> reader.readFloat()\n                Type.VEC3 -> Color(reader.readInt())\n            }\n        }\n\n        companion object {\n            private val types = Type.values()\n\n            fun parse(reader: ByteArrayReader, ordinal: Int): AdjustableValue {\n                val varName = reader.readString()\n                val valueType = types[reader.readByte().toInt()]\n                return AdjustableValue(varName, \"\", valueType, JsonObject(emptyMap()), ordinal)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2 \u2014 of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2] \u2014 of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.glsl.PanelSpaceUvTranslator\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.math.PI\nimport kotlin.math.abs\nimport kotlin.math.acos\nimport kotlin.math.pow\n\nclass HeartShader : Shader<HeartShader.Buffer>(ShaderId.HEART) {\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    override fun createRenderer(surface: Surface): Renderer = Renderer(surface)\n\n    companion object : ShaderReader<HeartShader> {\n        override fun parse(reader: ByteArrayReader) = HeartShader()\n    }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*> get() = this@HeartShader\n\n        var edgeColor = Color.RED\n        var centerColor = Color.RED.fade(Color.WHITE, .2f)\n        var heartSize = 1f\n        var strokeSize = 1f\n        var xOff = 0f\n        var yOff = 0f\n\n        override fun serialize(writer: ByteArrayWriter) {\n            writer.writeFloat(heartSize)\n            writer.writeFloat(strokeSize)\n            writer.writeFloat(xOff)\n            writer.writeFloat(yOff)\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            heartSize = reader.readFloat()\n            strokeSize = reader.readFloat()\n            xOff = reader.readFloat()\n            yOff = reader.readFloat()\n        }\n\n    }\n\n    class Renderer(surface: Surface) : Shader.Renderer<Buffer> {\n        private val uvTranslator =\n            if (surface is IdentifiedSurface) PanelSpaceUvTranslator.forSurface(surface) else null\n\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color {\n            if (uvTranslator == null) return Color.BLACK\n\n            var (x, y) = uvTranslator.getUV(pixelIndex)\n            x -= .5f + buffer.xOff - .5f\n            x *= 1.1f\n            y -= .5f + buffer.yOff - .5f\n\n            x /= buffer.heartSize\n            y /= buffer.heartSize\n\n            val upperCurveDist = y - (1 - (abs(x) - 1).pow(2))\n            val lowerCurveDist = y - (acos(1 - abs(x)) - PI).toFloat()\n            if (y >= 0) { // upper section\n                if (upperCurveDist < 0) {\n                    val fadeAmount = if (abs(upperCurveDist) < buffer.strokeSize) {\n                        0f\n                    } else {\n                        abs(upperCurveDist / buffer.heartSize)\n                    }\n                    return buffer.edgeColor.fade(buffer.centerColor, fadeAmount)\n                } else {\n                    return Color.TRANSPARENT\n                }\n            } else if (lowerCurveDist > 0) {\n                val fadeAmount = if (lowerCurveDist < buffer.strokeSize) {\n                    1f\n                } else {\n                    lowerCurveDist / buffer.heartSize\n                }\n                return buffer.edgeColor.fade(buffer.centerColor, fadeAmount)\n            } else {\n                return Color.TRANSPARENT\n            }\n        }\n    }\n}","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.math.min\n\n/**\n * A shader that allows control of individual pixels' colors directly from a show.\n *\n * This is a suboptimal shader for most purposes, consider writing a custom shader instead!\n */\nclass PixelShader(private val encoding: Encoding = Encoding.DIRECT_ARGB) : Shader<PixelShader.Buffer>(ShaderId.PIXEL) {\n\n    enum class Encoding {\n        DIRECT_ARGB {\n            override fun createBuffer(shader: PixelShader, pixelCount: Int) =\n                shader.DirectColorBuffer(pixelCount)\n        },\n        DIRECT_RGB {\n            override fun createBuffer(shader: PixelShader, pixelCount: Int) =\n                shader.DirectColorBuffer(pixelCount, true)\n        },\n        INDEXED_2 {\n            override fun createBuffer(shader: PixelShader, pixelCount: Int) =\n                shader.IndexedBuffer(1, pixelCount)\n        },\n        INDEXED_4 {\n            override fun createBuffer(shader: PixelShader, pixelCount: Int) =\n                shader.IndexedBuffer(2, pixelCount)\n        },\n        INDEXED_16 {\n            override fun createBuffer(shader: PixelShader, pixelCount: Int) =\n                shader.IndexedBuffer(4, pixelCount)\n        };\n\n        abstract fun createBuffer(shader: PixelShader, pixelCount: Int): Buffer\n\n        companion object {\n            val values = values()\n            fun get(i: Byte): Encoding {\n                return values[i.toInt()]\n            }\n        }\n    }\n\n    override fun serializeConfig(writer: ByteArrayWriter) {\n        writer.writeByte(encoding.ordinal.toByte())\n    }\n\n    override fun createBuffer(surface: Surface): Buffer {\n        val pixelCount = if (surface.pixelCount == SparkleMotion.PIXEL_COUNT_UNKNOWN) {\n            SparkleMotion.DEFAULT_PIXEL_COUNT\n        } else {\n            surface.pixelCount\n        }\n\n        return encoding.createBuffer(this, pixelCount)\n    }\n\n    override fun createRenderer(surface: Surface): Shader.Renderer<Buffer> = Renderer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer {\n        val incomingPixelCount = reader.readShort().toInt()\n        val buf = encoding.createBuffer(this, incomingPixelCount)\n        buf.read(reader, incomingPixelCount)\n        return buf\n    }\n\n    companion object : ShaderReader<PixelShader> {\n        override fun parse(reader: ByteArrayReader): PixelShader {\n            val encoding = Encoding.get(reader.readByte())\n            return PixelShader(encoding)\n        }\n    }\n\n    abstract inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*>\n            get() = this@PixelShader\n\n        override fun read(reader: ByteArrayReader) {\n            val incomingPixelCount = reader.readShort().toInt()\n            read(reader, incomingPixelCount)\n        }\n\n        abstract val colors: MutableList<Color>\n        abstract val palette: Array<Color>\n        protected abstract operator fun get(pixelIndex: Int): Color\n        protected abstract operator fun set(pixelIndex: Int, color: Color)\n        internal abstract operator fun set(pixelIndex: Int, paletteIndex: Int)\n        abstract fun setAll(color: Color)\n        abstract fun setAll(paletteIndex: Int)\n        abstract val indices: IntRange\n        abstract fun read(reader: ByteArrayReader, incomingPixelCount: Int)\n    }\n\n    inner class DirectColorBuffer(private val pixelCount: Int, private val rgb24BitMode: Boolean = false) : Buffer() {\n        override val palette: Array<Color> = emptyArray()\n        private var colorsBuf: Array<Color> = Array(pixelCount) { Color.WHITE }\n        override val colors: MutableList<Color>\n            get() = object : AbstractMutableList<Color>() {\n                override fun add(index: Int, element: Color): Unit = throw UnsupportedOperationException()\n\n                override fun removeAt(index: Int): Color = throw UnsupportedOperationException()\n\n                override fun set(index: Int, element: Color): Color {\n                    val oldValue = get(index)\n                    this@DirectColorBuffer.set(index, element)\n                    return oldValue\n                }\n\n                override val size = pixelCount\n\n                override fun get(index: Int): Color = this@DirectColorBuffer.get(index)\n            }\n\n        /** [serialize] and [read] are asymmetrical because pixel count is read in [Buffer.read]. */\n        override fun serialize(writer: ByteArrayWriter) {\n            writer.writeShort(pixelCount)\n            colorsBuf.forEach { color -> writeColor(color, writer) }\n        }\n\n        /** [serialize] and [read] are asymmetrical because pixel count is read in [Buffer.read]. */\n        override fun read(reader: ByteArrayReader, incomingPixelCount: Int) {\n            // if there are more colors in the buffer than pixels, drop from the end\n            val countFromBuffer = min(colorsBuf.size, incomingPixelCount)\n            for (i in 0 until countFromBuffer) {\n                colorsBuf[i] = readColor(reader)\n            }\n\n            // if there are more pixels than colors in the buffer, repeat\n            for (i in countFromBuffer until colorsBuf.size) {\n                colorsBuf[i] = colorsBuf[i % countFromBuffer]\n            }\n        }\n\n        private fun writeColor(color: Color, writer: ByteArrayWriter) {\n            if (rgb24BitMode) {\n                writer.writeByte(color.redB)\n                writer.writeByte(color.greenB)\n                writer.writeByte(color.blueB)\n            } else {\n                writer.writeInt(color.argb)\n            }\n        }\n\n        private fun readColor(reader: ByteArrayReader): Color {\n            return if (rgb24BitMode) {\n                Color(reader.readByte(), reader.readByte(), reader.readByte())\n            } else {\n                Color(reader.readInt())\n            }\n        }\n\n        override operator fun get(pixelIndex: Int): Color = colorsBuf[pixelIndex]\n        override fun set(pixelIndex: Int, color: Color) {\n            colorsBuf[pixelIndex] = color\n        }\n\n        override fun set(pixelIndex: Int, paletteIndex: Int): Unit =\n            throw UnsupportedOperationException(\"Indexed colors aren't available in this mode\")\n\n        override fun setAll(color: Color) {\n            for (i in colorsBuf.indices) set(i, color)\n        }\n\n        override fun setAll(paletteIndex: Int): Unit =\n            throw UnsupportedOperationException(\"Indexed colors aren't available in this mode\")\n\n        override val indices = colorsBuf.indices\n    }\n\n    inner class IndexedBuffer(private val bitsPerPixel: Int, private val pixelCount: Int) : Buffer() {\n        override val palette: Array<Color> = Array(1 shl bitsPerPixel) { Color.WHITE }\n        internal val dataBuf: ByteArray = ByteArray(bufferSizeFor(pixelCount)) { 0 }\n\n        override val colors: MutableList<Color>\n            get() = object : AbstractMutableList<Color>() {\n                override val size: Int = pixelCount\n\n                override fun add(index: Int, element: Color): Unit = throw UnsupportedOperationException()\n\n                override fun removeAt(index: Int): Color = throw UnsupportedOperationException()\n\n                override fun set(index: Int, element: Color): Color =\n                    throw IllegalArgumentException(\"Can't set color directly when using indexed color buffers\")\n\n                override fun get(index: Int): Color = this@IndexedBuffer.get(index)\n            }\n\n        override fun get(pixelIndex: Int): Color {\n            return palette[paletteIndex(pixelIndex)]\n        }\n\n        override fun set(pixelIndex: Int, color: Color): Unit =\n            throw IllegalArgumentException(\"Can't set color directly when using indexed color buffers\")\n\n        override fun set(pixelIndex: Int, paletteIndex: Int) {\n            val mask: Int\n            val pixelsPerByte: Int\n            val maxIndex: Int\n            when (bitsPerPixel) {\n                1 -> {\n                    mask = 0x01; pixelsPerByte = 8; maxIndex = 1\n                }\n                2 -> {\n                    mask = 0x03; pixelsPerByte = 4; maxIndex = 3\n                }\n                4 -> {\n                    mask = 0x0F; pixelsPerByte = 2; maxIndex = 15\n                }\n                else -> throw IllegalStateException()\n            }\n\n            if (paletteIndex < 0 || paletteIndex > maxIndex)\n                throw IllegalArgumentException(\"Invalid color index $paletteIndex\")\n\n\n            val bufOffset = pixelIndex / pixelsPerByte % dataBuf.size\n            val positionInByte = pixelsPerByte - pixelIndex % pixelsPerByte - 1\n            val bitShift = positionInByte * bitsPerPixel\n            val byte = (dataBuf[bufOffset].toInt() and (mask shl bitShift).inv()) or (paletteIndex shl bitShift)\n            dataBuf[bufOffset] = byte.toByte()\n        }\n\n        /** [serialize] and [read] are asymmetrical because pixel count is read in [Buffer.read]. */\n        override fun serialize(writer: ByteArrayWriter) {\n            writer.writeShort(pixelCount)\n            palette.forEach { paletteColor -> writer.writeInt(paletteColor.argb) }\n            writer.writeNBytes(dataBuf)\n        }\n\n        /** [serialize] and [read] are asymmetrical because pixel count is read in [Buffer.read]. */\n        override fun read(reader: ByteArrayReader, incomingPixelCount: Int) {\n            palette.indices.forEach { i -> palette[i] = Color.from(reader.readInt()) }\n            reader.readNBytes(dataBuf)\n        }\n\n        override fun setAll(color: Color): Unit =\n            throw IllegalArgumentException(\"Can't set color directly when using indexed color buffers\")\n\n        override fun setAll(paletteIndex: Int) {\n            for (i in indices) set(i, paletteIndex)\n        }\n\n        override val indices = 0 until pixelCount\n\n        private fun paletteIndex(pixelIndex: Int): Int {\n            val mask: Int\n            val pixelsPerByte: Int\n            when (bitsPerPixel) {\n                1 -> {\n                    mask = 0x01; pixelsPerByte = 8\n                }\n                2 -> {\n                    mask = 0x03; pixelsPerByte = 4\n                }\n                4 -> {\n                    mask = 0x0F; pixelsPerByte = 2\n                }\n                else -> throw IllegalStateException()\n            }\n\n            val bufOffset = pixelIndex / pixelsPerByte % dataBuf.size\n            val positionInByte = pixelsPerByte - pixelIndex % pixelsPerByte - 1\n            val bitShift = positionInByte * bitsPerPixel\n            return dataBuf[bufOffset].toInt() shr bitShift and mask\n        }\n\n        private fun bufferSizeFor(pixelCount: Int): Int {\n            return when (bitsPerPixel) {\n                1 -> (pixelCount + 7) / 8\n                2 -> (pixelCount + 3) / 4\n                4 -> (pixelCount + 1) / 2\n                else -> throw IllegalStateException()\n            }\n        }\n    }\n\n    class Renderer : Shader.Renderer<Buffer> {\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color = buffer.colors[pixelIndex]\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.random.Random\n\n/**\n * A shader that sets pixels to a random colors.\n */\nclass RandomShader : Shader<RandomShader.Buffer>(ShaderId.RANDOM) {\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    override fun createRenderer(surface: Surface): Renderer = Renderer()\n\n    companion object : ShaderReader<RandomShader> {\n        override fun parse(reader: ByteArrayReader) = RandomShader()\n    }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*>\n            get() = this@RandomShader\n\n        override fun serialize(writer: ByteArrayWriter) {\n        }\n\n        override fun read(reader: ByteArrayReader) {\n        }\n    }\n\n    class Renderer : Shader.Renderer<Buffer> {\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color =\n            Color.from(Random.nextInt(0xffffff) or (0xff ushr 24))\n    }\n}\n","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.glsl.PanelSpaceUvTranslator\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.math.sqrt\n\n/**\n * A shader that sets all pixels to a single color within x/y constraints.\n */\nclass SimpleSpatialShader() : Shader<SimpleSpatialShader.Buffer>(ShaderId.SIMPLE_SPATIAL) {\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    override fun createRenderer(surface: Surface): Renderer = Renderer(surface)\n\n    companion object : ShaderReader<SimpleSpatialShader> {\n        override fun parse(reader: ByteArrayReader) = SimpleSpatialShader()\n    }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*>\n            get() = this@SimpleSpatialShader\n\n        var color: Color = Color.WHITE\n        var centerX: Float = 0.5f\n        var centerY: Float = 0.5f\n        var radius: Float = 0.75f\n\n        override fun serialize(writer: ByteArrayWriter) {\n            color.serialize(writer)\n            writer.writeFloat(centerX)\n            writer.writeFloat(centerY)\n            writer.writeFloat(radius)\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            color = Color.parse(reader)\n            centerX = reader.readFloat()\n            centerY = reader.readFloat()\n            radius = reader.readFloat()\n        }\n    }\n\n    class Renderer(surface: Surface) : Shader.Renderer<Buffer> {\n        private val uvTranslator =\n            if (surface is IdentifiedSurface) PanelSpaceUvTranslator.forSurface(surface) else null\n\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color {\n            if (uvTranslator == null) return Color.BLACK\n\n            val (pixX, pixY) = uvTranslator.getUV(pixelIndex)\n\n            val distX = pixX - buffer.centerX\n            val distY = pixY - buffer.centerY\n            val dist = sqrt(distX * distX + distY * distY)\n            return when {\n                dist < buffer.radius - 0.025f -> buffer.color\n                dist < buffer.radius + 0.025f -> Color.BLACK\n                else -> buffer.color.fade(Color.BLACK, dist * 2)\n            }\n        }\n    }\n}\n","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.math.PI\nimport kotlin.math.sin\n\n/**\n * A shader that treats a surface's pixels as a linear strip and applies a configurable sine wave along the strip.\n */\nclass SineWaveShader() : Shader<SineWaveShader.Buffer>(ShaderId.SINE_WAVE) {\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    override fun createRenderer(surface: Surface): Shader.Renderer<Buffer> = Renderer()\n\n    companion object : ShaderReader<SineWaveShader> {\n        override fun parse(reader: ByteArrayReader) = SineWaveShader()\n    }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*>\n            get() = this@SineWaveShader\n\n        var color: Color = Color.WHITE\n        var theta: Float = 0f\n        var density: Float = 1f\n\n        override fun serialize(writer: ByteArrayWriter) {\n            color.serialize(writer)\n            writer.writeFloat(theta)\n            writer.writeFloat(density)\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            color = Color.parse(reader)\n            theta = reader.readFloat()\n            density = reader.readFloat()\n        }\n    }\n\n    class Renderer : Shader.Renderer<Buffer> {\n        private var pixelCount: Int = 1\n\n        override fun beginFrame(buffer: Buffer, pixelCount: Int) {\n            this.pixelCount = pixelCount\n        }\n\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color {\n            val theta = buffer.theta\n            val density = buffer.density\n\n            val v = sin(theta + 2 * PI * (pixelIndex.toFloat() / pixelCount * density)) / 2 + .5\n            return Color.BLACK.fade(buffer.color, v.toFloat())\n        }\n    }\n}\n","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\n\n/**\n * A shader that sets all pixels to a single color.\n */\nclass SolidShader : Shader<SolidShader.Buffer>(ShaderId.SOLID) {\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    override fun createRenderer(surface: Surface): Renderer = Renderer()\n\n    companion object : ShaderReader<SolidShader> {\n        override fun parse(reader: ByteArrayReader) = SolidShader()\n    }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*>\n            get() = this@SolidShader\n\n        var color: Color = Color.WHITE\n\n        override fun serialize(writer: ByteArrayWriter) {\n            color.serialize(writer)\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            color = Color.parse(reader)\n        }\n    }\n\n    class Renderer : Shader.Renderer<Buffer> {\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color = buffer.color\n    }\n}\n","package baaahs.shaders\n\nimport baaahs.*\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\nimport kotlin.random.Random\n\n/**\n * A shader that randomly sets some pixels to white, changing with each frame.\n */\nclass SparkleShader : Shader<SparkleShader.Buffer>(ShaderId.SPARKLE) {\n    override fun createBuffer(surface: Surface): Buffer = Buffer()\n\n    override fun readBuffer(reader: ByteArrayReader): Buffer = Buffer().apply { read(reader) }\n\n    override fun createRenderer(surface: Surface): Shader.Renderer<Buffer> = Renderer()\n\n    companion object : ShaderReader<SparkleShader> {\n        override fun parse(reader: ByteArrayReader) = SparkleShader()\n    }\n\n    inner class Buffer : Shader.Buffer {\n        override val shader: Shader<*> = this@SparkleShader\n\n        var color: Color = Color.WHITE\n        var sparkliness: Float = .1F\n\n        override fun serialize(writer: ByteArrayWriter) {\n            color.serialize(writer)\n            writer.writeFloat(sparkliness)\n        }\n\n        override fun read(reader: ByteArrayReader) {\n            color = Color.parse(reader)\n            sparkliness = reader.readFloat()\n        }\n    }\n\n    class Renderer : Shader.Renderer<Buffer> {\n        override fun draw(buffer: Buffer, pixelIndex: Int): Color {\n            return if (Random.nextFloat() < buffer.sparkliness ) { buffer.color } else { Color.BLACK }\n        }\n    }\n}\n","package baaahs.shows\n\nimport baaahs.getResource\n\nclass AllShows {\n    companion object {\n        val allGlslShows: List<GlslShow> by lazy {\n            getResource(\"_RESOURCE_FILES_\")\n                .split(\"\\n\")\n                .filter { it.startsWith(\"baaahs/shows/\") }\n                .map { fileName ->\n                    val shaderSource = getResource(fileName)\n                    val nameFromGlsl = Regex(\"^// (.*)\").find(shaderSource)?.groupValues?.get(1)\n                    val name = nameFromGlsl ?: fileName\n                        .split(\"/\").last()\n                        .replace(\".glsl\", \"\")\n                        .replace(\"_\", \" \")\n                    object : GlslShow(name) {\n                        override val program = shaderSource\n                    }\n                }\n        }\n\n        private val nonGlslShows = listOf(\n            SomeDumbShow,\n            RandomShow,\n            CompositeShow,\n            ThumpShow,\n            PanelTweenShow,\n            PixelTweenShow,\n            LifeyShow,\n            SimpleSpatialShow,\n            HeartbleatShow,\n            CreepingPixelsShow\n        )\n\n        val allShows = listOf(\n            SolidColorShow\n        ) + (nonGlslShows + allGlslShows).sortedBy { it.name.toLowerCase() }\n    }\n}\n","package baaahs.shows\n\nimport baaahs.*\nimport baaahs.gadgets.ColorPicker\nimport baaahs.shaders.CompositingMode\nimport baaahs.shaders.CompositorShader\nimport baaahs.shaders.SineWaveShader\nimport baaahs.shaders.SolidShader\nimport kotlin.math.PI\nimport kotlin.random.Random\n\nobject CompositeShow : Show(\"Composite\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner) = object : Renderer {\n        val colorPicker = showRunner.getGadget(\"color\", ColorPicker(\"Color\"))\n\n        val solidShader = SolidShader()\n        val sineWaveShader = SineWaveShader()\n\n        private val shaderBufs = showRunner.allSurfaces.associateWith { surface -> shaderBufsFor(surface) }\n            .toMutableMap()\n\n        private fun shaderBufsFor(surface: Surface): ShaderBufs {\n            val solidShaderBuffer = showRunner.getShaderBuffer(surface, solidShader)\n            val sineWaveShaderBuffer = showRunner.getShaderBuffer(surface, sineWaveShader).apply {\n                density = Random.nextFloat() * 20\n            }\n\n            val compositorShaderBuffer =\n                showRunner.getCompositorBuffer(surface, solidShaderBuffer, sineWaveShaderBuffer, CompositingMode.ADD)\n\n            return ShaderBufs(solidShaderBuffer, sineWaveShaderBuffer, compositorShaderBuffer)\n        }\n\n        private val movingHeadBuffers = showRunner.allMovingHeads.map { showRunner.getMovingHeadBuffer(it) }\n\n        override fun nextFrame() {\n            val theta = ((getTimeMillis() % 10000 / 1000f) % (2 * PI)).toFloat()\n\n            var i = 0\n            shaderBufs.values.forEach { shaderBuffer ->\n                shaderBuffer.solidShaderBuffer.color = colorPicker.color\n                shaderBuffer.sineWaveShaderBuffer.color = Color.WHITE\n                shaderBuffer.sineWaveShaderBuffer.theta = theta + i++\n                shaderBuffer.compositorShaderBuffer.mode = CompositingMode.ADD\n                shaderBuffer.compositorShaderBuffer.fade = 1f\n            }\n\n            movingHeadBuffers.forEach { buf ->\n                buf.color = colorPicker.color\n                buf.pan = PI.toFloat() / 2\n                buf.tilt = theta / 2\n            }\n        }\n\n        override fun surfacesChanged(newSurfaces: List<Surface>, removedSurfaces: List<Surface>) {\n            removedSurfaces.forEach { shaderBufs.remove(it) }\n            newSurfaces.forEach { shaderBufs[it] = shaderBufsFor(it) }\n        }\n    }\n\n    class ShaderBufs(\n        val solidShaderBuffer: SolidShader.Buffer,\n        val sineWaveShaderBuffer: SineWaveShader.Buffer,\n        val compositorShaderBuffer: CompositorShader.Buffer\n    )\n}\n","package baaahs.shows\n\nimport baaahs.Color\nimport baaahs.Model\nimport baaahs.Show\nimport baaahs.ShowRunner\nimport baaahs.gadgets.ColorPicker\nimport baaahs.shaders.PixelShader\n\nobject CreepingPixelsShow : Show(\"Creeping Pixels\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        val colorPicker = showRunner.getGadget(\"color\", ColorPicker(\"Color\"))\n\n        val shader = PixelShader(PixelShader.Encoding.INDEXED_2)\n        val shaderBuffers = showRunner.allSurfaces.map {\n            showRunner.getShaderBuffer(it, shader).apply {\n                palette[0] = Color.BLACK\n            }\n        }\n\n        return object : Renderer {\n            var i: Int = 0\n\n            override fun nextFrame() {\n                val color = colorPicker.color\n\n                shaderBuffers.forEach {\n                    it.palette[1] = color\n                    it.setAll(0)\n                    it[i % it.colors.size] = 1\n                }\n                i++\n            }\n        }\n    }\n}","package baaahs.shows\n\nimport baaahs.*\nimport baaahs.gadgets.ColorPicker\nimport baaahs.gadgets.Slider\nimport baaahs.shaders.GlslShader\n\nabstract class GlslShow(name: String) : Show(name) {\n    abstract val program: String\n\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        val shader = GlslShader(program)\n\n        val adjustableValuesToDataSources = shader.adjustableValues.associateWith { it.createDataSource(showRunner) }\n        val buffers = showRunner.allSurfaces.associateWithTo(hashMapOf()) { showRunner.getShaderBuffer(it, shader) }\n\n        return object : Renderer {\n            override fun nextFrame() {\n                buffers.values.forEach { buffer ->\n                    adjustableValuesToDataSources.forEach { (adjustableValue, dataSource) ->\n                        val value: Any = dataSource.getValue()\n                        buffer.update(adjustableValue, value)\n                    }\n                }\n            }\n\n            override fun surfacesChanged(newSurfaces: List<Surface>, removedSurfaces: List<Surface>) {\n                removedSurfaces.forEach { buffers.remove(it) }\n                newSurfaces.forEach { buffers[it] = showRunner.getShaderBuffer(it, shader) }\n            }\n        }\n    }\n\n    fun GlslShader.AdjustableValue.createDataSource(showRunner: ShowRunner): DataSource {\n        val config = config\n        val name = config.getPrimitive(\"name\").contentOrNull ?: varName\n\n        return when (gadgetType) {\n            \"Slider\" -> {\n                GadgetDataSource(showRunner.getGadget(\"glsl_${varName}\", Slider(\n                    name,\n                    initialValue = config.getPrimitiveOrNull(\"initialValue\")?.float ?: 1f,\n                    minValue = config.getPrimitiveOrNull(\"minValue\")?.float ?: 0f,\n                    maxValue = config.getPrimitiveOrNull(\"maxValue\")?.float ?: 1f\n                )))\n            }\n            \"ColorPicker\" -> {\n                GadgetDataSource(showRunner.getGadget(\"glsl_${varName}\", ColorPicker(name)))\n            }\n            \"Beat\" -> {\n                BeatDataSource(showRunner.getBeatSource().getBeatData(), showRunner.clock)\n            }\n            \"StartOfMeasure\" -> {\n                StartOfMeasureDataSource(showRunner.getBeatSource().getBeatData(), showRunner.clock)\n            }\n            else -> throw IllegalArgumentException(\"unknown gadget ${gadgetType}\")\n        }\n    }\n\n    interface DataSource {\n        fun getValue(): Any\n    }\n\n    class GadgetDataSource(val gadget: Gadget) : DataSource {\n        override fun getValue(): Any {\n            return when (gadget) {\n                is Slider -> gadget.value\n                is ColorPicker -> gadget.color\n                else -> throw IllegalArgumentException(\"unsupported gadget $gadget\")\n            }\n        }\n    }\n\n    class BeatDataSource(val beatData: BeatData, val clock: Clock) : DataSource {\n        override fun getValue(): Any {\n            return beatData.fractionTilNextBeat(clock)\n        }\n    }\n\n    class StartOfMeasureDataSource(val beatData: BeatData, val clock: Clock) : DataSource {\n        override fun getValue(): Any {\n            return beatData.fractionTilNextMeasure(clock)\n        }\n    }\n}","package baaahs.shows\n\nimport baaahs.*\nimport baaahs.gadgets.Slider\nimport baaahs.shaders.HeartShader\nimport baaahs.shaders.SolidShader\nimport kotlin.math.PI\nimport kotlin.math.abs\nimport kotlin.math.sin\n\nobject HeartbleatShow : Show(\"Heartbleat\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        model as SheepModel\n\n        return object : Renderer {\n            val hearts = showRunner.allSurfaces.filter { it is IdentifiedSurface && it.number == 7 }\n                .map { showRunner.getShaderBuffer(it, HeartShader()) }\n            val heartSizeGadget = showRunner.getGadget(\"heartSize\", Slider(\"Heart Size\", .16f))\n            val strokeSize = showRunner.getGadget(\"strokeSize\", Slider(\"Stroke Size\", .5f))\n            val xOff = showRunner.getGadget(\"xOff\", Slider(\"X Offset\", .4f))\n            val yOff = showRunner.getGadget(\"yOff\", Slider(\"Y Offset\", .67f))\n            val otherSurfaces = showRunner.allUnusedSurfaces.map { showRunner.getShaderBuffer(it, SolidShader()) }\n\n            override fun nextFrame() {\n                val currentBeat = showRunner.currentBeat\n                var phase = (currentBeat % 1.0) * 3.0f\n                val heartSize = heartSizeGadget.value * if (phase > 1.5 && phase < 2.5f) {\n                    1f + ((.5f - abs(phase - 2)) / 4).toFloat()\n                } else if (phase > 2.5f || phase < 0.5f) {\n                    if (phase > 2.5f) phase -= 3\n                    1f + ((.5f - abs(phase)) / 2).toFloat()\n                } else {\n                    1f\n                }\n\n                hearts.forEach {\n                    it.heartSize = heartSize\n                    it.strokeSize = strokeSize.value\n                    it.xOff = xOff.value\n                    it.yOff = yOff.value\n                }\n\n                otherSurfaces.forEach {\n                    it.color = Color(.25f, .25f, .25f)\n                        .fade(Color(.75f, .3f, .3f), sin(currentBeat / 4.0f * PI).toFloat())\n                }\n            }\n        }\n    }\n\n    val IdentifiedSurface.number: Int\n        get() = Regex(\"\\\\d+\").find(name)?.value?.toInt() ?: -1\n}\n","package baaahs.shows\n\nimport baaahs.*\nimport baaahs.gadgets.Slider\nimport baaahs.shaders.SolidShader\nimport kotlin.random.Random\n\nobject LifeyShow : Show(\"Lifey\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        model as SheepModel\n\n        val speedSlider = showRunner.getGadget(\"speed\", Slider(\"Speed\", .25f))\n\n        val shader = SolidShader()\n        val shaderBuffers = showRunner.allSurfaces.associateWith {\n            showRunner.getShaderBuffer(it, shader).apply { color = Color.WHITE }\n        }\n\n        val selectedPanels = mutableListOf<SheepModel.Panel>()\n        var lastUpdateMs: Long = 0\n\n        fun SheepModel.Panel.neighbors() = model.neighborsOf(this)\n        fun SheepModel.Panel.isSelected() = selectedPanels.contains(this)\n        fun SheepModel.Panel.neighborsSelected() = neighbors().filter { selectedPanels.contains(it) }.count()\n\n        return object : Renderer {\n            override fun nextFrame() {\n                val nowMs = getTimeMillis()\n                val intervalMs = ((1f - speedSlider.value) * 1000).toLong()\n                if (nowMs > lastUpdateMs + intervalMs) {\n                    if (selectedPanels.isEmpty()) {\n                        selectedPanels.addAll(model.allPanels.filter { Random.nextFloat() < .5 })\n                    } else {\n                        val newSelectedPanels = mutableListOf<SheepModel.Panel>()\n                        selectedPanels.forEach { panel ->\n                            var living = panel.isSelected()\n\n                            val neighborsSelected = panel.neighborsSelected()\n                            if (living) {\n                                if (neighborsSelected < 1 || neighborsSelected > 3) {\n                                    living = false\n\n                                    // super-lonely panels will move next door instead of dying...\n                                    if (neighborsSelected == 0) {\n                                        val moveToNeighbor = panel.neighbors().random()\n                                        moveToNeighbor?.let { newSelectedPanels.add(it) }\n                                        living = false\n                                    }\n                                }\n                            } else {\n                                if (neighborsSelected == 2 || neighborsSelected == 3) {\n                                    living = true\n                                }\n                            }\n\n                            // sometimes panels spontaneously become alive or die...\n                            if (Random.nextFloat() < .1) {\n                                living = !living\n                            }\n\n                            if (living) {\n                                newSelectedPanels.add(panel)\n                            }\n                        }\n                        selectedPanels.clear()\n                        selectedPanels.addAll(newSelectedPanels)\n                    }\n\n                    lastUpdateMs = nowMs\n                }\n\n                shaderBuffers.forEach { (surface, buffer) ->\n                    buffer.color =\n                        if (surface is IdentifiedSurface\n                            && selectedPanels.contains(surface.modelSurface)) Color.WHITE else Color.BLACK\n                }\n            }\n        }\n    }\n}","package baaahs.shows\n\nimport baaahs.*\nimport baaahs.shaders.PixelShader\nimport kotlin.random.Random\n\nobject PixelTweenShow : Show(\"PixelTweenShow\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        val colorArray = arrayOf(\n            Color.from(\"#FF8A47\"),\n            Color.from(\"#FC6170\"),\n            Color.from(\"#8CEEEE\"),\n            Color.from(\"#26BFBF\"),\n            Color.from(\"#FFD747\")\n        )\n\n        return object : Renderer {\n            val shaderBuffers = showRunner.allSurfaces.map { surface ->\n                showRunner.getShaderBuffer(surface, PixelShader())\n            }\n            val fadeTimeMs = 1000\n\n            override fun nextFrame() {\n                val now = getTimeMillis().and(0xfffffff).toInt()\n                shaderBuffers.forEachIndexed { i, buffer ->\n                    val colorIndex = (now / fadeTimeMs + i) % colorArray.size\n                    val startColor = colorArray[colorIndex]\n                    val endColor = colorArray[(colorIndex + 1) % colorArray.size]\n\n                    val colors = buffer.colors\n                    colors.forEachIndexed { index, _ ->\n                        if (Random.nextFloat() < .1) {\n                            colors[index] = Color.WHITE\n                        } else {\n                            val tweenedColor =\n                                startColor.fade(endColor, ((now + index) % fadeTimeMs) / fadeTimeMs.toFloat())\n                            colors[index] = tweenedColor\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    val SheepModel.Panel.number: Int\n        get() = Regex(\"\\\\d+\").find(name)?.value?.toInt() ?: -1\n\n}\n","package baaahs.shows\n\nimport baaahs.Color\nimport baaahs.Model\nimport baaahs.Show\nimport baaahs.ShowRunner\nimport baaahs.dmx.Shenzarpy\nimport baaahs.shaders.RandomShader\nimport kotlin.random.Random\n\nobject RandomShow : Show(\"Random\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner) = object : Renderer {\n        init {\n            showRunner.allSurfaces.map { surface -> showRunner.getShaderBuffer(surface, RandomShader()) }\n        }\n\n        val movingHeadBuffers = model.movingHeads.map { showRunner.getMovingHeadBuffer(it) }\n\n        override fun nextFrame() {\n            movingHeadBuffers.forEach { shenzarpy ->\n                shenzarpy.color = Color.random()\n                shenzarpy.pan = Random.nextFloat() * Shenzarpy.panRange.endInclusive\n                shenzarpy.tilt = Random.nextFloat() * Shenzarpy.tiltRange.endInclusive\n            }\n        }\n    }\n}\n","package baaahs.shows\n\nimport baaahs.Model\nimport baaahs.Show\nimport baaahs.ShowRunner\nimport baaahs.gadgets.ColorPicker\nimport baaahs.gadgets.Slider\nimport baaahs.shaders.SimpleSpatialShader\n\nobject SimpleSpatialShow : Show(\"Spatial\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        val colorPicker = showRunner.getGadget(\"color\", ColorPicker(\"Color\"))\n        val centerXSlider = showRunner.getGadget(\"centerX\", Slider(\"center X\", 0.5f, 0f, 1f, 0.01f))\n        val centerYSlider = showRunner.getGadget(\"centerY\", Slider(\"center Y\", 0.5f, 0f, 1f, 0.01f))\n        val radiusSlider = showRunner.getGadget(\"radius\", Slider(\"radius\", 0.25f, 0f, 1f, 0.01f))\n\n        val shader = SimpleSpatialShader()\n        val shaderBuffers = showRunner.allSurfaces.map {\n            showRunner.getShaderBuffer(it, shader)\n        }\n\n        return object : Renderer {\n            override fun nextFrame() {\n                shaderBuffers.forEach {\n                    it.color = colorPicker.color\n                    it.centerX = centerXSlider.value\n                    it.centerY = centerYSlider.value\n                    it.radius = radiusSlider.value\n                }\n            }\n        }\n    }\n}","package baaahs.shows\n\nimport baaahs.Color\nimport baaahs.Model\nimport baaahs.Show\nimport baaahs.ShowRunner\nimport baaahs.gadgets.ColorPicker\nimport baaahs.shaders.SolidShader\n\nobject SolidColorShow : Show(\"Solid Color\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner): Renderer {\n        val colorPicker = showRunner.getGadget(\"color\", ColorPicker(\"Color\"))\n\n        val shader = SolidShader()\n        val shaderBuffers = showRunner.allSurfaces.map {\n            showRunner.getShaderBuffer(it, shader).apply { color = Color.WHITE }\n        }\n\n        val eyes = model.movingHeads.map { eye -> showRunner.getMovingHeadBuffer(eye) }\n\n        return object : Renderer {\n            override fun nextFrame() {\n                val color = colorPicker.color\n                shaderBuffers.forEach { it.color = color }\n                eyes.forEach { it.color = color }\n            }\n        }\n    }\n}","package baaahs.shows\n\nimport baaahs.*\nimport baaahs.gadgets.ColorPicker\nimport baaahs.shaders.PixelShader\nimport kotlin.math.abs\nimport kotlin.math.sin\nimport kotlin.random.Random\n\nobject SomeDumbShow : Show(\"SomeDumbShow\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner) = object : Renderer {\n        val colorPicker = showRunner.getGadget(\"color\", ColorPicker(\"Color\"))\n        val pixelShader = PixelShader()\n\n        val pixelShaderBuffers =\n            showRunner.allSurfaces.map { surface -> showRunner.getShaderBuffer(surface, pixelShader) }\n        val movingHeads = model.movingHeads.map { showRunner.getMovingHeadBuffer(it) }\n\n        override fun nextFrame() {\n            val seed = Random(0)\n            val now = getTimeMillis()\n\n            fun Random.nextTimeShiftedFloat(): Float =\n                sin(nextFloat() + now / 1000.0).toFloat()\n\n            fun Color.desaturateRandomishly(baseSaturation: Float, seed: Random): Color {\n                return withSaturation(baseSaturation * abs(seed.nextFloat()))\n            }\n\n            pixelShaderBuffers.forEach { shaderBuffer ->\n                val baseSaturation = seed.nextFloat()\n                val panelColor = if (seed.nextTimeShiftedFloat() < 0.1) Color.random() else colorPicker.color\n\n                for (i in shaderBuffer.colors.indices) {\n                    shaderBuffer.colors[i] = panelColor.desaturateRandomishly(baseSaturation, seed)\n                }\n            }\n\n            movingHeads.forEach { buf ->\n                buf.color = colorPicker.color\n                buf.pan += (seed.nextTimeShiftedFloat() - .5f) / 5\n                buf.tilt += (seed.nextTimeShiftedFloat() - .5f) / 5\n            }\n        }\n    }\n}\n","package baaahs.shows\n\nimport baaahs.Color\nimport baaahs.Model\nimport baaahs.Show\nimport baaahs.ShowRunner\nimport baaahs.gadgets.ColorPicker\nimport baaahs.shaders.CompositingMode\nimport baaahs.shaders.CompositorShader\nimport baaahs.shaders.SineWaveShader\nimport baaahs.shaders.SolidShader\nimport kotlin.math.roundToInt\nimport kotlin.random.Random\n\nobject ThumpShow : Show(\"Thump\") {\n    override fun createRenderer(model: Model<*>, showRunner: ShowRunner) = object : Renderer {\n        private val beatSource = showRunner.getBeatSource()\n        val colorPicker = showRunner.getGadget(\"color\", ColorPicker(\"Color\"))\n\n        val solidShader = SolidShader()\n        val sineWaveShader = SineWaveShader()\n        val compositorShader = CompositorShader(solidShader, sineWaveShader)\n\n        private val shaderBufs = showRunner.allSurfaces.map { surface ->\n            val solidShaderBuffer = showRunner.getShaderBuffer(surface, solidShader)\n\n            val sineWaveShaderBuffer = showRunner.getShaderBuffer(surface, sineWaveShader).apply {\n                density = Random.nextFloat() * 20\n            }\n\n            val compositorShaderBuffer =\n                showRunner.getCompositorBuffer(surface, solidShaderBuffer, sineWaveShaderBuffer, CompositingMode.ADD, 1f)\n\n            ShaderBufs(solidShaderBuffer, sineWaveShaderBuffer, compositorShaderBuffer)\n        }\n\n        private val movingHeadBuffers = model.movingHeads.map { showRunner.getMovingHeadBuffer(it) }\n\n        init {\n//        println(\"Created new CompositeShow, we have ${shaderBufs.size} buffers\")\n        }\n\n        override fun nextFrame() {\n//            val theta = ((getTimeMillis() / 1000f) % (2 * PI)).toFloat()\n            val beat = showRunner.currentBeat\n\n            var i = 0\n            val beatColor: Color = Color.WHITE.fade(colorPicker.color, beat % 1)\n\n            shaderBufs.forEach { shaderBuffer ->\n                shaderBuffer.solidShaderBuffer.color = beatColor\n                shaderBuffer.sineWaveShaderBuffer.color = beatColor\n//                shaderBuffer.sineWaveShaderBuffer.theta = theta + i++\n                shaderBuffer.compositorShaderBuffer.mode = CompositingMode.ADD\n                shaderBuffer.compositorShaderBuffer.fade = 1f\n            }\n\n            movingHeadBuffers.forEach { buf ->\n                buf.color = beatColor\n                buf.pan = beat.roundToInt().toFloat() / 2\n                buf.tilt = beat.roundToInt().toFloat() / 2\n            }\n        }\n    }\n\n    class ShaderBufs(\n        val solidShaderBuffer: SolidShader.Buffer,\n        val sineWaveShaderBuffer: SineWaveShader.Buffer,\n        val compositorShaderBuffer: CompositorShader.Buffer\n    )\n}\n","package baaahs.sim\n\nimport baaahs.Dmx\n\nclass FakeDmxUniverse : Dmx.Universe() {\n    private val channelsOut = ByteArray(512)\n    private val channelsIn = ByteArray(512)\n    private val listeners = mutableListOf<() -> Unit>()\n\n    override fun writer(baseChannel: Int, channelCount: Int) =\n        Dmx.Buffer(channelsOut, baseChannel, channelCount)\n\n    fun reader(baseChannel: Int, channelCount: Int, listener: () -> Unit): Dmx.Buffer {\n        listeners.add(listener)\n        return Dmx.Buffer(channelsIn, baseChannel, channelCount)\n    }\n\n    override fun sendFrame() {\n        channelsOut.copyInto(channelsIn)\n        updateListeners()\n    }\n\n    override fun allOff() {\n        for (i in 0 until 512) channelsIn[i] = 0\n        updateListeners()\n    }\n\n    private fun updateListeners() {\n        listeners.forEach { it() }\n    }\n}","package baaahs.sim\n\nimport baaahs.Logger\nimport baaahs.io.Fs\n\n@UseExperimental(ExperimentalStdlibApi::class)\nclass FakeFs : Fs {\n    private val files = mutableMapOf<String, ByteArray>()\n\n    override fun listFiles(path: String): List<String> {\n        logger.debug { \"FakeFs.listFiles($path)\" }\n        return files.keys.filter { it.startsWith(\"$path/\") }\n    }\n\n    override fun loadFile(path: String): String? {\n        logger.debug { \"FakeFs.loadFile($path)\" }\n        return files[path]?.decodeToString()\n    }\n\n    override fun createFile(path: String, content: ByteArray, allowOverwrite: Boolean) {\n        logger.debug { \"FakeFs.createFile($path) -> ${content.size} bytes\" }\n        addFile(path, content)\n    }\n\n    override fun createFile(path: String, content: String, allowOverwrite: Boolean) {\n        createFile(path, content.encodeToByteArray(), allowOverwrite)\n    }\n\n    private fun addFile(path: String, content: ByteArray) {\n        if (files.containsKey(path)) {\n            throw Exception(\"$path already exists\")\n        }\n        files[path] = content\n    }\n\n    companion object {\n        val logger = Logger(\"FakeFs\")\n    }\n}","package baaahs.sim\n\nimport baaahs.NetworkDisplay\nimport baaahs.net.Network\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.coroutines.EmptyCoroutineContext\nimport kotlin.random.Random\n\nclass FakeNetwork(\n    private val networkDelay: Int = 1,\n    private val display: NetworkDisplay? = null,\n    coroutineContext: CoroutineContext = EmptyCoroutineContext\n) : Network {\n    private val coroutineScope: CoroutineScope = object : CoroutineScope {\n        override val coroutineContext: CoroutineContext get() = coroutineContext\n    }\n    private var nextAddress = 0xb00f\n    private val udpListeners: MutableMap<Pair<Network.Address, Int>, Network.UdpListener> = hashMapOf()\n    private val udpListenersByPort: MutableMap<Int, MutableList<Network.UdpListener>> = hashMapOf()\n\n    private val httpServersByPort:\n            MutableMap<Pair<Network.Address, Int>, FakeLink.FakeHttpServer> = hashMapOf()\n\n    override fun link(): Network.Link {\n        val address = FakeAddress(nextAddress++)\n        return FakeLink(address)\n    }\n\n    private fun sendPacketSuccess() = Random.nextFloat() > packetLossRate() / 2\n    private fun receivePacketSuccess() = Random.nextFloat() > packetLossRate() / 2\n    private fun packetLossRate() = display?.packetLossRate ?: 0f\n\n    private inner class FakeLink(override val myAddress: Network.Address) : Network.Link {\n        override val udpMtu = 1500\n        private var nextAvailablePort = 65000\n\n        override fun listenUdp(port: Int, udpListener: Network.UdpListener): Network.UdpSocket {\n            val serverPort = if (port == 0) nextAvailablePort++ else port\n            udpListeners.put(Pair(myAddress, serverPort), udpListener)\n            val portListeners = udpListenersByPort.getOrPut(serverPort) { mutableListOf() }\n            portListeners.add(udpListener)\n            return FakeUdpSocket(serverPort)\n        }\n\n        override fun startHttpServer(port: Int): Network.HttpServer {\n            val fakeHttpServer = FakeHttpServer(port)\n            httpServersByPort[myAddress to port] = fakeHttpServer\n            return fakeHttpServer\n        }\n\n        override fun connectWebSocket(\n            toAddress: Network.Address,\n            port: Int,\n            path: String,\n            webSocketListener: Network.WebSocketListener\n        ): Network.TcpConnection {\n            val fakeHttpServer = httpServersByPort[toAddress to port]\n            val onConnectCallback = fakeHttpServer?.webSocketListeners?.get(path)\n            if (onConnectCallback == null) {\n                val connection = FakeTcpConnection(myAddress, toAddress, port, null)\n                coroutineScope.launch {\n                    networkDelay()\n                    webSocketListener.reset(connection)\n                }\n                return connection\n            }\n\n            lateinit var clientSideConnection: FakeTcpConnection\n            val serverSideConnection = FakeTcpConnection(myAddress, toAddress, port, webSocketListener) {\n                clientSideConnection\n            }\n\n            val serverListener = onConnectCallback(serverSideConnection)\n\n            clientSideConnection = FakeTcpConnection(myAddress, toAddress, port, serverListener) {\n                serverSideConnection\n            }\n\n            coroutineScope.launch {\n                networkDelay()\n                webSocketListener.connected(clientSideConnection)\n            }\n\n            coroutineScope.launch {\n                networkDelay()\n                serverListener.connected(serverSideConnection)\n            }\n\n            return clientSideConnection\n        }\n\n        inner class FakeTcpConnection(\n            override val fromAddress: Network.Address,\n            override val toAddress: Network.Address,\n            override val port: Int,\n            private val webSocketListener: Network.WebSocketListener? = null,\n            private val otherListener: (() -> Network.TcpConnection)? = null\n        ) : Network.TcpConnection {\n            override fun send(bytes: ByteArray) {\n                coroutineScope.launch {\n                    webSocketListener?.receive(otherListener!!(), bytes)\n                }\n            }\n        }\n\n        private inner class FakeUdpSocket(override val serverPort: Int) : Network.UdpSocket {\n            override fun sendUdp(toAddress: Network.Address, port: Int, bytes: ByteArray) {\n                if (!sendPacketSuccess()) {\n                    display?.droppedPacket()\n                    return\n                }\n\n                val listener = udpListeners[Pair(toAddress, port)]\n                if (listener != null) transmitUdp(myAddress, serverPort, listener, bytes)\n            }\n\n            override fun broadcastUdp(port: Int, bytes: ByteArray) {\n                if (!sendPacketSuccess()) {\n                    display?.droppedPacket()\n                    return\n                }\n\n                udpListenersByPort[port]?.forEach { listener ->\n                    transmitUdp(myAddress, serverPort, listener, bytes)\n                }\n            }\n\n            private fun transmitUdp(\n                fromAddress: Network.Address,\n                fromPort: Int,\n                udpListener: Network.UdpListener,\n                bytes: ByteArray\n            ) {\n                coroutineScope.launch {\n                    networkDelay()\n\n                    if (!receivePacketSuccess()) {\n                        display?.droppedPacket()\n                    } else {\n                        display?.receivedPacket()\n                        udpListener.receive(fromAddress, fromPort, bytes)\n                    }\n                }\n            }\n        }\n\n        internal inner class FakeHttpServer(val port: Int) : Network.HttpServer {\n            val webSocketListeners: MutableMap<String, (Network.TcpConnection) -> Network.WebSocketListener> =\n                mutableMapOf()\n\n            override fun listenWebSocket(\n                path: String,\n                onConnect: (incomingConnection: Network.TcpConnection) -> Network.WebSocketListener\n            ) {\n                webSocketListeners[path] = onConnect\n            }\n        }\n    }\n\n    private suspend fun networkDelay() {\n        if (networkDelay != 0) delay(networkDelay.toLong())\n    }\n\n    private data class FakeAddress(val id: Int) : Network.Address {\n        override fun toString(): String = \"x${id.toString(16)}\"\n    }\n}","package baaahs\n\nimport com.soywiz.klock.DateFormat\nimport com.soywiz.klock.DateTime\nimport kotlinx.coroutines.delay\nimport kotlin.math.PI\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.random.Random\n\nfun <E> List<E>.random(): E? = if (size > 0) get(Random.nextInt(size)) else null\n\nfun <E> List<E>.random(random: Random): E? = if (size > 0) get(random.nextInt(size)) else null\n\nfun <E> Collection<E>.only(description: String = \"item\"): E {\n    if (size != 1) throw IllegalArgumentException(\"Expected one $description, found $size: $this\")\n    else return iterator().next()\n}\n\nfun toRadians(degrees: Float) = (degrees * PI / 180).toFloat()\n\nfun constrain(value: Float, minValue: Float, maxValue: Float): Float {\n    return max(min(value, maxValue), minValue)\n}\n\nsuspend fun randomDelay(timeMs: Int) {\n    delay(Random.nextInt(timeMs).toLong())\n}\n\nclass Logger(val id: String) {\n    private fun log(level: String, message: String) {\n        println(\"${ts()} [] $level  $id - $message\")\n    }\n\n    private fun log(level: String, message: String, exception: Exception) {\n        println(\"${ts()} [] $level  $id - $message: ${exception.message}\")\n    }\n\n    fun debug(message: () -> String) {\n        log(\"DEBUG\", message.invoke())\n    }\n\n    fun info(message: () -> String) {\n        log(\"INFO\", message.invoke())\n    }\n\n    fun warn(message: () -> String) {\n        log(\"WARN\", message.invoke())\n    }\n\n    fun error(message: () -> String) {\n        log(\"ERROR\", message.invoke())\n    }\n\n    fun error(message: String, exception: Exception) {\n        log(\"ERROR\", message, exception)\n    }\n\n    fun error(message: () -> String, exception: Exception) {\n        log(\"ERROR\", message.invoke(), exception)\n    }\n\n    companion object {\n        private val FORMAT by lazy { DateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\") }\n\n        fun ts(): String {\n            return DateTime.now().format(FORMAT)\n        }\n\n    }\n}\n\n\nexpect fun getTimeMillis(): Long\nexpect fun doRunBlocking(block: suspend () -> Unit)\n\nexpect fun getResource(name: String): String\n\nexpect fun decodeBase64(s: String): ByteArray\n\ninternal suspend fun time(function: suspend () -> Unit): Long {\n    val now = getTimeMillis()\n    function.invoke()\n    return getTimeMillis() - now\n}\n\ninternal fun timeSync(function: () -> Unit): Long {\n    val now = getTimeMillis()\n    function.invoke()\n    return getTimeMillis() - now\n}\n","package baaahs\n\nimport baaahs.net.Network\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport org.w3c.dom.Document\nimport org.w3c.dom.Element\nimport org.w3c.dom.HTMLSelectElement\nimport org.w3c.dom.get\nimport kotlin.browser.document\nimport kotlin.dom.addClass\nimport kotlin.dom.appendElement\nimport kotlin.dom.appendText\nimport kotlin.dom.clear\n\nclass JsDisplay : Display {\n    override fun forNetwork(): NetworkDisplay = JsNetworkDisplay(document)\n\n    override fun forPinky(): PinkyDisplay =\n        JsPinkyDisplay(document.getElementById(\"pinkyView\")!!)\n\n    override fun forBrain(): BrainDisplay =\n        JsBrainDisplay(\n            document.getElementById(\"brainsView\")!!,\n            document.getElementById(\"brainDetails\")!!\n        )\n\n    override fun forVisualizer(): VisualizerDisplay = JsVisualizerDisplay()\n}\n\nclass JsNetworkDisplay(document: Document) : NetworkDisplay {\n    private val packetLossRateSpan = document.getElementById(\"networkPacketLossRate\")!!.apply {\n        addEventListener(\"click\", {\n            packetLossRate = kotlin.browser.window.prompt(\n                \"Packet loss rate (%):\", \"${(packetLossRate * 100).toInt()}\"\n            )!!.toFloat() / 100\n        })\n    }\n\n    override var packetLossRate: Float = 0.05f\n        set(value) {\n            packetLossRateSpan.textContent = \"${(value * 100).toInt()}%\"\n            field = value\n        }\n\n    init {\n//        packetLossRate = 0.05f\n        packetLossRate = 0.0f\n    }\n\n    private val packetsReceivedSpan = document.getElementById(\"networkPacketsReceived\")!!\n    private val packetsDroppedSpan = document.getElementById(\"networkPacketsDropped\")!!\n\n    private var packetsReceived = 0\n    private var packetsDropped = 0\n\n    override fun receivedPacket() {\n        packetsReceivedSpan.textContent = packetsReceived++.toString()\n    }\n\n    override fun droppedPacket() {\n        packetsDroppedSpan.textContent = packetsDropped++.toString()\n    }\n}\n\nclass JsPinkyDisplay(element: Element) : PinkyDisplay {\n    override var onShowChange: (() -> Unit) = {}\n    override var selectedShow: Show? = null\n        set(value) {\n            field = value\n            val options = showListInput.options\n            for (i in 0 until options.length) {\n                if (options[i]?.textContent == value?.name) showListInput.selectedIndex = i\n            }\n        }\n\n    override var showFrameMs: Int = 0\n        set(value) {\n            field = value\n            showFramerate.textContent = \"${1000 / value}fps\"\n            showElapsedMs.textContent = \"${value}ms\"\n        }\n\n    override var stats: Pinky.NetworkStats? = null\n        set(value) {\n            field = value\n            statsSpan.textContent = value?.run { \"$bytesSent bytes / $packetsSent packets sent\" } ?: \"?\"\n        }\n\n    private val brainCountDiv: Element\n    private val beat1: Element\n    private val beat2: Element\n    private val beat3: Element\n    private val beat4: Element\n    private val beats: List<Element>\n    private val bpmSpan: Element\n    private val beatConfidenceElement: Element\n    private var showList = emptyList<Show>()\n    private val showListInput: HTMLSelectElement\n    private var showFramerate: Element = document.getElementById(\"showFramerate\")!!\n    private var showElapsedMs: Element = document.getElementById(\"showElapsedMs\")!!\n    private var statsSpan: Element\n\n    init {\n        element.appendText(\"Brains online: \")\n        brainCountDiv = element.appendElement(\"span\") {}\n\n        val beatsDiv = element.appendElement(\"div\") {\n            id = \"beatsDiv\"\n            appendElement(\"b\") { appendText(\"Beats: \") }\n        }\n        beatConfidenceElement = beatsDiv.appendElement(\"b\") {\n            appendText(\"[confidence: ?]\")\n            appendElement(\"br\") {}\n        }\n        bpmSpan = beatsDiv.appendElement(\"h1\") { appendText(\"\u2026BPM !!\") }\n        bpmSpan.classList.add(\"bpmDisplay-beatOff\")\n        beat1 = beatsDiv.appendElement(\"span\") { appendText(\"1\") }\n        beat2 = beatsDiv.appendElement(\"span\") { appendText(\"2\") }\n        beat3 = beatsDiv.appendElement(\"span\") { appendText(\"3\") }\n        beat4 = beatsDiv.appendElement(\"span\") { appendText(\"4\") }\n        beats = listOf(beat1, beat2, beat3, beat4)\n\n        element.appendElement(\"b\") { appendText(\"Renderer: \") }\n        showListInput = element.appendElement(\"select\") { className = \"showsDiv\" } as HTMLSelectElement\n        showListInput.onchange = {\n            selectedShow = showList.find { it.name == showListInput.selectedOptions[0]?.textContent }\n            onShowChange.invoke()\n        }\n\n        element.appendElement(\"br\") { }\n        element.appendElement(\"b\") { appendText(\"Data to Brains: \") }\n        statsSpan = element.appendElement(\"span\") {}\n    }\n\n    override fun listShows(shows: List<Show>) {\n        showListInput.clear()\n        showList = shows\n        shows.forEach {\n            showListInput.appendElement(\"option\") { appendText(it.name) }\n        }\n    }\n\n    override var brainCount: Int = 0\n        set(value) {\n            brainCountDiv.clear()\n            brainCountDiv.appendText(value.toString())\n            field = value\n        }\n\n    override var beat: Int = 0\n        set(value) {\n            try {\n                beats[field].classList.clear()\n                beats[value].classList.add(\"selected\")\n                if (value % 2 == 1) {\n                    bpmSpan.classList.add(\"bpmDisplay-beatOn\")\n                    bpmSpan.textContent = bpmSpan.textContent + \"!!\"\n                } else {\n                    bpmSpan.classList.remove(\"bpmDisplay-beatOn\")\n                    bpmSpan.textContent = bpmSpan.textContent?.removeSuffix(\" !!\")\n                }\n            } catch (e: Exception) {\n                println(\"durrr error $e\")\n            }\n\n            field = value\n        }\n\n    fun Double.format(digits: Int): String = this.asDynamic().toFixed(digits) as String\n    fun Float.format(digits: Int): String = this.asDynamic().toFixed(digits) as String\n\n    override var bpm: Float = 0.0f\n        set(value) {\n            if (beat % 2 == 0) {\n                bpmSpan.textContent = \"${value.format(1)} BPM !!\"\n            } else {\n                bpmSpan.textContent = \"${value.format(1)} BPM\"\n            }\n            field = value\n        }\n\n    override var beatConfidence: Float = 1.0f\n        set(value) {\n            beatConfidenceElement.textContent = \"[confidence: ${value * 100}%]\"\n            field = value\n        }\n}\n\nclass JsBrainDisplay(container: Element, detailsContainer: Element) : BrainDisplay {\n    override var id: String? = null\n    override var surface: Surface? = null\n    override var onReset: suspend () -> Unit = {}\n\n    private var myDiv = container.appendElement(\"div\") {\n        addClass(\"brain-box\", \"brain-offline\")\n        this.addEventListener(\"click\", { GlobalScope.launch { onReset() } })\n        this.addEventListener(\"mouseover\", {\n            detailsContainer.clear()\n            detailsContainer.appendElement(\"hr\") {}\n            detailsContainer.appendElement(\"b\") {\n                appendText(\"Brain ${this@JsBrainDisplay.id}\")\n            }\n            detailsContainer.appendElement(\"div\") {\n                appendText(\"Surface: ${surface?.describe()}\")\n            }\n        })\n    }\n\n    override fun haveLink(link: Network.Link) {\n        myDiv.classList.remove(\"brain-offline\")\n        myDiv.classList.add(\"brain-link\")\n    }\n}\n\nclass JsVisualizerDisplay : VisualizerDisplay {\n    private var visualizerFramerate: Element = document.getElementById(\"visualizerFramerate\")!!\n    private var visualizerElapsedMs: Element = document.getElementById(\"visualizerElapsedMs\")!!\n\n    override var renderMs: Int = 0\n        set(value) {\n            field = value\n            visualizerFramerate.textContent = \"${1000 / value}fps\"\n            visualizerElapsedMs.textContent = \"${value}ms\"\n        }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.dom\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Navigator](https://developer.mozilla.org/en/docs/Web/API/Navigator) to Kotlin\n */\npublic external abstract class Navigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n    open val maxTouchPoints: Int\n    open val mediaDevices: MediaDevices\n    open val clipboard: Clipboard\n    fun vibrate(pattern: dynamic): Boolean\n    fun getUserMedia(constraints: MediaStreamConstraints, successCallback: (MediaStream) -> Unit, errorCallback: (dynamic) -> Unit): Unit\n}\n\n/**\n * Exposes the JavaScript [Document](https://developer.mozilla.org/en/docs/Web/API/Document) to Kotlin\n */\npublic external open class Document : Node, GlobalEventHandlers, DocumentAndElementEventHandlers, NonElementParentNode, DocumentOrShadowRoot, ParentNode, GeometryUtils {\n    open val fullscreenEnabled: Boolean\n    open val fullscreen: Boolean\n    var onfullscreenchange: ((Event) -> dynamic)?\n    var onfullscreenerror: ((Event) -> dynamic)?\n    open val rootElement: SVGSVGElement?\n    var title: String\n    open val referrer: String\n    var domain: String\n    open val activeElement: Element?\n    open val location: Location?\n    var cookie: String\n    open val lastModified: String\n    open val readyState: DocumentReadyState\n    var dir: String\n    var body: HTMLElement?\n    open val head: HTMLHeadElement?\n    open val images: HTMLCollection\n    open val embeds: HTMLCollection\n    open val plugins: HTMLCollection\n    open val links: HTMLCollection\n    open val forms: HTMLCollection\n    open val scripts: HTMLCollection\n    open val currentScript: HTMLOrSVGScriptElement?\n    open val defaultView: Window?\n    var designMode: String\n    var onreadystatechange: ((Event) -> dynamic)?\n    var fgColor: String\n    var linkColor: String\n    var vlinkColor: String\n    var alinkColor: String\n    var bgColor: String\n    open val anchors: HTMLCollection\n    open val applets: HTMLCollection\n    open val all: HTMLAllCollection\n    open val implementation: DOMImplementation\n    open val URL: String\n    open val documentURI: String\n    open val origin: String\n    open val compatMode: String\n    open val characterSet: String\n    open val charset: String\n    open val inputEncoding: String\n    open val contentType: String\n    open val doctype: DocumentType?\n    open val documentElement: Element?\n    open val scrollingElement: Element?\n    open val styleSheets: StyleSheetList\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override val fullscreenElement: Element?\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    fun exitFullscreen(): Promise<Unit>\n    fun getElementsByName(elementName: String): NodeList\n    fun open(type: String = definedExternally, replace: String = definedExternally): Document\n    fun open(url: String, name: String, features: String): Window\n    fun close(): Unit\n    fun write(vararg text: String): Unit\n    fun writeln(vararg text: String): Unit\n    fun hasFocus(): Boolean\n    fun execCommand(commandId: String, showUI: Boolean = definedExternally, value: String = definedExternally): Boolean\n    fun queryCommandEnabled(commandId: String): Boolean\n    fun queryCommandIndeterm(commandId: String): Boolean\n    fun queryCommandState(commandId: String): Boolean\n    fun queryCommandSupported(commandId: String): Boolean\n    fun queryCommandValue(commandId: String): String\n    fun clear(): Unit\n    fun captureEvents(): Unit\n    fun releaseEvents(): Unit\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun createElement(localName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createDocumentFragment(): DocumentFragment\n    fun createTextNode(data: String): Text\n    fun createCDATASection(data: String): CDATASection\n    fun createComment(data: String): Comment\n    fun createProcessingInstruction(target: String, data: String): ProcessingInstruction\n    fun importNode(node: Node, deep: Boolean = definedExternally): Node\n    fun adoptNode(node: Node): Node\n    fun createAttribute(localName: String): Attr\n    fun createAttributeNS(namespace: String?, qualifiedName: String): Attr\n    fun createEvent(interface_: String): Event\n    fun createRange(): Range\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): NodeIterator\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): NodeIterator\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): TreeWalker\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): TreeWalker\n    fun elementFromPoint(x: Double, y: Double): Element?\n    fun elementsFromPoint(x: Double, y: Double): Array<Element>\n    fun caretPositionFromPoint(x: Double, y: Double): CaretPosition?\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n@kotlin.internal.InlineOnly inline operator fun Document.get(name: String): dynamic = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Window](https://developer.mozilla.org/en/docs/Web/API/Window) to Kotlin\n */\npublic external abstract class Window : EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, WindowSessionStorage, WindowLocalStorage, GlobalPerformance, UnionMessagePortOrWindow {\n    override val performance: Performance\n    open val window: Window\n    open val self: Window\n    open val document: Document\n    open var name: String\n    open val location: Location\n    open val history: History\n    open val customElements: CustomElementRegistry\n    open val locationbar: BarProp\n    open val menubar: BarProp\n    open val personalbar: BarProp\n    open val scrollbars: BarProp\n    open val statusbar: BarProp\n    open val toolbar: BarProp\n    open var status: String\n    open val closed: Boolean\n    open val frames: Window\n    open val length: Int\n    open val top: Window\n    open var opener: Any?\n    open val parent: Window\n    open val frameElement: Element?\n    open val navigator: Navigator\n    open val applicationCache: ApplicationCache\n    open val external: External\n    open val screen: Screen\n    open val innerWidth: Int\n    open val innerHeight: Int\n    open val scrollX: Double\n    open val pageXOffset: Double\n    open val scrollY: Double\n    open val pageYOffset: Double\n    open val screenX: Int\n    open val screenY: Int\n    open val outerWidth: Int\n    open val outerHeight: Int\n    open val devicePixelRatio: Double\n    fun close(): Unit\n    fun stop(): Unit\n    fun focus(): Unit\n    fun blur(): Unit\n    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?\n    fun alert(): Unit\n    fun alert(message: String): Unit\n    fun confirm(message: String = definedExternally): Boolean\n    fun prompt(message: String = definedExternally, default: String = definedExternally): String?\n    fun print(): Unit\n    fun requestAnimationFrame(callback: (Double) -> Unit): Int\n    fun cancelAnimationFrame(handle: Int): Unit\n    fun postMessage(message: Any?, targetOrigin: String, transfer: Array<dynamic> = definedExternally): Unit\n    fun captureEvents(): Unit\n    fun releaseEvents(): Unit\n    fun matchMedia(query: String): MediaQueryList\n    fun moveTo(x: Int, y: Int): Unit\n    fun moveBy(x: Int, y: Int): Unit\n    fun resizeTo(x: Int, y: Int): Unit\n    fun resizeBy(x: Int, y: Int): Unit\n    fun scroll(options: ScrollToOptions = definedExternally): Unit\n    fun scroll(x: Double, y: Double): Unit\n    fun scrollTo(options: ScrollToOptions = definedExternally): Unit\n    fun scrollTo(x: Double, y: Double): Unit\n    fun scrollBy(options: ScrollToOptions = definedExternally): Unit\n    fun scrollBy(x: Double, y: Double): Unit\n    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration\n}\n@kotlin.internal.InlineOnly inline operator fun Window.get(name: String): dynamic = asDynamic()[name]\n\npublic external abstract class HTMLAllCollection {\n    open val length: Int\n//    fun namedItem(name: String): UnionElementOrHTMLCollection?\n    fun item(nameOrIndex: String = definedExternally): UnionElementOrHTMLCollection?\n}\n//@kotlin.internal.InlineOnly inline operator fun HTMLAllCollection.get(index: Int): Element? = asDynamic()[index]\n//@kotlin.internal.InlineOnly inline operator fun HTMLAllCollection.get(name: String): UnionElementOrHTMLCollection? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLFormControlsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLFormControlsCollection) to Kotlin\n */\npublic external abstract class HTMLFormControlsCollection : HTMLCollection {\n//    override fun namedItem(name: String): UnionElementOrRadioNodeList?\n}\n//@kotlin.internal.InlineOnly override inline operator fun HTMLFormControlsCollection.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [RadioNodeList](https://developer.mozilla.org/en/docs/Web/API/RadioNodeList) to Kotlin\n */\npublic external abstract class RadioNodeList : NodeList, UnionElementOrRadioNodeList {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionsCollection) to Kotlin\n */\npublic external abstract class HTMLOptionsCollection : HTMLCollection {\n    override var length: Int\n    open var selectedIndex: Int\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally): Unit\n    fun remove(index: Int): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLOptionsCollection.set(index: Int, option: HTMLOptionElement?): Unit { asDynamic()[index] = option; }\n\n/**\n * Exposes the JavaScript [HTMLElement](https://developer.mozilla.org/en/docs/Web/API/HTMLElement) to Kotlin\n */\npublic external abstract class HTMLElement : Element, ElementCSSInlineStyle, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable {\n    open var title: String\n    open var lang: String\n    open var translate: Boolean\n    open var dir: String\n    open val dataset: DOMStringMap\n    open var hidden: Boolean\n    open var tabIndex: Int\n    open var accessKey: String\n    open val accessKeyLabel: String\n    open var draggable: Boolean\n    open val dropzone: DOMTokenList\n    open var contextMenu: HTMLMenuElement?\n    open var spellcheck: Boolean\n    open var innerText: String\n    open val offsetParent: Element?\n    open val offsetTop: Int\n    open val offsetLeft: Int\n    open val offsetWidth: Int\n    open val offsetHeight: Int\n    fun click(): Unit\n    fun focus(): Unit\n    fun blur(): Unit\n    fun forceSpellCheck(): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLUnknownElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUnknownElement) to Kotlin\n */\npublic external abstract class HTMLUnknownElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [DOMStringMap](https://developer.mozilla.org/en/docs/Web/API/DOMStringMap) to Kotlin\n */\npublic external abstract class DOMStringMap {\n}\n@kotlin.internal.InlineOnly inline operator fun DOMStringMap.get(name: String): String? = asDynamic()[name]\n@kotlin.internal.InlineOnly inline operator fun DOMStringMap.set(name: String, value: String): Unit { asDynamic()[name] = value; }\n\n/**\n * Exposes the JavaScript [HTMLHtmlElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHtmlElement) to Kotlin\n */\npublic external abstract class HTMLHtmlElement : HTMLElement {\n    open var version: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadElement) to Kotlin\n */\npublic external abstract class HTMLHeadElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLTitleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTitleElement) to Kotlin\n */\npublic external abstract class HTMLTitleElement : HTMLElement {\n    open var text: String\n}\n\n/**\n * Exposes the JavaScript [HTMLBaseElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBaseElement) to Kotlin\n */\npublic external abstract class HTMLBaseElement : HTMLElement {\n    open var href: String\n    open var target: String\n}\n\n/**\n * Exposes the JavaScript [HTMLLinkElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLinkElement) to Kotlin\n */\npublic external abstract class HTMLLinkElement : HTMLElement, LinkStyle {\n    open var scope: String\n    open var workerType: WorkerType\n    open var href: String\n    open var crossOrigin: String?\n    open var rel: String\n    @JsName(\"as\") open var as_: RequestDestination\n    open val relList: DOMTokenList\n    open var media: String\n    open var nonce: String\n    open var hreflang: String\n    open var type: String\n    open val sizes: DOMTokenList\n    open var referrerPolicy: String\n    open var charset: String\n    open var rev: String\n    open var target: String\n}\n\n/**\n * Exposes the JavaScript [HTMLMetaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMetaElement) to Kotlin\n */\npublic external abstract class HTMLMetaElement : HTMLElement {\n    open var name: String\n    open var httpEquiv: String\n    open var content: String\n    open var scheme: String\n}\n\n/**\n * Exposes the JavaScript [HTMLStyleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLStyleElement) to Kotlin\n */\npublic external abstract class HTMLStyleElement : HTMLElement, LinkStyle {\n    open var media: String\n    open var nonce: String\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLBodyElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBodyElement) to Kotlin\n */\npublic external abstract class HTMLBodyElement : HTMLElement, WindowEventHandlers {\n    open var text: String\n    open var link: String\n    open var vLink: String\n    open var aLink: String\n    open var bgColor: String\n    open var background: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadingElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadingElement) to Kotlin\n */\npublic external abstract class HTMLHeadingElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLParagraphElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParagraphElement) to Kotlin\n */\npublic external abstract class HTMLParagraphElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHRElement) to Kotlin\n */\npublic external abstract class HTMLHRElement : HTMLElement {\n    open var align: String\n    open var color: String\n    open var noShade: Boolean\n    open var size: String\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLPreElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPreElement) to Kotlin\n */\npublic external abstract class HTMLPreElement : HTMLElement {\n    open var width: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLQuoteElement](https://developer.mozilla.org/en/docs/Web/API/HTMLQuoteElement) to Kotlin\n */\npublic external abstract class HTMLQuoteElement : HTMLElement {\n    open var cite: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOListElement) to Kotlin\n */\npublic external abstract class HTMLOListElement : HTMLElement {\n    open var reversed: Boolean\n    open var start: Int\n    open var type: String\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLUListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUListElement) to Kotlin\n */\npublic external abstract class HTMLUListElement : HTMLElement {\n    open var compact: Boolean\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLLIElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLIElement) to Kotlin\n */\npublic external abstract class HTMLLIElement : HTMLElement {\n    open var value: Int\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLDListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDListElement) to Kotlin\n */\npublic external abstract class HTMLDListElement : HTMLElement {\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDivElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDivElement) to Kotlin\n */\npublic external abstract class HTMLDivElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLAnchorElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAnchorElement) to Kotlin\n */\npublic external abstract class HTMLAnchorElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var hreflang: String\n    open var type: String\n    open var text: String\n    open var referrerPolicy: String\n    open var coords: String\n    open var charset: String\n    open var name: String\n    open var rev: String\n    open var shape: String\n}\n\n/**\n * Exposes the JavaScript [HTMLDataElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataElement) to Kotlin\n */\npublic external abstract class HTMLDataElement : HTMLElement {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTimeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTimeElement) to Kotlin\n */\npublic external abstract class HTMLTimeElement : HTMLElement {\n    open var dateTime: String\n}\n\n/**\n * Exposes the JavaScript [HTMLSpanElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSpanElement) to Kotlin\n */\npublic external abstract class HTMLSpanElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLBRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBRElement) to Kotlin\n */\npublic external abstract class HTMLBRElement : HTMLElement {\n    open var clear: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHyperlinkElementUtils](https://developer.mozilla.org/en/docs/Web/API/HTMLHyperlinkElementUtils) to Kotlin\n */\npublic external interface HTMLHyperlinkElementUtils {\n    var href: String\n    val origin: String\n    var protocol: String\n    var username: String\n    var password: String\n    var host: String\n    var hostname: String\n    var port: String\n    var pathname: String\n    var search: String\n    var hash: String\n}\n\n/**\n * Exposes the JavaScript [HTMLModElement](https://developer.mozilla.org/en/docs/Web/API/HTMLModElement) to Kotlin\n */\npublic external abstract class HTMLModElement : HTMLElement {\n    open var cite: String\n    open var dateTime: String\n}\n\n/**\n * Exposes the JavaScript [HTMLPictureElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPictureElement) to Kotlin\n */\npublic external abstract class HTMLPictureElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLSourceElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSourceElement) to Kotlin\n */\npublic external abstract class HTMLSourceElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var srcset: String\n    open var sizes: String\n    open var media: String\n}\n\n/**\n * Exposes the JavaScript [HTMLImageElement](https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement) to Kotlin\n */\npublic external abstract class HTMLImageElement : HTMLElement, TexImageSource, HTMLOrSVGImageElement {\n    open var alt: String\n    open var src: String\n    open var srcset: String\n    open var sizes: String\n    open var crossOrigin: String?\n    open var useMap: String\n    open var isMap: Boolean\n    open var width: Int\n    open var height: Int\n    open val naturalWidth: Int\n    open val naturalHeight: Int\n    open val complete: Boolean\n    open val currentSrc: String\n    open var referrerPolicy: String\n    open var name: String\n    open var lowsrc: String\n    open var align: String\n    open var hspace: Int\n    open var vspace: Int\n    open var longDesc: String\n    open var border: String\n    open val x: Int\n    open val y: Int\n}\n\n/**\n * Exposes the JavaScript [Image](https://developer.mozilla.org/en/docs/Web/API/Image) to Kotlin\n */\npublic external open class Image(width: Int = definedExternally, height: Int = definedExternally) : HTMLImageElement {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override val style: CSSStyleDeclaration\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [HTMLIFrameElement](https://developer.mozilla.org/en/docs/Web/API/HTMLIFrameElement) to Kotlin\n */\npublic external abstract class HTMLIFrameElement : HTMLElement {\n    open var src: String\n    open var srcdoc: String\n    open var name: String\n    open val sandbox: DOMTokenList\n    open var allowFullscreen: Boolean\n    open var allowUserMedia: Boolean\n    open var width: String\n    open var height: String\n    open var referrerPolicy: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var align: String\n    open var scrolling: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var marginHeight: String\n    open var marginWidth: String\n    fun getSVGDocument(): Document?\n}\n\n/**\n * Exposes the JavaScript [HTMLEmbedElement](https://developer.mozilla.org/en/docs/Web/API/HTMLEmbedElement) to Kotlin\n */\npublic external abstract class HTMLEmbedElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var width: String\n    open var height: String\n    open var align: String\n    open var name: String\n    fun getSVGDocument(): Document?\n}\n\n/**\n * Exposes the JavaScript [HTMLObjectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLObjectElement) to Kotlin\n */\npublic external abstract class HTMLObjectElement : HTMLElement {\n    open var data: String\n    open var type: String\n    open var typeMustMatch: Boolean\n    open var name: String\n    open var useMap: String\n    open val form: HTMLFormElement?\n    open var width: String\n    open var height: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open var align: String\n    open var archive: String\n    open var code: String\n    open var declare: Boolean\n    open var hspace: Int\n    open var standby: String\n    open var vspace: Int\n    open var codeBase: String\n    open var codeType: String\n    open var border: String\n    fun getSVGDocument(): Document?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLParamElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParamElement) to Kotlin\n */\npublic external abstract class HTMLParamElement : HTMLElement {\n    open var name: String\n    open var value: String\n    open var type: String\n    open var valueType: String\n}\n\n/**\n * Exposes the JavaScript [HTMLVideoElement](https://developer.mozilla.org/en/docs/Web/API/HTMLVideoElement) to Kotlin\n */\npublic external abstract class HTMLVideoElement : HTMLMediaElement, TexImageSource {\n    open var width: Int\n    open var height: Int\n    open val videoWidth: Int\n    open val videoHeight: Int\n    open var poster: String\n    open var playsInline: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLAudioElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAudioElement) to Kotlin\n */\npublic external abstract class HTMLAudioElement : HTMLMediaElement {\n}\n\npublic external open class Audio(src: String = definedExternally) : HTMLAudioElement {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override val style: CSSStyleDeclaration\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [HTMLTrackElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTrackElement) to Kotlin\n */\npublic external abstract class HTMLTrackElement : HTMLElement {\n    open var kind: String\n    open var src: String\n    open var srclang: String\n    open var label: String\n    open var default: Boolean\n    open val readyState: Short\n    open val track: TextTrack\n\n    companion object {\n        val NONE: Short\n        val LOADING: Short\n        val LOADED: Short\n        val ERROR: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMediaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMediaElement) to Kotlin\n */\npublic external abstract class HTMLMediaElement : HTMLElement {\n    open val error: MediaError?\n    open var src: String\n    open var srcObject: dynamic\n    open val currentSrc: String\n    open var crossOrigin: String?\n    open val networkState: Short\n    open var preload: String\n    open val buffered: TimeRanges\n    open val readyState: Short\n    open val seeking: Boolean\n    open var currentTime: Double\n    open val duration: Double\n    open val paused: Boolean\n    open var defaultPlaybackRate: Double\n    open var playbackRate: Double\n    open val played: TimeRanges\n    open val seekable: TimeRanges\n    open val ended: Boolean\n    open var autoplay: Boolean\n    open var loop: Boolean\n    open var controls: Boolean\n    open var volume: Double\n    open var muted: Boolean\n    open var defaultMuted: Boolean\n    open val audioTracks: AudioTrackList\n    open val videoTracks: VideoTrackList\n    open val textTracks: TextTrackList\n    fun load(): Unit\n    fun canPlayType(type: String): CanPlayTypeResult\n    fun fastSeek(time: Double): Unit\n    fun getStartDate(): dynamic\n    fun play(): Promise<Unit>\n    fun pause(): Unit\n    fun addTextTrack(kind: TextTrackKind, label: String = definedExternally, language: String = definedExternally): TextTrack\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [MediaError](https://developer.mozilla.org/en/docs/Web/API/MediaError) to Kotlin\n */\npublic external abstract class MediaError {\n    open val code: Short\n\n    companion object {\n        val MEDIA_ERR_ABORTED: Short\n        val MEDIA_ERR_NETWORK: Short\n        val MEDIA_ERR_DECODE: Short\n        val MEDIA_ERR_SRC_NOT_SUPPORTED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [AudioTrackList](https://developer.mozilla.org/en/docs/Web/API/AudioTrackList) to Kotlin\n */\npublic external abstract class AudioTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): AudioTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun AudioTrackList.get(index: Int): AudioTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [AudioTrack](https://developer.mozilla.org/en/docs/Web/API/AudioTrack) to Kotlin\n */\npublic external abstract class AudioTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var enabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [VideoTrackList](https://developer.mozilla.org/en/docs/Web/API/VideoTrackList) to Kotlin\n */\npublic external abstract class VideoTrackList : EventTarget {\n    open val length: Int\n    open val selectedIndex: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): VideoTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun VideoTrackList.get(index: Int): VideoTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [VideoTrack](https://developer.mozilla.org/en/docs/Web/API/VideoTrack) to Kotlin\n */\npublic external abstract class VideoTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var selected: Boolean\n}\n\npublic external abstract class TextTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): TextTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun TextTrackList.get(index: Int): TextTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrack](https://developer.mozilla.org/en/docs/Web/API/TextTrack) to Kotlin\n */\npublic external abstract class TextTrack : EventTarget, UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val kind: TextTrackKind\n    open val label: String\n    open val language: String\n    open val id: String\n    open val inBandMetadataTrackDispatchType: String\n    open var mode: TextTrackMode\n    open val cues: TextTrackCueList?\n    open val activeCues: TextTrackCueList?\n    open var oncuechange: ((Event) -> dynamic)?\n    fun addCue(cue: TextTrackCue): Unit\n    fun removeCue(cue: TextTrackCue): Unit\n}\n\npublic external abstract class TextTrackCueList {\n    open val length: Int\n    fun getCueById(id: String): TextTrackCue?\n}\n@kotlin.internal.InlineOnly inline operator fun TextTrackCueList.get(index: Int): TextTrackCue? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrackCue](https://developer.mozilla.org/en/docs/Web/API/TextTrackCue) to Kotlin\n */\npublic external abstract class TextTrackCue : EventTarget {\n    open val track: TextTrack?\n    open var id: String\n    open var startTime: Double\n    open var endTime: Double\n    open var pauseOnExit: Boolean\n    open var onenter: ((Event) -> dynamic)?\n    open var onexit: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin\n */\npublic external abstract class TimeRanges {\n    open val length: Int\n    fun start(index: Int): Double\n    fun end(index: Int): Double\n}\n\n/**\n * Exposes the JavaScript [TrackEvent](https://developer.mozilla.org/en/docs/Web/API/TrackEvent) to Kotlin\n */\npublic external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event {\n    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?\n}\n\npublic external interface TrackEventInit : EventInit {\n    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit {\n    val o = js(\"({})\")\n\n    o[\"track\"] = track\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin\n */\npublic external abstract class HTMLMapElement : HTMLElement {\n    open var name: String\n    open val areas: HTMLCollection\n}\n\n/**\n * Exposes the JavaScript [HTMLAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAreaElement) to Kotlin\n */\npublic external abstract class HTMLAreaElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var alt: String\n    open var coords: String\n    open var shape: String\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var referrerPolicy: String\n    open var noHref: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLTableElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableElement) to Kotlin\n */\npublic external abstract class HTMLTableElement : HTMLElement {\n    open var caption: HTMLTableCaptionElement?\n    open var tHead: HTMLTableSectionElement?\n    open var tFoot: HTMLTableSectionElement?\n    open val tBodies: HTMLCollection\n    open val rows: HTMLCollection\n    open var align: String\n    open var border: String\n    open var frame: String\n    open var rules: String\n    open var summary: String\n    open var width: String\n    open var bgColor: String\n    open var cellPadding: String\n    open var cellSpacing: String\n    fun createCaption(): HTMLTableCaptionElement\n    fun deleteCaption(): Unit\n    fun createTHead(): HTMLTableSectionElement\n    fun deleteTHead(): Unit\n    fun createTFoot(): HTMLTableSectionElement\n    fun deleteTFoot(): Unit\n    fun createTBody(): HTMLTableSectionElement\n    fun insertRow(index: Int = definedExternally): HTMLTableRowElement\n    fun deleteRow(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCaptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCaptionElement) to Kotlin\n */\npublic external abstract class HTMLTableCaptionElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTableColElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableColElement) to Kotlin\n */\npublic external abstract class HTMLTableColElement : HTMLElement {\n    open var span: Int\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTableSectionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableSectionElement) to Kotlin\n */\npublic external abstract class HTMLTableSectionElement : HTMLElement {\n    open val rows: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    fun insertRow(index: Int = definedExternally): HTMLElement\n    fun deleteRow(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableRowElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableRowElement) to Kotlin\n */\npublic external abstract class HTMLTableRowElement : HTMLElement {\n    open val rowIndex: Int\n    open val sectionRowIndex: Int\n    open val cells: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var bgColor: String\n    fun insertCell(index: Int = definedExternally): HTMLElement\n    fun deleteCell(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCellElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCellElement) to Kotlin\n */\npublic external abstract class HTMLTableCellElement : HTMLElement {\n    open var colSpan: Int\n    open var rowSpan: Int\n    open var headers: String\n    open val cellIndex: Int\n    open var scope: String\n    open var abbr: String\n    open var align: String\n    open var axis: String\n    open var height: String\n    open var width: String\n    open var ch: String\n    open var chOff: String\n    open var noWrap: Boolean\n    open var vAlign: String\n    open var bgColor: String\n}\n\n/**\n * Exposes the JavaScript [HTMLFormElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFormElement) to Kotlin\n */\npublic external abstract class HTMLFormElement : HTMLElement {\n    open var acceptCharset: String\n    open var action: String\n    open var autocomplete: String\n    open var enctype: String\n    open var encoding: String\n    open var method: String\n    open var name: String\n    open var noValidate: Boolean\n    open var target: String\n    open val elements: HTMLFormControlsCollection\n    open val length: Int\n    fun submit(): Unit\n    fun reset(): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLFormElement.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLFormElement.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLLabelElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLabelElement) to Kotlin\n */\npublic external abstract class HTMLLabelElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var htmlFor: String\n    open val control: HTMLElement?\n}\n\n/**\n * Exposes the JavaScript [HTMLInputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement) to Kotlin\n */\npublic external abstract class HTMLInputElement : HTMLElement {\n    open var accept: String\n    open var alt: String\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var defaultChecked: Boolean\n    open var checked: Boolean\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open val files: FileList?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var height: Int\n    open var indeterminate: Boolean\n    open var inputMode: String\n    open val list: HTMLElement?\n    open var max: String\n    open var maxLength: Int\n    open var min: String\n    open var minLength: Int\n    open var multiple: Boolean\n    open var name: String\n    open var pattern: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var size: Int\n    open var src: String\n    open var step: String\n    open var type: String\n    open var defaultValue: String\n    open var value: String\n    open var valueAsDate: dynamic\n    open var valueAsNumber: Double\n    open var width: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    open var align: String\n    open var useMap: String\n    fun stepUp(n: Int = definedExternally): Unit\n    fun stepDown(n: Int = definedExternally): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n    fun select(): Unit\n    fun setRangeText(replacement: String): Unit\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally): Unit\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLButtonElement](https://developer.mozilla.org/en/docs/Web/API/HTMLButtonElement) to Kotlin\n */\npublic external abstract class HTMLButtonElement : HTMLElement {\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var name: String\n    open var type: String\n    open var value: String\n    open var menu: HTMLMenuElement?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLSelectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSelectElement) to Kotlin\n */\npublic external abstract class HTMLSelectElement : HTMLElement, ItemArrayLike<Element> {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var multiple: Boolean\n    open var name: String\n    open var required: Boolean\n    open var size: Int\n    open val type: String\n    open val options: HTMLOptionsCollection\n    override var length: Int\n    open val selectedOptions: HTMLCollection\n    open var selectedIndex: Int\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): HTMLOptionElement?\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally): Unit\n    fun remove(index: Int): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLSelectElement.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLSelectElement.set(index: Int, option: HTMLOptionElement?): Unit { asDynamic()[index] = option; }\n\n/**\n * Exposes the JavaScript [HTMLDataListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataListElement) to Kotlin\n */\npublic external abstract class HTMLDataListElement : HTMLElement {\n    open val options: HTMLCollection\n}\n\n/**\n * Exposes the JavaScript [HTMLOptGroupElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptGroupElement) to Kotlin\n */\npublic external abstract class HTMLOptGroupElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open var label: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionElement) to Kotlin\n */\npublic external abstract class HTMLOptionElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var label: String\n    open var defaultSelected: Boolean\n    open var selected: Boolean\n    open var value: String\n    open var text: String\n    open val index: Int\n}\n\n/**\n * Exposes the JavaScript [Option](https://developer.mozilla.org/en/docs/Web/API/Option) to Kotlin\n */\npublic external open class Option(text: String = definedExternally, value: String = definedExternally, defaultSelected: Boolean = definedExternally, selected: Boolean = definedExternally) : HTMLOptionElement {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override val style: CSSStyleDeclaration\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [HTMLTextAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTextAreaElement) to Kotlin\n */\npublic external abstract class HTMLTextAreaElement : HTMLElement {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var cols: Int\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var inputMode: String\n    open var maxLength: Int\n    open var minLength: Int\n    open var name: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var rows: Int\n    open var wrap: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val textLength: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n    fun select(): Unit\n    fun setRangeText(replacement: String): Unit\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally): Unit\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLKeygenElement](https://developer.mozilla.org/en/docs/Web/API/HTMLKeygenElement) to Kotlin\n */\npublic external abstract class HTMLKeygenElement : HTMLElement {\n    open var autofocus: Boolean\n    open var challenge: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var keytype: String\n    open var name: String\n    open val type: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLOutputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOutputElement) to Kotlin\n */\npublic external abstract class HTMLOutputElement : HTMLElement {\n    open val htmlFor: DOMTokenList\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLProgressElement](https://developer.mozilla.org/en/docs/Web/API/HTMLProgressElement) to Kotlin\n */\npublic external abstract class HTMLProgressElement : HTMLElement {\n    open var value: Double\n    open var max: Double\n    open val position: Double\n    open val labels: NodeList\n}\n\n/**\n * Exposes the JavaScript [HTMLMeterElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMeterElement) to Kotlin\n */\npublic external abstract class HTMLMeterElement : HTMLElement {\n    open var value: Double\n    open var min: Double\n    open var max: Double\n    open var low: Double\n    open var high: Double\n    open var optimum: Double\n    open val labels: NodeList\n}\n\n/**\n * Exposes the JavaScript [HTMLFieldSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFieldSetElement) to Kotlin\n */\npublic external abstract class HTMLFieldSetElement : HTMLElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open val elements: HTMLCollection\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLLegendElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLegendElement) to Kotlin\n */\npublic external abstract class HTMLLegendElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [ValidityState](https://developer.mozilla.org/en/docs/Web/API/ValidityState) to Kotlin\n */\npublic external abstract class ValidityState {\n    open val valueMissing: Boolean\n    open val typeMismatch: Boolean\n    open val patternMismatch: Boolean\n    open val tooLong: Boolean\n    open val tooShort: Boolean\n    open val rangeUnderflow: Boolean\n    open val rangeOverflow: Boolean\n    open val stepMismatch: Boolean\n    open val badInput: Boolean\n    open val customError: Boolean\n    open val valid: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDetailsElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDetailsElement) to Kotlin\n */\npublic external abstract class HTMLDetailsElement : HTMLElement {\n    open var open: Boolean\n}\n\npublic external abstract class HTMLMenuElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var compact: Boolean\n}\n\npublic external abstract class HTMLMenuItemElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var icon: String\n    open var disabled: Boolean\n    open var checked: Boolean\n    open var radiogroup: String\n    open var default: Boolean\n}\n\npublic external open class RelatedEvent(type: String, eventInitDict: RelatedEventInit = definedExternally) : Event {\n    open val relatedTarget: EventTarget?\n}\n\npublic external interface RelatedEventInit : EventInit {\n    var relatedTarget: EventTarget? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RelatedEventInit(relatedTarget: EventTarget? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): RelatedEventInit {\n    val o = js(\"({})\")\n\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLDialogElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDialogElement) to Kotlin\n */\npublic external abstract class HTMLDialogElement : HTMLElement {\n    open var open: Boolean\n    open var returnValue: String\n    fun show(anchor: UnionElementOrMouseEvent = definedExternally): Unit\n    fun showModal(anchor: UnionElementOrMouseEvent = definedExternally): Unit\n    fun close(returnValue: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLScriptElement](https://developer.mozilla.org/en/docs/Web/API/HTMLScriptElement) to Kotlin\n */\npublic external abstract class HTMLScriptElement : HTMLElement, HTMLOrSVGScriptElement {\n    open var src: String\n    open var type: String\n    open var charset: String\n    open var async: Boolean\n    open var defer: Boolean\n    open var crossOrigin: String?\n    open var text: String\n    open var nonce: String\n    open var event: String\n    open var htmlFor: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTemplateElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTemplateElement) to Kotlin\n */\npublic external abstract class HTMLTemplateElement : HTMLElement {\n    open val content: DocumentFragment\n}\n\n/**\n * Exposes the JavaScript [HTMLSlotElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSlotElement) to Kotlin\n */\npublic external abstract class HTMLSlotElement : HTMLElement {\n    open var name: String\n    fun assignedNodes(options: AssignedNodesOptions = definedExternally): Array<Node>\n}\n\npublic external interface AssignedNodesOptions {\n    var flatten: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AssignedNodesOptions(flatten: Boolean? = false): AssignedNodesOptions {\n    val o = js(\"({})\")\n\n    o[\"flatten\"] = flatten\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLCanvasElement](https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement) to Kotlin\n */\npublic external abstract class HTMLCanvasElement : HTMLElement, TexImageSource {\n    open var width: Int\n    open var height: Int\n    fun getContext(contextId: String, vararg arguments: Any?): RenderingContext?\n    fun toDataURL(type: String = definedExternally, quality: Any? = definedExternally): String\n    fun toBlob(_callback: (Blob?) -> Unit, type: String = definedExternally, quality: Any? = definedExternally): Unit\n}\n\npublic external interface CanvasRenderingContext2DSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CanvasRenderingContext2DSettings(alpha: Boolean? = true): CanvasRenderingContext2DSettings {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CanvasRenderingContext2D](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D) to Kotlin\n */\npublic external abstract class CanvasRenderingContext2D : CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasHitRegion, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath, RenderingContext {\n    open val canvas: HTMLCanvasElement\n}\n\npublic external interface CanvasState {\n    fun save(): Unit\n    fun restore(): Unit\n}\n\npublic external interface CanvasTransform {\n    fun scale(x: Double, y: Double): Unit\n    fun rotate(angle: Double): Unit\n    fun translate(x: Double, y: Double): Unit\n    fun transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double): Unit\n    fun getTransform(): DOMMatrix\n    fun setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double): Unit\n    fun setTransform(transform: dynamic = definedExternally): Unit\n    fun resetTransform(): Unit\n}\n\npublic external interface CanvasCompositing {\n    var globalAlpha: Double\n    var globalCompositeOperation: String\n}\n\npublic external interface CanvasImageSmoothing {\n    var imageSmoothingEnabled: Boolean\n    var imageSmoothingQuality: ImageSmoothingQuality\n}\n\npublic external interface CanvasFillStrokeStyles {\n    var strokeStyle: dynamic\n    var fillStyle: dynamic\n    fun createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double): CanvasGradient\n    fun createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double): CanvasGradient\n    fun createPattern(image: dynamic, repetition: String): CanvasPattern?\n}\n\npublic external interface CanvasShadowStyles {\n    var shadowOffsetX: Double\n    var shadowOffsetY: Double\n    var shadowBlur: Double\n    var shadowColor: String\n}\n\npublic external interface CanvasFilters {\n    var filter: String\n}\n\npublic external interface CanvasRect {\n    fun clearRect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun fillRect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun strokeRect(x: Double, y: Double, w: Double, h: Double): Unit\n}\n\npublic external interface CanvasDrawPath {\n    fun beginPath(): Unit\n    fun fill(fillRule: CanvasFillRule = definedExternally): Unit\n    fun fill(path: Path2D, fillRule: CanvasFillRule = definedExternally): Unit\n    fun stroke(): Unit\n    fun stroke(path: Path2D): Unit\n    fun clip(fillRule: CanvasFillRule = definedExternally): Unit\n    fun clip(path: Path2D, fillRule: CanvasFillRule = definedExternally): Unit\n    fun resetClip(): Unit\n    fun isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInStroke(x: Double, y: Double): Boolean\n    fun isPointInStroke(path: Path2D, x: Double, y: Double): Boolean\n}\n\npublic external interface CanvasUserInterface {\n    fun drawFocusIfNeeded(element: Element): Unit\n    fun drawFocusIfNeeded(path: Path2D, element: Element): Unit\n    fun scrollPathIntoView(): Unit\n    fun scrollPathIntoView(path: Path2D): Unit\n}\n\npublic external interface CanvasText {\n    fun fillText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally): Unit\n    fun strokeText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally): Unit\n    fun measureText(text: String): TextMetrics\n}\n\npublic external interface CanvasDrawImage {\n    fun drawImage(image: dynamic, dx: Double, dy: Double): Unit\n    fun drawImage(image: dynamic, dx: Double, dy: Double, dw: Double, dh: Double): Unit\n    fun drawImage(image: dynamic, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double): Unit\n}\n\npublic external interface CanvasHitRegion {\n    fun addHitRegion(options: HitRegionOptions = definedExternally): Unit\n    fun removeHitRegion(id: String): Unit\n    fun clearHitRegions(): Unit\n}\n\npublic external interface CanvasImageData {\n    fun createImageData(sw: Double, sh: Double): ImageData\n    fun createImageData(imagedata: ImageData): ImageData\n    fun getImageData(sx: Double, sy: Double, sw: Double, sh: Double): ImageData\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double): Unit\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double, dirtyX: Double, dirtyY: Double, dirtyWidth: Double, dirtyHeight: Double): Unit\n}\n\npublic external interface CanvasPathDrawingStyles {\n    var lineWidth: Double\n    var lineCap: CanvasLineCap\n    var lineJoin: CanvasLineJoin\n    var miterLimit: Double\n    var lineDashOffset: Double\n    fun setLineDash(segments: Array<Double>): Unit\n    fun getLineDash(): Array<Double>\n}\n\npublic external interface CanvasTextDrawingStyles {\n    var font: String\n    var textAlign: CanvasTextAlign\n    var textBaseline: CanvasTextBaseline\n    var direction: CanvasDirection\n}\n\npublic external interface CanvasPath {\n    fun closePath(): Unit\n    fun moveTo(x: Double, y: Double): Unit\n    fun lineTo(x: Double, y: Double): Unit\n    fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double): Unit\n    fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double): Unit\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double): Unit\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double): Unit\n    fun rect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally): Unit\n    fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [CanvasGradient](https://developer.mozilla.org/en/docs/Web/API/CanvasGradient) to Kotlin\n */\npublic external abstract class CanvasGradient {\n    fun addColorStop(offset: Double, color: String): Unit\n}\n\n/**\n * Exposes the JavaScript [CanvasPattern](https://developer.mozilla.org/en/docs/Web/API/CanvasPattern) to Kotlin\n */\npublic external abstract class CanvasPattern {\n    fun setTransform(transform: dynamic = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [TextMetrics](https://developer.mozilla.org/en/docs/Web/API/TextMetrics) to Kotlin\n */\npublic external abstract class TextMetrics {\n    open val width: Double\n    open val actualBoundingBoxLeft: Double\n    open val actualBoundingBoxRight: Double\n    open val fontBoundingBoxAscent: Double\n    open val fontBoundingBoxDescent: Double\n    open val actualBoundingBoxAscent: Double\n    open val actualBoundingBoxDescent: Double\n    open val emHeightAscent: Double\n    open val emHeightDescent: Double\n    open val hangingBaseline: Double\n    open val alphabeticBaseline: Double\n    open val ideographicBaseline: Double\n}\n\npublic external interface HitRegionOptions {\n    var path: Path2D? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillRule: CanvasFillRule? /* = CanvasFillRule.NONZERO */\n        get() = definedExternally\n        set(value) = definedExternally\n    var id: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var parentID: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cursor: String? /* = \"inherit\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var control: Element? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var label: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var role: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HitRegionOptions(path: Path2D? = null, fillRule: CanvasFillRule? = CanvasFillRule.NONZERO, id: String? = \"\", parentID: String? = null, cursor: String? = \"inherit\", control: Element? = null, label: String? = null, role: String? = null): HitRegionOptions {\n    val o = js(\"({})\")\n\n    o[\"path\"] = path\n    o[\"fillRule\"] = fillRule\n    o[\"id\"] = id\n    o[\"parentID\"] = parentID\n    o[\"cursor\"] = cursor\n    o[\"control\"] = control\n    o[\"label\"] = label\n    o[\"role\"] = role\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ImageData](https://developer.mozilla.org/en/docs/Web/API/ImageData) to Kotlin\n */\npublic external open class ImageData : TexImageSource {\n    constructor(sw: Int, sh: Int)\n    constructor(data: Uint8ClampedArray, sw: Int, sh: Int = definedExternally)\n    open val width: Int\n    open val height: Int\n    open val data: Uint8ClampedArray\n}\n\n/**\n * Exposes the JavaScript [Path2D](https://developer.mozilla.org/en/docs/Web/API/Path2D) to Kotlin\n */\npublic external open class Path2D() : CanvasPath {\n    constructor(path: Path2D)\n    constructor(paths: Array<Path2D>, fillRule: CanvasFillRule = definedExternally)\n    constructor(d: String)\n    fun addPath(path: Path2D, transform: dynamic = definedExternally): Unit\n    override fun closePath(): Unit\n    override fun moveTo(x: Double, y: Double): Unit\n    override fun lineTo(x: Double, y: Double): Unit\n    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double): Unit\n    override fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double): Unit\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double): Unit\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double): Unit\n    override fun rect(x: Double, y: Double, w: Double, h: Double): Unit\n    override fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */): Unit\n    override fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */): Unit\n}\n\n/**\n * Exposes the JavaScript [Touch](https://developer.mozilla.org/en/docs/Web/API/Touch) to Kotlin\n */\npublic external abstract class Touch {\n    open val region: String?\n}\n\n/**\n * Exposes the JavaScript [ImageBitmapRenderingContext](https://developer.mozilla.org/en/docs/Web/API/ImageBitmapRenderingContext) to Kotlin\n */\npublic external abstract class ImageBitmapRenderingContext {\n    open val canvas: HTMLCanvasElement\n    fun transferFromImageBitmap(bitmap: ImageBitmap?): Unit\n}\n\npublic external interface ImageBitmapRenderingContextSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapRenderingContextSettings(alpha: Boolean? = true): ImageBitmapRenderingContextSettings {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomElementRegistry](https://developer.mozilla.org/en/docs/Web/API/CustomElementRegistry) to Kotlin\n */\npublic external abstract class CustomElementRegistry {\n    fun define(name: String, constructor: () -> dynamic, options: ElementDefinitionOptions = definedExternally): Unit\n    fun get(name: String): Any?\n    fun whenDefined(name: String): Promise<Unit>\n}\n\npublic external interface ElementDefinitionOptions {\n    var extends: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementDefinitionOptions(extends: String? = undefined): ElementDefinitionOptions {\n    val o = js(\"({})\")\n\n    o[\"extends\"] = extends\n\n    return o\n}\n\npublic external interface ElementContentEditable {\n    var contentEditable: String\n    val isContentEditable: Boolean\n}\n\n/**\n * Exposes the JavaScript [DataTransfer](https://developer.mozilla.org/en/docs/Web/API/DataTransfer) to Kotlin\n */\npublic external abstract class DataTransfer {\n    open var dropEffect: String\n    open var effectAllowed: String\n    open val items: DataTransferItemList\n    open val types: Array<out String>\n    open val files: FileList\n    fun setDragImage(image: Element, x: Int, y: Int): Unit\n    fun getData(format: String): String\n    fun setData(format: String, data: String): Unit\n    fun clearData(format: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [DataTransferItemList](https://developer.mozilla.org/en/docs/Web/API/DataTransferItemList) to Kotlin\n */\npublic external abstract class DataTransferItemList {\n    open val length: Int\n    fun add(data: String, type: String): DataTransferItem?\n    fun add(data: File): DataTransferItem?\n    fun remove(index: Int): Unit\n    fun clear(): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun DataTransferItemList.get(index: Int): DataTransferItem? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DataTransferItem](https://developer.mozilla.org/en/docs/Web/API/DataTransferItem) to Kotlin\n */\npublic external abstract class DataTransferItem {\n    open val kind: String\n    open val type: String\n    fun getAsString(_callback: ((String) -> Unit)?): Unit\n    fun getAsFile(): File?\n}\n\n/**\n * Exposes the JavaScript [DragEvent](https://developer.mozilla.org/en/docs/Web/API/DragEvent) to Kotlin\n */\npublic external open class DragEvent(type: String, eventInitDict: DragEventInit = definedExternally) : MouseEvent {\n    open val dataTransfer: DataTransfer?\n}\n\npublic external interface DragEventInit : MouseEventInit {\n    var dataTransfer: DataTransfer? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DragEventInit(dataTransfer: DataTransfer? = null, screenX: Int? = 0, screenY: Int? = 0, clientX: Int? = 0, clientY: Int? = 0, button: Short? = 0, buttons: Short? = 0, relatedTarget: EventTarget? = null, ctrlKey: Boolean? = false, shiftKey: Boolean? = false, altKey: Boolean? = false, metaKey: Boolean? = false, modifierAltGraph: Boolean? = false, modifierCapsLock: Boolean? = false, modifierFn: Boolean? = false, modifierFnLock: Boolean? = false, modifierHyper: Boolean? = false, modifierNumLock: Boolean? = false, modifierScrollLock: Boolean? = false, modifierSuper: Boolean? = false, modifierSymbol: Boolean? = false, modifierSymbolLock: Boolean? = false, view: Window? = null, detail: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): DragEventInit {\n    val o = js(\"({})\")\n\n    o[\"dataTransfer\"] = dataTransfer\n    o[\"screenX\"] = screenX\n    o[\"screenY\"] = screenY\n    o[\"clientX\"] = clientX\n    o[\"clientY\"] = clientY\n    o[\"button\"] = button\n    o[\"buttons\"] = buttons\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"ctrlKey\"] = ctrlKey\n    o[\"shiftKey\"] = shiftKey\n    o[\"altKey\"] = altKey\n    o[\"metaKey\"] = metaKey\n    o[\"modifierAltGraph\"] = modifierAltGraph\n    o[\"modifierCapsLock\"] = modifierCapsLock\n    o[\"modifierFn\"] = modifierFn\n    o[\"modifierFnLock\"] = modifierFnLock\n    o[\"modifierHyper\"] = modifierHyper\n    o[\"modifierNumLock\"] = modifierNumLock\n    o[\"modifierScrollLock\"] = modifierScrollLock\n    o[\"modifierSuper\"] = modifierSuper\n    o[\"modifierSymbol\"] = modifierSymbol\n    o[\"modifierSymbolLock\"] = modifierSymbolLock\n    o[\"view\"] = view\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external abstract class BarProp {\n    open val visible: Boolean\n}\n\n/**\n * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin\n */\npublic external abstract class History {\n    open val length: Int\n    open var scrollRestoration: ScrollRestoration\n    open val state: Any?\n    fun go(delta: Int = definedExternally): Unit\n    fun back(): Unit\n    fun forward(): Unit\n    fun pushState(data: Any?, title: String, url: String? = definedExternally): Unit\n    fun replaceState(data: Any?, title: String, url: String? = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin\n */\npublic external abstract class Location {\n    open var href: String\n    open val origin: String\n    open var protocol: String\n    open var host: String\n    open var hostname: String\n    open var port: String\n    open var pathname: String\n    open var search: String\n    open var hash: String\n    open val ancestorOrigins: Array<out String>\n    fun assign(url: String): Unit\n    fun replace(url: String): Unit\n    fun reload(): Unit\n}\n\n/**\n * Exposes the JavaScript [PopStateEvent](https://developer.mozilla.org/en/docs/Web/API/PopStateEvent) to Kotlin\n */\npublic external open class PopStateEvent(type: String, eventInitDict: PopStateEventInit = definedExternally) : Event {\n    open val state: Any?\n}\n\npublic external interface PopStateEventInit : EventInit {\n    var state: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PopStateEventInit(state: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PopStateEventInit {\n    val o = js(\"({})\")\n\n    o[\"state\"] = state\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HashChangeEvent](https://developer.mozilla.org/en/docs/Web/API/HashChangeEvent) to Kotlin\n */\npublic external open class HashChangeEvent(type: String, eventInitDict: HashChangeEventInit = definedExternally) : Event {\n    open val oldURL: String\n    open val newURL: String\n}\n\npublic external interface HashChangeEventInit : EventInit {\n    var oldURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HashChangeEventInit(oldURL: String? = \"\", newURL: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): HashChangeEventInit {\n    val o = js(\"({})\")\n\n    o[\"oldURL\"] = oldURL\n    o[\"newURL\"] = newURL\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [PageTransitionEvent](https://developer.mozilla.org/en/docs/Web/API/PageTransitionEvent) to Kotlin\n */\npublic external open class PageTransitionEvent(type: String, eventInitDict: PageTransitionEventInit = definedExternally) : Event {\n    open val persisted: Boolean\n}\n\npublic external interface PageTransitionEventInit : EventInit {\n    var persisted: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PageTransitionEventInit(persisted: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PageTransitionEventInit {\n    val o = js(\"({})\")\n\n    o[\"persisted\"] = persisted\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [BeforeUnloadEvent](https://developer.mozilla.org/en/docs/Web/API/BeforeUnloadEvent) to Kotlin\n */\npublic external open class BeforeUnloadEvent : Event {\n    var returnValue: String\n}\n\npublic external abstract class ApplicationCache : EventTarget {\n    open val status: Short\n    open var onchecking: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onnoupdate: ((Event) -> dynamic)?\n    open var ondownloading: ((Event) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onupdateready: ((Event) -> dynamic)?\n    open var oncached: ((Event) -> dynamic)?\n    open var onobsolete: ((Event) -> dynamic)?\n    fun update(): Unit\n    fun abort(): Unit\n    fun swapCache(): Unit\n\n    companion object {\n        val UNCACHED: Short\n        val IDLE: Short\n        val CHECKING: Short\n        val DOWNLOADING: Short\n        val UPDATEREADY: Short\n        val OBSOLETE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NavigatorOnLine](https://developer.mozilla.org/en/docs/Web/API/NavigatorOnLine) to Kotlin\n */\npublic external interface NavigatorOnLine {\n    val onLine: Boolean\n}\n\n/**\n * Exposes the JavaScript [ErrorEvent](https://developer.mozilla.org/en/docs/Web/API/ErrorEvent) to Kotlin\n */\npublic external open class ErrorEvent(type: String, eventInitDict: ErrorEventInit = definedExternally) : Event {\n    open val message: String\n    open val filename: String\n    open val lineno: Int\n    open val colno: Int\n    open val error: Any?\n}\n\npublic external interface ErrorEventInit : EventInit {\n    var message: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var filename: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lineno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var error: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ErrorEventInit(message: String? = \"\", filename: String? = \"\", lineno: Int? = 0, colno: Int? = 0, error: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ErrorEventInit {\n    val o = js(\"({})\")\n\n    o[\"message\"] = message\n    o[\"filename\"] = filename\n    o[\"lineno\"] = lineno\n    o[\"colno\"] = colno\n    o[\"error\"] = error\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [PromiseRejectionEvent](https://developer.mozilla.org/en/docs/Web/API/PromiseRejectionEvent) to Kotlin\n */\npublic external open class PromiseRejectionEvent(type: String, eventInitDict: PromiseRejectionEventInit) : Event {\n    open val promise: Promise<Any?>\n    open val reason: Any?\n}\n\npublic external interface PromiseRejectionEventInit : EventInit {\n    var promise: Promise<Any?>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PromiseRejectionEventInit(promise: Promise<Any?>?, reason: Any? = undefined, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PromiseRejectionEventInit {\n    val o = js(\"({})\")\n\n    o[\"promise\"] = promise\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [GlobalEventHandlers](https://developer.mozilla.org/en/docs/Web/API/GlobalEventHandlers) to Kotlin\n */\npublic external interface GlobalEventHandlers {\n    var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    var onpointerdown: ((PointerEvent) -> dynamic)?\n    var onpointermove: ((PointerEvent) -> dynamic)?\n    var onpointerup: ((PointerEvent) -> dynamic)?\n    var onpointercancel: ((PointerEvent) -> dynamic)?\n    var onpointerover: ((PointerEvent) -> dynamic)?\n    var onpointerout: ((PointerEvent) -> dynamic)?\n    var onpointerenter: ((PointerEvent) -> dynamic)?\n    var onpointerleave: ((PointerEvent) -> dynamic)?\n    var onabort: ((Event) -> dynamic)?\n    var onblur: ((FocusEvent) -> dynamic)?\n    var oncancel: ((Event) -> dynamic)?\n    var oncanplay: ((Event) -> dynamic)?\n    var oncanplaythrough: ((Event) -> dynamic)?\n    var onchange: ((Event) -> dynamic)?\n    var onclick: ((MouseEvent) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    var oncontextmenu: ((MouseEvent) -> dynamic)?\n    var oncuechange: ((Event) -> dynamic)?\n    var ondblclick: ((MouseEvent) -> dynamic)?\n    var ondrag: ((DragEvent) -> dynamic)?\n    var ondragend: ((DragEvent) -> dynamic)?\n    var ondragenter: ((DragEvent) -> dynamic)?\n    var ondragexit: ((DragEvent) -> dynamic)?\n    var ondragleave: ((DragEvent) -> dynamic)?\n    var ondragover: ((DragEvent) -> dynamic)?\n    var ondragstart: ((DragEvent) -> dynamic)?\n    var ondrop: ((DragEvent) -> dynamic)?\n    var ondurationchange: ((Event) -> dynamic)?\n    var onemptied: ((Event) -> dynamic)?\n    var onended: ((Event) -> dynamic)?\n    var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    var onfocus: ((FocusEvent) -> dynamic)?\n    var oninput: ((InputEvent) -> dynamic)?\n    var oninvalid: ((Event) -> dynamic)?\n    var onkeydown: ((KeyboardEvent) -> dynamic)?\n    var onkeypress: ((KeyboardEvent) -> dynamic)?\n    var onkeyup: ((KeyboardEvent) -> dynamic)?\n    var onload: ((Event) -> dynamic)?\n    var onloadeddata: ((Event) -> dynamic)?\n    var onloadedmetadata: ((Event) -> dynamic)?\n    var onloadend: ((Event) -> dynamic)?\n    var onloadstart: ((ProgressEvent) -> dynamic)?\n    var onmousedown: ((MouseEvent) -> dynamic)?\n    var onmouseenter: ((MouseEvent) -> dynamic)?\n    var onmouseleave: ((MouseEvent) -> dynamic)?\n    var onmousemove: ((MouseEvent) -> dynamic)?\n    var onmouseout: ((MouseEvent) -> dynamic)?\n    var onmouseover: ((MouseEvent) -> dynamic)?\n    var onmouseup: ((MouseEvent) -> dynamic)?\n    var onwheel: ((WheelEvent) -> dynamic)?\n    var onpause: ((Event) -> dynamic)?\n    var onplay: ((Event) -> dynamic)?\n    var onplaying: ((Event) -> dynamic)?\n    var onprogress: ((ProgressEvent) -> dynamic)?\n    var onratechange: ((Event) -> dynamic)?\n    var onreset: ((Event) -> dynamic)?\n    var onresize: ((Event) -> dynamic)?\n    var onscroll: ((Event) -> dynamic)?\n    var onseeked: ((Event) -> dynamic)?\n    var onseeking: ((Event) -> dynamic)?\n    var onselect: ((Event) -> dynamic)?\n    var onshow: ((Event) -> dynamic)?\n    var onstalled: ((Event) -> dynamic)?\n    var onsubmit: ((Event) -> dynamic)?\n    var onsuspend: ((Event) -> dynamic)?\n    var ontimeupdate: ((Event) -> dynamic)?\n    var ontoggle: ((Event) -> dynamic)?\n    var onvolumechange: ((Event) -> dynamic)?\n    var onwaiting: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [WindowEventHandlers](https://developer.mozilla.org/en/docs/Web/API/WindowEventHandlers) to Kotlin\n */\npublic external interface WindowEventHandlers {\n    var onafterprint: ((Event) -> dynamic)?\n    var onbeforeprint: ((Event) -> dynamic)?\n    var onbeforeunload: ((BeforeUnloadEvent) -> String?)?\n    var onhashchange: ((HashChangeEvent) -> dynamic)?\n    var onlanguagechange: ((Event) -> dynamic)?\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var onoffline: ((Event) -> dynamic)?\n    var ononline: ((Event) -> dynamic)?\n    var onpagehide: ((PageTransitionEvent) -> dynamic)?\n    var onpageshow: ((PageTransitionEvent) -> dynamic)?\n    var onpopstate: ((PopStateEvent) -> dynamic)?\n    var onrejectionhandled: ((Event) -> dynamic)?\n    var onstorage: ((StorageEvent) -> dynamic)?\n    var onunhandledrejection: ((PromiseRejectionEvent) -> dynamic)?\n    var onunload: ((Event) -> dynamic)?\n}\n\npublic external interface DocumentAndElementEventHandlers {\n    var oncopy: ((ClipboardEvent) -> dynamic)?\n    var oncut: ((ClipboardEvent) -> dynamic)?\n    var onpaste: ((ClipboardEvent) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [WindowOrWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WindowOrWorkerGlobalScope) to Kotlin\n */\npublic external interface WindowOrWorkerGlobalScope {\n    val caches: CacheStorage\n    val origin: String\n    fun fetch(input: dynamic, init: RequestInit = definedExternally): Promise<Response>\n    fun btoa(data: String): String\n    fun atob(data: String): String\n    fun setTimeout(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearTimeout(handle: Int = definedExternally): Unit\n    fun setInterval(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearInterval(handle: Int = definedExternally): Unit\n    fun createImageBitmap(image: dynamic, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun createImageBitmap(image: dynamic, sx: Int, sy: Int, sw: Int, sh: Int, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n}\n\n/**\n * Exposes the JavaScript [NavigatorID](https://developer.mozilla.org/en/docs/Web/API/NavigatorID) to Kotlin\n */\npublic external interface NavigatorID {\n    val appCodeName: String\n    val appName: String\n    val appVersion: String\n    val platform: String\n    val product: String\n    val productSub: String\n    val userAgent: String\n    val vendor: String\n    val vendorSub: String\n    val oscpu: String\n    fun taintEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorLanguage](https://developer.mozilla.org/en/docs/Web/API/NavigatorLanguage) to Kotlin\n */\npublic external interface NavigatorLanguage {\n    val language: String\n    val languages: Array<out String>\n}\n\npublic external interface NavigatorContentUtils {\n    fun registerProtocolHandler(scheme: String, url: String, title: String): Unit\n    fun registerContentHandler(mimeType: String, url: String, title: String): Unit\n    fun isProtocolHandlerRegistered(scheme: String, url: String): String\n    fun isContentHandlerRegistered(mimeType: String, url: String): String\n    fun unregisterProtocolHandler(scheme: String, url: String): Unit\n    fun unregisterContentHandler(mimeType: String, url: String): Unit\n}\n\npublic external interface NavigatorCookies {\n    val cookieEnabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorPlugins](https://developer.mozilla.org/en/docs/Web/API/NavigatorPlugins) to Kotlin\n */\npublic external interface NavigatorPlugins {\n    val plugins: PluginArray\n    val mimeTypes: MimeTypeArray\n    fun javaEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [PluginArray](https://developer.mozilla.org/en/docs/Web/API/PluginArray) to Kotlin\n */\npublic external abstract class PluginArray : ItemArrayLike<Plugin> {\n    override val length: Int\n    fun refresh(reload: Boolean = definedExternally): Unit\n    override fun item(index: Int): Plugin?\n    fun namedItem(name: String): Plugin?\n}\n@kotlin.internal.InlineOnly inline operator fun PluginArray.get(index: Int): Plugin? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun PluginArray.get(name: String): Plugin? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeTypeArray](https://developer.mozilla.org/en/docs/Web/API/MimeTypeArray) to Kotlin\n */\npublic external abstract class MimeTypeArray : ItemArrayLike<MimeType> {\n    override val length: Int\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n@kotlin.internal.InlineOnly inline operator fun MimeTypeArray.get(index: Int): MimeType? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun MimeTypeArray.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Plugin](https://developer.mozilla.org/en/docs/Web/API/Plugin) to Kotlin\n */\npublic external abstract class Plugin : ItemArrayLike<MimeType> {\n    open val name: String\n    open val description: String\n    open val filename: String\n    override val length: Int\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n@kotlin.internal.InlineOnly inline operator fun Plugin.get(index: Int): MimeType? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Plugin.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeType](https://developer.mozilla.org/en/docs/Web/API/MimeType) to Kotlin\n */\npublic external abstract class MimeType {\n    open val type: String\n    open val description: String\n    open val suffixes: String\n    open val enabledPlugin: Plugin\n}\n\n/**\n * Exposes the JavaScript [ImageBitmap](https://developer.mozilla.org/en/docs/Web/API/ImageBitmap) to Kotlin\n */\npublic external abstract class ImageBitmap : TexImageSource {\n    open val width: Int\n    open val height: Int\n    fun close(): Unit\n}\n\npublic external interface ImageBitmapOptions {\n    var imageOrientation: ImageOrientation? /* = ImageOrientation.NONE */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultiplyAlpha: PremultiplyAlpha? /* = PremultiplyAlpha.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colorSpaceConversion: ColorSpaceConversion? /* = ColorSpaceConversion.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeWidth: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeHeight: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeQuality: ResizeQuality? /* = ResizeQuality.LOW */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapOptions(imageOrientation: ImageOrientation? = ImageOrientation.NONE, premultiplyAlpha: PremultiplyAlpha? = PremultiplyAlpha.DEFAULT, colorSpaceConversion: ColorSpaceConversion? = ColorSpaceConversion.DEFAULT, resizeWidth: Int? = undefined, resizeHeight: Int? = undefined, resizeQuality: ResizeQuality? = ResizeQuality.LOW): ImageBitmapOptions {\n    val o = js(\"({})\")\n\n    o[\"imageOrientation\"] = imageOrientation\n    o[\"premultiplyAlpha\"] = premultiplyAlpha\n    o[\"colorSpaceConversion\"] = colorSpaceConversion\n    o[\"resizeWidth\"] = resizeWidth\n    o[\"resizeHeight\"] = resizeHeight\n    o[\"resizeQuality\"] = resizeQuality\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageEvent](https://developer.mozilla.org/en/docs/Web/API/MessageEvent) to Kotlin\n */\npublic external open class MessageEvent(type: String, eventInitDict: MessageEventInit = definedExternally) : Event {\n    open val data: Any?\n    open val origin: String\n    open val lastEventId: String\n    open val source: UnionMessagePortOrWindow?\n    open val ports: Array<out MessagePort>\n    fun initMessageEvent(type: String, bubbles: Boolean, cancelable: Boolean, data: Any?, origin: String, lastEventId: String, source: UnionMessagePortOrWindow?, ports: Array<MessagePort>): Unit\n}\n\npublic external interface MessageEventInit : EventInit {\n    var data: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var origin: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lastEventId: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var source: UnionMessagePortOrWindow? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var ports: Array<MessagePort>? /* = arrayOf() */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MessageEventInit(data: Any? = null, origin: String? = \"\", lastEventId: String? = \"\", source: UnionMessagePortOrWindow? = null, ports: Array<MessagePort>? = arrayOf(), bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MessageEventInit {\n    val o = js(\"({})\")\n\n    o[\"data\"] = data\n    o[\"origin\"] = origin\n    o[\"lastEventId\"] = lastEventId\n    o[\"source\"] = source\n    o[\"ports\"] = ports\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [EventSource](https://developer.mozilla.org/en/docs/Web/API/EventSource) to Kotlin\n */\npublic external open class EventSource(url: String, eventSourceInitDict: EventSourceInit = definedExternally) : EventTarget {\n    open val url: String\n    open val withCredentials: Boolean\n    open val readyState: Short\n    var onopen: ((Event) -> dynamic)?\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    fun close(): Unit\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSED: Short\n    }\n}\n\npublic external interface EventSourceInit {\n    var withCredentials: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventSourceInit(withCredentials: Boolean? = false): EventSourceInit {\n    val o = js(\"({})\")\n\n    o[\"withCredentials\"] = withCredentials\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [WebSocket](https://developer.mozilla.org/en/docs/Web/API/WebSocket) to Kotlin\n */\npublic external open class WebSocket(url: String, protocols: dynamic = definedExternally) : EventTarget {\n    open val url: String\n    open val readyState: Short\n    open val bufferedAmount: Int\n    var onopen: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    open val extensions: String\n    open val protocol: String\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var binaryType: BinaryType\n    fun close(code: Short = definedExternally, reason: String = definedExternally): Unit\n    fun send(data: String): Unit\n    fun send(data: Blob): Unit\n    fun send(data: ArrayBuffer): Unit\n    fun send(data: ArrayBufferView): Unit\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSING: Short\n        val CLOSED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CloseEvent](https://developer.mozilla.org/en/docs/Web/API/CloseEvent) to Kotlin\n */\npublic external open class CloseEvent(type: String, eventInitDict: CloseEventInit = definedExternally) : Event {\n    open val wasClean: Boolean\n    open val code: Short\n    open val reason: String\n}\n\npublic external interface CloseEventInit : EventInit {\n    var wasClean: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var code: Short? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CloseEventInit(wasClean: Boolean? = false, code: Short? = 0, reason: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CloseEventInit {\n    val o = js(\"({})\")\n\n    o[\"wasClean\"] = wasClean\n    o[\"code\"] = code\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageChannel](https://developer.mozilla.org/en/docs/Web/API/MessageChannel) to Kotlin\n */\npublic external open class MessageChannel {\n    open val port1: MessagePort\n    open val port2: MessagePort\n}\n\n/**\n * Exposes the JavaScript [MessagePort](https://developer.mozilla.org/en/docs/Web/API/MessagePort) to Kotlin\n */\npublic external abstract class MessagePort : EventTarget, UnionMessagePortOrWindow, UnionMessagePortOrServiceWorker, UnionClientOrMessagePortOrServiceWorker {\n    open var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n    fun start(): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [BroadcastChannel](https://developer.mozilla.org/en/docs/Web/API/BroadcastChannel) to Kotlin\n */\npublic external open class BroadcastChannel(name: String) : EventTarget {\n    open val name: String\n    var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [WorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WorkerGlobalScope) to Kotlin\n */\npublic external abstract class WorkerGlobalScope : EventTarget, WindowOrWorkerGlobalScope, GlobalPerformance {\n    open val self: WorkerGlobalScope\n    open val location: WorkerLocation\n    open val navigator: WorkerNavigator\n    open var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    open var onlanguagechange: ((Event) -> dynamic)?\n    open var onoffline: ((Event) -> dynamic)?\n    open var ononline: ((Event) -> dynamic)?\n    open var onrejectionhandled: ((Event) -> dynamic)?\n    open var onunhandledrejection: ((PromiseRejectionEvent) -> dynamic)?\n    fun importScripts(vararg urls: String): Unit\n}\n\n/**\n * Exposes the JavaScript [DedicatedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/DedicatedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class DedicatedWorkerGlobalScope : WorkerGlobalScope {\n    open var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [SharedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/SharedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class SharedWorkerGlobalScope : WorkerGlobalScope {\n    open val name: String\n    open val applicationCache: ApplicationCache\n    open var onconnect: ((Event) -> dynamic)?\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [AbstractWorker](https://developer.mozilla.org/en/docs/Web/API/AbstractWorker) to Kotlin\n */\npublic external interface AbstractWorker {\n    var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [Worker](https://developer.mozilla.org/en/docs/Web/API/Worker) to Kotlin\n */\npublic external open class Worker(scriptURL: String, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    var onmessage: ((MessageEvent) -> dynamic)?\n    override var onerror: ((Event) -> dynamic)?\n    fun terminate(): Unit\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n}\n\npublic external interface WorkerOptions {\n    var type: WorkerType? /* = WorkerType.CLASSIC */\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials? /* = RequestCredentials.OMIT */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WorkerOptions(type: WorkerType? = WorkerType.CLASSIC, credentials: RequestCredentials? = RequestCredentials.OMIT): WorkerOptions {\n    val o = js(\"({})\")\n\n    o[\"type\"] = type\n    o[\"credentials\"] = credentials\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [SharedWorker](https://developer.mozilla.org/en/docs/Web/API/SharedWorker) to Kotlin\n */\npublic external open class SharedWorker(scriptURL: String, name: String = definedExternally, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    open val port: MessagePort\n    override var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [NavigatorConcurrentHardware](https://developer.mozilla.org/en/docs/Web/API/NavigatorConcurrentHardware) to Kotlin\n */\npublic external interface NavigatorConcurrentHardware {\n    val hardwareConcurrency: Int\n}\n\n/**\n * Exposes the JavaScript [WorkerNavigator](https://developer.mozilla.org/en/docs/Web/API/WorkerNavigator) to Kotlin\n */\npublic external abstract class WorkerNavigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n}\n\n/**\n * Exposes the JavaScript [WorkerLocation](https://developer.mozilla.org/en/docs/Web/API/WorkerLocation) to Kotlin\n */\npublic external abstract class WorkerLocation {\n    open var href: String\n    open val origin: String\n    open val protocol: String\n    open val host: String\n    open val hostname: String\n    open val port: String\n    open val pathname: String\n    open val search: String\n    open val hash: String\n}\n\n/**\n * Exposes the JavaScript [Storage](https://developer.mozilla.org/en/docs/Web/API/Storage) to Kotlin\n */\npublic external abstract class Storage {\n    open val length: Int\n    fun key(index: Int): String?\n    fun getItem(key: String): String?\n    fun setItem(key: String, value: String): Unit\n    fun removeItem(key: String): Unit\n    fun clear(): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun Storage.get(key: String): String? = asDynamic()[key]\n@kotlin.internal.InlineOnly inline operator fun Storage.set(key: String, value: String): Unit { asDynamic()[key] = value; }\n\n/**\n * Exposes the JavaScript [WindowSessionStorage](https://developer.mozilla.org/en/docs/Web/API/WindowSessionStorage) to Kotlin\n */\npublic external interface WindowSessionStorage {\n    val sessionStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [WindowLocalStorage](https://developer.mozilla.org/en/docs/Web/API/WindowLocalStorage) to Kotlin\n */\npublic external interface WindowLocalStorage {\n    val localStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [StorageEvent](https://developer.mozilla.org/en/docs/Web/API/StorageEvent) to Kotlin\n */\npublic external open class StorageEvent(type: String, eventInitDict: StorageEventInit = definedExternally) : Event {\n    open val key: String?\n    open val oldValue: String?\n    open val newValue: String?\n    open val url: String\n    open val storageArea: Storage?\n}\n\npublic external interface StorageEventInit : EventInit {\n    var key: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var oldValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var url: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var storageArea: Storage? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun StorageEventInit(key: String? = null, oldValue: String? = null, newValue: String? = null, url: String? = \"\", storageArea: Storage? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): StorageEventInit {\n    val o = js(\"({})\")\n\n    o[\"key\"] = key\n    o[\"oldValue\"] = oldValue\n    o[\"newValue\"] = newValue\n    o[\"url\"] = url\n    o[\"storageArea\"] = storageArea\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external abstract class HTMLAppletElement : HTMLElement {\n    open var align: String\n    open var alt: String\n    open var archive: String\n    open var code: String\n    open var codeBase: String\n    open var height: String\n    open var hspace: Int\n    open var name: String\n    open var _object: String\n    open var vspace: Int\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLMarqueeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMarqueeElement) to Kotlin\n */\npublic external abstract class HTMLMarqueeElement : HTMLElement {\n    open var behavior: String\n    open var bgColor: String\n    open var direction: String\n    open var height: String\n    open var hspace: Int\n    open var loop: Int\n    open var scrollAmount: Int\n    open var scrollDelay: Int\n    open var trueSpeed: Boolean\n    open var vspace: Int\n    open var width: String\n    open var onbounce: ((Event) -> dynamic)?\n    open var onfinish: ((Event) -> dynamic)?\n    open var onstart: ((Event) -> dynamic)?\n    fun start(): Unit\n    fun stop(): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLFrameSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFrameSetElement) to Kotlin\n */\npublic external abstract class HTMLFrameSetElement : HTMLElement, WindowEventHandlers {\n    open var cols: String\n    open var rows: String\n}\n\npublic external abstract class HTMLFrameElement : HTMLElement {\n    open var name: String\n    open var scrolling: String\n    open var src: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var noResize: Boolean\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var marginHeight: String\n    open var marginWidth: String\n}\n\npublic external abstract class HTMLDirectoryElement : HTMLElement {\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLFontElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFontElement) to Kotlin\n */\npublic external abstract class HTMLFontElement : HTMLElement {\n    open var color: String\n    open var face: String\n    open var size: String\n}\n\npublic external interface External {\n    fun AddSearchProvider(): Unit\n    fun IsSearchProviderInstalled(): Unit\n}\n\npublic external interface EventInit {\n    var bubbles: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cancelable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventInit(bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): EventInit {\n    val o = js(\"({})\")\n\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomEvent](https://developer.mozilla.org/en/docs/Web/API/CustomEvent) to Kotlin\n */\npublic external open class CustomEvent(type: String, eventInitDict: CustomEventInit = definedExternally) : Event {\n    open val detail: Any?\n    fun initCustomEvent(type: String, bubbles: Boolean, cancelable: Boolean, detail: Any?): Unit\n}\n\npublic external interface CustomEventInit : EventInit {\n    var detail: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CustomEventInit(detail: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CustomEventInit {\n    val o = js(\"({})\")\n\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external interface EventListenerOptions {\n    var capture: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventListenerOptions(capture: Boolean? = false): EventListenerOptions {\n    val o = js(\"({})\")\n\n    o[\"capture\"] = capture\n\n    return o\n}\n\npublic external interface AddEventListenerOptions : EventListenerOptions {\n    var passive: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var once: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AddEventListenerOptions(passive: Boolean? = false, once: Boolean? = false, capture: Boolean? = false): AddEventListenerOptions {\n    val o = js(\"({})\")\n\n    o[\"passive\"] = passive\n    o[\"once\"] = once\n    o[\"capture\"] = capture\n\n    return o\n}\n\npublic external interface NonElementParentNode {\n    fun getElementById(elementId: String): Element?\n}\n\n/**\n * Exposes the JavaScript [DocumentOrShadowRoot](https://developer.mozilla.org/en/docs/Web/API/DocumentOrShadowRoot) to Kotlin\n */\npublic external interface DocumentOrShadowRoot {\n    val fullscreenElement: Element?\n}\n\n/**\n * Exposes the JavaScript [ParentNode](https://developer.mozilla.org/en/docs/Web/API/ParentNode) to Kotlin\n */\npublic external interface ParentNode {\n    val children: HTMLCollection\n    val firstElementChild: Element?\n    val lastElementChild: Element?\n    val childElementCount: Int\n    fun prepend(vararg nodes: dynamic): Unit\n    fun append(vararg nodes: dynamic): Unit\n    fun querySelector(selectors: String): Element?\n    fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [NonDocumentTypeChildNode](https://developer.mozilla.org/en/docs/Web/API/NonDocumentTypeChildNode) to Kotlin\n */\npublic external interface NonDocumentTypeChildNode {\n    val previousElementSibling: Element?\n    val nextElementSibling: Element?\n}\n\n/**\n * Exposes the JavaScript [ChildNode](https://developer.mozilla.org/en/docs/Web/API/ChildNode) to Kotlin\n */\npublic external interface ChildNode {\n    fun before(vararg nodes: dynamic): Unit\n    fun after(vararg nodes: dynamic): Unit\n    fun replaceWith(vararg nodes: dynamic): Unit\n    fun remove(): Unit\n}\n\n/**\n * Exposes the JavaScript [Slotable](https://developer.mozilla.org/en/docs/Web/API/Slotable) to Kotlin\n */\npublic external interface Slotable {\n    val assignedSlot: HTMLSlotElement?\n}\n\n/**\n * Exposes the JavaScript [NodeList](https://developer.mozilla.org/en/docs/Web/API/NodeList) to Kotlin\n */\npublic external abstract class NodeList : ItemArrayLike<Node> {\n    override val length: Int\n    override fun item(index: Int): Node?\n}\n@kotlin.internal.InlineOnly inline operator fun NodeList.get(index: Int): Node? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [HTMLCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLCollection) to Kotlin\n */\npublic external abstract class HTMLCollection : UnionElementOrHTMLCollection, ItemArrayLike<Element> {\n    override val length: Int\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): Element?\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLCollection.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLCollection.get(name: String): Element? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) to Kotlin\n */\npublic external open class MutationObserver(callback: (Array<MutationRecord>, MutationObserver) -> Unit) {\n    fun observe(target: Node, options: MutationObserverInit = definedExternally): Unit\n    fun disconnect(): Unit\n    fun takeRecords(): Array<MutationRecord>\n}\n\n/**\n * Exposes the JavaScript [MutationObserverInit](https://developer.mozilla.org/en/docs/Web/API/MutationObserverInit) to Kotlin\n */\npublic external interface MutationObserverInit {\n    var childList: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributes: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterData: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var subtree: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterDataOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeFilter: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MutationObserverInit(childList: Boolean? = false, attributes: Boolean? = undefined, characterData: Boolean? = undefined, subtree: Boolean? = false, attributeOldValue: Boolean? = undefined, characterDataOldValue: Boolean? = undefined, attributeFilter: Array<String>? = undefined): MutationObserverInit {\n    val o = js(\"({})\")\n\n    o[\"childList\"] = childList\n    o[\"attributes\"] = attributes\n    o[\"characterData\"] = characterData\n    o[\"subtree\"] = subtree\n    o[\"attributeOldValue\"] = attributeOldValue\n    o[\"characterDataOldValue\"] = characterDataOldValue\n    o[\"attributeFilter\"] = attributeFilter\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MutationRecord](https://developer.mozilla.org/en/docs/Web/API/MutationRecord) to Kotlin\n */\npublic external abstract class MutationRecord {\n    open val type: String\n    open val target: Node\n    open val addedNodes: NodeList\n    open val removedNodes: NodeList\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open val attributeName: String?\n    open val attributeNamespace: String?\n    open val oldValue: String?\n}\n\n/**\n * Exposes the JavaScript [Node](https://developer.mozilla.org/en/docs/Web/API/Node) to Kotlin\n */\npublic external abstract class Node : EventTarget {\n    open val nodeType: Short\n    open val nodeName: String\n    open val baseURI: String\n    open val isConnected: Boolean\n    open val ownerDocument: Document?\n    open val parentNode: Node?\n    open val parentElement: Element?\n    open val childNodes: NodeList\n    open val firstChild: Node?\n    open val lastChild: Node?\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open var nodeValue: String?\n    open var textContent: String?\n    fun getRootNode(options: GetRootNodeOptions = definedExternally): Node\n    fun hasChildNodes(): Boolean\n    fun normalize(): Unit\n    fun cloneNode(deep: Boolean = definedExternally): Node\n    fun isEqualNode(otherNode: Node?): Boolean\n    fun isSameNode(otherNode: Node?): Boolean\n    fun compareDocumentPosition(other: Node): Short\n    fun contains(other: Node?): Boolean\n    fun lookupPrefix(namespace: String?): String?\n    fun lookupNamespaceURI(prefix: String?): String?\n    fun isDefaultNamespace(namespace: String?): Boolean\n    fun insertBefore(node: Node, child: Node?): Node\n    fun appendChild(node: Node): Node\n    fun replaceChild(node: Node, child: Node): Node\n    fun removeChild(child: Node): Node\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface GetRootNodeOptions {\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun GetRootNodeOptions(composed: Boolean? = false): GetRootNodeOptions {\n    val o = js(\"({})\")\n\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [XMLDocument](https://developer.mozilla.org/en/docs/Web/API/XMLDocument) to Kotlin\n */\npublic external open class XMLDocument : Document {\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\npublic external interface ElementCreationOptions {\n    @JsName(\"is\") var is_: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementCreationOptions(is_: String? = undefined): ElementCreationOptions {\n    val o = js(\"({})\")\n\n    o[\"is\"] = is_\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMImplementation](https://developer.mozilla.org/en/docs/Web/API/DOMImplementation) to Kotlin\n */\npublic external abstract class DOMImplementation {\n    fun createDocumentType(qualifiedName: String, publicId: String, systemId: String): DocumentType\n    fun createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = definedExternally): XMLDocument\n    fun createHTMLDocument(title: String = definedExternally): Document\n    fun hasFeature(): Boolean\n}\n\n/**\n * Exposes the JavaScript [DocumentType](https://developer.mozilla.org/en/docs/Web/API/DocumentType) to Kotlin\n */\npublic external abstract class DocumentType : Node, ChildNode {\n    open val name: String\n    open val publicId: String\n    open val systemId: String\n}\n\n/**\n * Exposes the JavaScript [DocumentFragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment) to Kotlin\n */\npublic external open class DocumentFragment : Node, NonElementParentNode, ParentNode {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [ShadowRoot](https://developer.mozilla.org/en/docs/Web/API/ShadowRoot) to Kotlin\n */\npublic external open class ShadowRoot : DocumentFragment, DocumentOrShadowRoot {\n    open val mode: ShadowRootMode\n    open val host: Element\n    override val fullscreenElement: Element?\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [Element](https://developer.mozilla.org/en/docs/Web/API/Element) to Kotlin\n */\npublic external abstract class Element : Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slotable, GeometryUtils, UnionElementOrProcessingInstruction, UnionElementOrHTMLCollection, UnionElementOrRadioNodeList, UnionElementOrMouseEvent {\n    open var innerHTML: String\n    open var outerHTML: String\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val tagName: String\n    open var id: String\n    open var className: String\n    open val classList: DOMTokenList\n    open var slot: String\n    open val attributes: NamedNodeMap\n    open val shadowRoot: ShadowRoot?\n    open var scrollTop: Double\n    open var scrollLeft: Double\n    open val scrollWidth: Int\n    open val scrollHeight: Int\n    open val clientTop: Int\n    open val clientLeft: Int\n    open val clientWidth: Int\n    open val clientHeight: Int\n    fun requestFullscreen(): Promise<Unit>\n    fun setPointerCapture(pointerId: Int): Unit\n    fun releasePointerCapture(pointerId: Int): Unit\n    fun hasPointerCapture(pointerId: Int): Boolean\n    fun insertAdjacentHTML(position: String, text: String): Unit\n    fun hasAttributes(): Boolean\n    fun getAttributeNames(): Array<String>\n    fun getAttribute(qualifiedName: String): String?\n    fun getAttributeNS(namespace: String?, localName: String): String?\n    fun setAttribute(qualifiedName: String, value: String): Unit\n    fun setAttributeNS(namespace: String?, qualifiedName: String, value: String): Unit\n    fun removeAttribute(qualifiedName: String): Unit\n    fun removeAttributeNS(namespace: String?, localName: String): Unit\n    fun hasAttribute(qualifiedName: String): Boolean\n    fun hasAttributeNS(namespace: String?, localName: String): Boolean\n    fun getAttributeNode(qualifiedName: String): Attr?\n    fun getAttributeNodeNS(namespace: String?, localName: String): Attr?\n    fun setAttributeNode(attr: Attr): Attr?\n    fun setAttributeNodeNS(attr: Attr): Attr?\n    fun removeAttributeNode(attr: Attr): Attr\n    fun attachShadow(init: ShadowRootInit): ShadowRoot\n    fun closest(selectors: String): Element?\n    fun matches(selectors: String): Boolean\n    fun webkitMatchesSelector(selectors: String): Boolean\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun insertAdjacentElement(where: String, element: Element): Element?\n    fun insertAdjacentText(where: String, data: String): Unit\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun scrollIntoView(): Unit\n    fun scrollIntoView(arg: dynamic): Unit\n    fun scroll(options: ScrollToOptions = definedExternally): Unit\n    fun scroll(x: Double, y: Double): Unit\n    fun scrollTo(options: ScrollToOptions = definedExternally): Unit\n    fun scrollTo(x: Double, y: Double): Unit\n    fun scrollBy(options: ScrollToOptions = definedExternally): Unit\n    fun scrollBy(x: Double, y: Double): Unit\n}\n\npublic external interface ShadowRootInit {\n    var mode: ShadowRootMode?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ShadowRootInit(mode: ShadowRootMode?): ShadowRootInit {\n    val o = js(\"({})\")\n\n    o[\"mode\"] = mode\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [NamedNodeMap](https://developer.mozilla.org/en/docs/Web/API/NamedNodeMap) to Kotlin\n */\npublic external abstract class NamedNodeMap : ItemArrayLike<Attr> {\n    override val length: Int\n    override fun item(index: Int): Attr?\n    fun getNamedItem(qualifiedName: String): Attr?\n    fun getNamedItemNS(namespace: String?, localName: String): Attr?\n    fun setNamedItem(attr: Attr): Attr?\n    fun setNamedItemNS(attr: Attr): Attr?\n    fun removeNamedItem(qualifiedName: String): Attr\n    fun removeNamedItemNS(namespace: String?, localName: String): Attr\n}\n@kotlin.internal.InlineOnly inline operator fun NamedNodeMap.get(index: Int): Attr? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun NamedNodeMap.get(qualifiedName: String): Attr? = asDynamic()[qualifiedName]\n\n/**\n * Exposes the JavaScript [Attr](https://developer.mozilla.org/en/docs/Web/API/Attr) to Kotlin\n */\npublic external abstract class Attr : Node {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val name: String\n    open var value: String\n    open val ownerElement: Element?\n    open val specified: Boolean\n}\n\n/**\n * Exposes the JavaScript [CharacterData](https://developer.mozilla.org/en/docs/Web/API/CharacterData) to Kotlin\n */\npublic external abstract class CharacterData : Node, NonDocumentTypeChildNode, ChildNode {\n    open var data: String\n    open val length: Int\n    fun substringData(offset: Int, count: Int): String\n    fun appendData(data: String): Unit\n    fun insertData(offset: Int, data: String): Unit\n    fun deleteData(offset: Int, count: Int): Unit\n    fun replaceData(offset: Int, count: Int, data: String): Unit\n}\n\n/**\n * Exposes the JavaScript [Text](https://developer.mozilla.org/en/docs/Web/API/Text) to Kotlin\n */\npublic external open class Text(data: String = definedExternally) : CharacterData, Slotable, GeometryUtils {\n    open val wholeText: String\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    fun splitText(offset: Int): Text\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [CDATASection](https://developer.mozilla.org/en/docs/Web/API/CDATASection) to Kotlin\n */\npublic external open class CDATASection : Text {\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [ProcessingInstruction](https://developer.mozilla.org/en/docs/Web/API/ProcessingInstruction) to Kotlin\n */\npublic external abstract class ProcessingInstruction : CharacterData, LinkStyle, UnionElementOrProcessingInstruction {\n    open val target: String\n}\n\n/**\n * Exposes the JavaScript [Comment](https://developer.mozilla.org/en/docs/Web/API/Comment) to Kotlin\n */\npublic external open class Comment(data: String = definedExternally) : CharacterData {\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n}\n\n/**\n * Exposes the JavaScript [Range](https://developer.mozilla.org/en/docs/Web/API/Range) to Kotlin\n */\npublic external open class Range {\n    open val startContainer: Node\n    open val startOffset: Int\n    open val endContainer: Node\n    open val endOffset: Int\n    open val collapsed: Boolean\n    open val commonAncestorContainer: Node\n    fun createContextualFragment(fragment: String): DocumentFragment\n    fun setStart(node: Node, offset: Int): Unit\n    fun setEnd(node: Node, offset: Int): Unit\n    fun setStartBefore(node: Node): Unit\n    fun setStartAfter(node: Node): Unit\n    fun setEndBefore(node: Node): Unit\n    fun setEndAfter(node: Node): Unit\n    fun collapse(toStart: Boolean = definedExternally): Unit\n    fun selectNode(node: Node): Unit\n    fun selectNodeContents(node: Node): Unit\n    fun compareBoundaryPoints(how: Short, sourceRange: Range): Short\n    fun deleteContents(): Unit\n    fun extractContents(): DocumentFragment\n    fun cloneContents(): DocumentFragment\n    fun insertNode(node: Node): Unit\n    fun surroundContents(newParent: Node): Unit\n    fun cloneRange(): Range\n    fun detach(): Unit\n    fun isPointInRange(node: Node, offset: Int): Boolean\n    fun comparePoint(node: Node, offset: Int): Short\n    fun intersectsNode(node: Node): Boolean\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n\n    companion object {\n        val START_TO_START: Short\n        val START_TO_END: Short\n        val END_TO_END: Short\n        val END_TO_START: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NodeIterator](https://developer.mozilla.org/en/docs/Web/API/NodeIterator) to Kotlin\n */\npublic external abstract class NodeIterator {\n    open val root: Node\n    open val referenceNode: Node\n    open val pointerBeforeReferenceNode: Boolean\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    fun nextNode(): Node?\n    fun previousNode(): Node?\n    fun detach(): Unit\n}\n\n/**\n * Exposes the JavaScript [TreeWalker](https://developer.mozilla.org/en/docs/Web/API/TreeWalker) to Kotlin\n */\npublic external abstract class TreeWalker {\n    open val root: Node\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    open var currentNode: Node\n    fun parentNode(): Node?\n    fun firstChild(): Node?\n    fun lastChild(): Node?\n    fun previousSibling(): Node?\n    fun nextSibling(): Node?\n    fun previousNode(): Node?\n    fun nextNode(): Node?\n}\n\n/**\n * Exposes the JavaScript [NodeFilter](https://developer.mozilla.org/en/docs/Web/API/NodeFilter) to Kotlin\n */\npublic external interface NodeFilter {\n    fun acceptNode(node: Node): Short\n\n    companion object {\n        val FILTER_ACCEPT: Short\n        val FILTER_REJECT: Short\n        val FILTER_SKIP: Short\n        val SHOW_ALL: Int\n        val SHOW_ELEMENT: Int\n        val SHOW_ATTRIBUTE: Int\n        val SHOW_TEXT: Int\n        val SHOW_CDATA_SECTION: Int\n        val SHOW_ENTITY_REFERENCE: Int\n        val SHOW_ENTITY: Int\n        val SHOW_PROCESSING_INSTRUCTION: Int\n        val SHOW_COMMENT: Int\n        val SHOW_DOCUMENT: Int\n        val SHOW_DOCUMENT_TYPE: Int\n        val SHOW_DOCUMENT_FRAGMENT: Int\n        val SHOW_NOTATION: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMTokenList](https://developer.mozilla.org/en/docs/Web/API/DOMTokenList) to Kotlin\n */\npublic external abstract class DOMTokenList : ItemArrayLike<String> {\n    override val length: Int\n    open var value: String\n    override fun item(index: Int): String?\n    fun contains(token: String): Boolean\n    fun add(vararg tokens: String): Unit\n    fun remove(vararg tokens: String): Unit\n    fun toggle(token: String, force: Boolean = definedExternally): Boolean\n    fun replace(token: String, newToken: String): Unit\n    fun supports(token: String): Boolean\n}\n@kotlin.internal.InlineOnly inline operator fun DOMTokenList.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMPointReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMPointReadOnly) to Kotlin\n */\npublic external open class DOMPointReadOnly(x: Double, y: Double, z: Double, w: Double) {\n    open val x: Double\n    open val y: Double\n    open val z: Double\n    open val w: Double\n    fun matrixTransform(matrix: DOMMatrixReadOnly): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [DOMPoint](https://developer.mozilla.org/en/docs/Web/API/DOMPoint) to Kotlin\n */\npublic external open class DOMPoint : DOMPointReadOnly {\n    constructor(point: DOMPointInit)\n    constructor(x: Double = definedExternally, y: Double = definedExternally, z: Double = definedExternally, w: Double = definedExternally)\n    override var x: Double\n    override var y: Double\n    override var z: Double\n    override var w: Double\n}\n\n/**\n * Exposes the JavaScript [DOMPointInit](https://developer.mozilla.org/en/docs/Web/API/DOMPointInit) to Kotlin\n */\npublic external interface DOMPointInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var z: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var w: Double? /* = 1.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMPointInit(x: Double? = 0.0, y: Double? = 0.0, z: Double? = 0.0, w: Double? = 1.0): DOMPointInit {\n    val o = js(\"({})\")\n\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"z\"] = z\n    o[\"w\"] = w\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMRect](https://developer.mozilla.org/en/docs/Web/API/DOMRect) to Kotlin\n */\npublic external open class DOMRect(x: Double = definedExternally, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally) : DOMRectReadOnly {\n    override var x: Double\n    override var y: Double\n    override var width: Double\n    override var height: Double\n}\n\n/**\n * Exposes the JavaScript [DOMRectReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMRectReadOnly) to Kotlin\n */\npublic external open class DOMRectReadOnly(x: Double, y: Double, width: Double, height: Double) {\n    open val x: Double\n    open val y: Double\n    open val width: Double\n    open val height: Double\n    open val top: Double\n    open val right: Double\n    open val bottom: Double\n    open val left: Double\n}\n\npublic external interface DOMRectInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var width: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMRectInit(x: Double? = 0.0, y: Double? = 0.0, width: Double? = 0.0, height: Double? = 0.0): DOMRectInit {\n    val o = js(\"({})\")\n\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"width\"] = width\n    o[\"height\"] = height\n\n    return o\n}\n\npublic external interface DOMRectList : ItemArrayLike<DOMRect> {\n    override fun item(index: Int): DOMRect?\n}\n@kotlin.internal.InlineOnly inline operator fun DOMRectList.get(index: Int): DOMRect? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMQuad](https://developer.mozilla.org/en/docs/Web/API/DOMQuad) to Kotlin\n */\npublic external open class DOMQuad {\n    constructor(p1: DOMPointInit = definedExternally, p2: DOMPointInit = definedExternally, p3: DOMPointInit = definedExternally, p4: DOMPointInit = definedExternally)\n    constructor(rect: DOMRectInit)\n    open val p1: DOMPoint\n    open val p2: DOMPoint\n    open val p3: DOMPoint\n    open val p4: DOMPoint\n    open val bounds: DOMRectReadOnly\n}\n\n/**\n * Exposes the JavaScript [DOMMatrixReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMMatrixReadOnly) to Kotlin\n */\npublic external open class DOMMatrixReadOnly(numberSequence: Array<Double>) {\n    open val a: Double\n    open val b: Double\n    open val c: Double\n    open val d: Double\n    open val e: Double\n    open val f: Double\n    open val m11: Double\n    open val m12: Double\n    open val m13: Double\n    open val m14: Double\n    open val m21: Double\n    open val m22: Double\n    open val m23: Double\n    open val m24: Double\n    open val m31: Double\n    open val m32: Double\n    open val m33: Double\n    open val m34: Double\n    open val m41: Double\n    open val m42: Double\n    open val m43: Double\n    open val m44: Double\n    open val is2D: Boolean\n    open val isIdentity: Boolean\n    fun translate(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scale(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3d(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniform(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotate(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVector(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngle(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewX(sx: Double): DOMMatrix\n    fun skewY(sy: Double): DOMMatrix\n    fun multiply(other: DOMMatrix): DOMMatrix\n    fun flipX(): DOMMatrix\n    fun flipY(): DOMMatrix\n    fun inverse(): DOMMatrix\n    fun transformPoint(point: DOMPointInit = definedExternally): DOMPoint\n    fun toFloat32Array(): Float32Array\n    fun toFloat64Array(): Float64Array\n}\n\n/**\n * Exposes the JavaScript [DOMMatrix](https://developer.mozilla.org/en/docs/Web/API/DOMMatrix) to Kotlin\n */\npublic external open class DOMMatrix() : DOMMatrixReadOnly {\n    constructor(transformList: String)\n    constructor(other: DOMMatrixReadOnly)\n    constructor(array32: Float32Array)\n    constructor(array64: Float64Array)\n    constructor(numberSequence: Array<Double>)\n    override var a: Double\n    override var b: Double\n    override var c: Double\n    override var d: Double\n    override var e: Double\n    override var f: Double\n    override var m11: Double\n    override var m12: Double\n    override var m13: Double\n    override var m14: Double\n    override var m21: Double\n    override var m22: Double\n    override var m23: Double\n    override var m24: Double\n    override var m31: Double\n    override var m32: Double\n    override var m33: Double\n    override var m34: Double\n    override var m41: Double\n    override var m42: Double\n    override var m43: Double\n    override var m44: Double\n    fun multiplySelf(other: DOMMatrix): DOMMatrix\n    fun preMultiplySelf(other: DOMMatrix): DOMMatrix\n    fun translateSelf(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scaleSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3dSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniformSelf(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotateSelf(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVectorSelf(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngleSelf(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewXSelf(sx: Double): DOMMatrix\n    fun skewYSelf(sy: Double): DOMMatrix\n    fun invertSelf(): DOMMatrix\n    fun setMatrixValue(transformList: String): DOMMatrix\n}\n\npublic external interface ScrollOptions {\n    var behavior: ScrollBehavior? /* = ScrollBehavior.AUTO */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollOptions(behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollOptions {\n    val o = js(\"({})\")\n\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ScrollToOptions](https://developer.mozilla.org/en/docs/Web/API/ScrollToOptions) to Kotlin\n */\npublic external interface ScrollToOptions : ScrollOptions {\n    var left: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var top: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollToOptions(left: Double? = undefined, top: Double? = undefined, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollToOptions {\n    val o = js(\"({})\")\n\n    o[\"left\"] = left\n    o[\"top\"] = top\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaQueryList](https://developer.mozilla.org/en/docs/Web/API/MediaQueryList) to Kotlin\n */\npublic external abstract class MediaQueryList : EventTarget {\n    open val media: String\n    open val matches: Boolean\n    open var onchange: ((Event) -> dynamic)?\n    fun addListener(listener: EventListener?): Unit\n    fun addListener(listener: ((Event) -> Unit)?): Unit\n    fun removeListener(listener: EventListener?): Unit\n    fun removeListener(listener: ((Event) -> Unit)?): Unit\n}\n\n/**\n * Exposes the JavaScript [MediaQueryListEvent](https://developer.mozilla.org/en/docs/Web/API/MediaQueryListEvent) to Kotlin\n */\npublic external open class MediaQueryListEvent(type: String, eventInitDict: MediaQueryListEventInit = definedExternally) : Event {\n    open val media: String\n    open val matches: Boolean\n}\n\npublic external interface MediaQueryListEventInit : EventInit {\n    var media: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var matches: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaQueryListEventInit(media: String? = \"\", matches: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MediaQueryListEventInit {\n    val o = js(\"({})\")\n\n    o[\"media\"] = media\n    o[\"matches\"] = matches\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [Screen](https://developer.mozilla.org/en/docs/Web/API/Screen) to Kotlin\n */\npublic external abstract class Screen {\n    open val availWidth: Int\n    open val availHeight: Int\n    open val width: Int\n    open val height: Int\n    open val colorDepth: Int\n    open val pixelDepth: Int\n}\n\n/**\n * Exposes the JavaScript [CaretPosition](https://developer.mozilla.org/en/docs/Web/API/CaretPosition) to Kotlin\n */\npublic external abstract class CaretPosition {\n    open val offsetNode: Node\n    open val offset: Int\n    fun getClientRect(): DOMRect?\n}\n\npublic external interface ScrollIntoViewOptions : ScrollOptions {\n    var block: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var inline: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollIntoViewOptions(block: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, inline: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollIntoViewOptions {\n    val o = js(\"({})\")\n\n    o[\"block\"] = block\n    o[\"inline\"] = inline\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\npublic external interface BoxQuadOptions {\n    var box: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var relativeTo: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun BoxQuadOptions(box: CSSBoxType? = CSSBoxType.BORDER, relativeTo: dynamic = undefined): BoxQuadOptions {\n    val o = js(\"({})\")\n\n    o[\"box\"] = box\n    o[\"relativeTo\"] = relativeTo\n\n    return o\n}\n\npublic external interface ConvertCoordinateOptions {\n    var fromBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var toBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConvertCoordinateOptions(fromBox: CSSBoxType? = CSSBoxType.BORDER, toBox: CSSBoxType? = CSSBoxType.BORDER): ConvertCoordinateOptions {\n    val o = js(\"({})\")\n\n    o[\"fromBox\"] = fromBox\n    o[\"toBox\"] = toBox\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [GeometryUtils](https://developer.mozilla.org/en/docs/Web/API/GeometryUtils) to Kotlin\n */\npublic external interface GeometryUtils {\n    fun getBoxQuads(options: BoxQuadOptions = definedExternally): Array<DOMQuad>\n    fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMPoint\n}\n\npublic external @marker interface UnionElementOrProcessingInstruction {\n}\n\npublic external @marker interface UnionElementOrHTMLCollection {\n}\n\npublic external @marker interface UnionElementOrRadioNodeList {\n}\n\npublic external @marker interface UnionHTMLOptGroupElementOrHTMLOptionElement {\n}\n\npublic external @marker interface UnionAudioTrackOrTextTrackOrVideoTrack {\n}\n\npublic external @marker interface UnionElementOrMouseEvent {\n}\n\npublic external @marker interface UnionMessagePortOrWindow {\n}\n\npublic external @marker interface UnionMessagePortOrServiceWorker {\n}\n\npublic external @marker interface HTMLOrSVGScriptElement {\n}\n\npublic external @marker interface RenderingContext {\n}\n\npublic external @marker interface HTMLOrSVGImageElement {\n}\n\n/* please, don't implement this interface! */\npublic external interface DocumentReadyState {\n    companion object\n}\npublic inline val DocumentReadyState.Companion.LOADING: DocumentReadyState get() = \"loading\".asDynamic().unsafeCast<DocumentReadyState>()\npublic inline val DocumentReadyState.Companion.INTERACTIVE: DocumentReadyState get() = \"interactive\".asDynamic().unsafeCast<DocumentReadyState>()\npublic inline val DocumentReadyState.Companion.COMPLETE: DocumentReadyState get() = \"complete\".asDynamic().unsafeCast<DocumentReadyState>()\n\n/* please, don't implement this interface! */\npublic external interface CanPlayTypeResult {\n    companion object\n}\npublic inline val CanPlayTypeResult.Companion.EMPTY: CanPlayTypeResult get() = \"\".asDynamic().unsafeCast<CanPlayTypeResult>()\npublic inline val CanPlayTypeResult.Companion.MAYBE: CanPlayTypeResult get() = \"maybe\".asDynamic().unsafeCast<CanPlayTypeResult>()\npublic inline val CanPlayTypeResult.Companion.PROBABLY: CanPlayTypeResult get() = \"probably\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\n/* please, don't implement this interface! */\npublic external interface TextTrackMode {\n    companion object\n}\npublic inline val TextTrackMode.Companion.DISABLED: TextTrackMode get() = \"disabled\".asDynamic().unsafeCast<TextTrackMode>()\npublic inline val TextTrackMode.Companion.HIDDEN: TextTrackMode get() = \"hidden\".asDynamic().unsafeCast<TextTrackMode>()\npublic inline val TextTrackMode.Companion.SHOWING: TextTrackMode get() = \"showing\".asDynamic().unsafeCast<TextTrackMode>()\n\n/* please, don't implement this interface! */\npublic external interface TextTrackKind {\n    companion object\n}\npublic inline val TextTrackKind.Companion.SUBTITLES: TextTrackKind get() = \"subtitles\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.CAPTIONS: TextTrackKind get() = \"captions\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.DESCRIPTIONS: TextTrackKind get() = \"descriptions\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.CHAPTERS: TextTrackKind get() = \"chapters\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.METADATA: TextTrackKind get() = \"metadata\".asDynamic().unsafeCast<TextTrackKind>()\n\n/* please, don't implement this interface! */\npublic external interface SelectionMode {\n    companion object\n}\npublic inline val SelectionMode.Companion.SELECT: SelectionMode get() = \"select\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.START: SelectionMode get() = \"start\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.END: SelectionMode get() = \"end\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.PRESERVE: SelectionMode get() = \"preserve\".asDynamic().unsafeCast<SelectionMode>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasFillRule {\n    companion object\n}\npublic inline val CanvasFillRule.Companion.NONZERO: CanvasFillRule get() = \"nonzero\".asDynamic().unsafeCast<CanvasFillRule>()\npublic inline val CanvasFillRule.Companion.EVENODD: CanvasFillRule get() = \"evenodd\".asDynamic().unsafeCast<CanvasFillRule>()\n\n/* please, don't implement this interface! */\npublic external interface ImageSmoothingQuality {\n    companion object\n}\npublic inline val ImageSmoothingQuality.Companion.LOW: ImageSmoothingQuality get() = \"low\".asDynamic().unsafeCast<ImageSmoothingQuality>()\npublic inline val ImageSmoothingQuality.Companion.MEDIUM: ImageSmoothingQuality get() = \"medium\".asDynamic().unsafeCast<ImageSmoothingQuality>()\npublic inline val ImageSmoothingQuality.Companion.HIGH: ImageSmoothingQuality get() = \"high\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasLineCap {\n    companion object\n}\npublic inline val CanvasLineCap.Companion.BUTT: CanvasLineCap get() = \"butt\".asDynamic().unsafeCast<CanvasLineCap>()\npublic inline val CanvasLineCap.Companion.ROUND: CanvasLineCap get() = \"round\".asDynamic().unsafeCast<CanvasLineCap>()\npublic inline val CanvasLineCap.Companion.SQUARE: CanvasLineCap get() = \"square\".asDynamic().unsafeCast<CanvasLineCap>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasLineJoin {\n    companion object\n}\npublic inline val CanvasLineJoin.Companion.ROUND: CanvasLineJoin get() = \"round\".asDynamic().unsafeCast<CanvasLineJoin>()\npublic inline val CanvasLineJoin.Companion.BEVEL: CanvasLineJoin get() = \"bevel\".asDynamic().unsafeCast<CanvasLineJoin>()\npublic inline val CanvasLineJoin.Companion.MITER: CanvasLineJoin get() = \"miter\".asDynamic().unsafeCast<CanvasLineJoin>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasTextAlign {\n    companion object\n}\npublic inline val CanvasTextAlign.Companion.START: CanvasTextAlign get() = \"start\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.END: CanvasTextAlign get() = \"end\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.LEFT: CanvasTextAlign get() = \"left\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.RIGHT: CanvasTextAlign get() = \"right\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.CENTER: CanvasTextAlign get() = \"center\".asDynamic().unsafeCast<CanvasTextAlign>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasTextBaseline {\n    companion object\n}\npublic inline val CanvasTextBaseline.Companion.TOP: CanvasTextBaseline get() = \"top\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.HANGING: CanvasTextBaseline get() = \"hanging\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.MIDDLE: CanvasTextBaseline get() = \"middle\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.ALPHABETIC: CanvasTextBaseline get() = \"alphabetic\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.IDEOGRAPHIC: CanvasTextBaseline get() = \"ideographic\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.BOTTOM: CanvasTextBaseline get() = \"bottom\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasDirection {\n    companion object\n}\npublic inline val CanvasDirection.Companion.LTR: CanvasDirection get() = \"ltr\".asDynamic().unsafeCast<CanvasDirection>()\npublic inline val CanvasDirection.Companion.RTL: CanvasDirection get() = \"rtl\".asDynamic().unsafeCast<CanvasDirection>()\npublic inline val CanvasDirection.Companion.INHERIT: CanvasDirection get() = \"inherit\".asDynamic().unsafeCast<CanvasDirection>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollRestoration {\n    companion object\n}\npublic inline val ScrollRestoration.Companion.AUTO: ScrollRestoration get() = \"auto\".asDynamic().unsafeCast<ScrollRestoration>()\npublic inline val ScrollRestoration.Companion.MANUAL: ScrollRestoration get() = \"manual\".asDynamic().unsafeCast<ScrollRestoration>()\n\n/* please, don't implement this interface! */\npublic external interface ImageOrientation {\n    companion object\n}\npublic inline val ImageOrientation.Companion.NONE: ImageOrientation get() = \"none\".asDynamic().unsafeCast<ImageOrientation>()\npublic inline val ImageOrientation.Companion.FLIPY: ImageOrientation get() = \"flipY\".asDynamic().unsafeCast<ImageOrientation>()\n\n/* please, don't implement this interface! */\npublic external interface PremultiplyAlpha {\n    companion object\n}\npublic inline val PremultiplyAlpha.Companion.NONE: PremultiplyAlpha get() = \"none\".asDynamic().unsafeCast<PremultiplyAlpha>()\npublic inline val PremultiplyAlpha.Companion.PREMULTIPLY: PremultiplyAlpha get() = \"premultiply\".asDynamic().unsafeCast<PremultiplyAlpha>()\npublic inline val PremultiplyAlpha.Companion.DEFAULT: PremultiplyAlpha get() = \"default\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\n/* please, don't implement this interface! */\npublic external interface ColorSpaceConversion {\n    companion object\n}\npublic inline val ColorSpaceConversion.Companion.NONE: ColorSpaceConversion get() = \"none\".asDynamic().unsafeCast<ColorSpaceConversion>()\npublic inline val ColorSpaceConversion.Companion.DEFAULT: ColorSpaceConversion get() = \"default\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\n/* please, don't implement this interface! */\npublic external interface ResizeQuality {\n    companion object\n}\npublic inline val ResizeQuality.Companion.PIXELATED: ResizeQuality get() = \"pixelated\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.LOW: ResizeQuality get() = \"low\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.MEDIUM: ResizeQuality get() = \"medium\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.HIGH: ResizeQuality get() = \"high\".asDynamic().unsafeCast<ResizeQuality>()\n\n/* please, don't implement this interface! */\npublic external interface BinaryType {\n    companion object\n}\npublic inline val BinaryType.Companion.BLOB: BinaryType get() = \"blob\".asDynamic().unsafeCast<BinaryType>()\npublic inline val BinaryType.Companion.ARRAYBUFFER: BinaryType get() = \"arraybuffer\".asDynamic().unsafeCast<BinaryType>()\n\n/* please, don't implement this interface! */\npublic external interface WorkerType {\n    companion object\n}\npublic inline val WorkerType.Companion.CLASSIC: WorkerType get() = \"classic\".asDynamic().unsafeCast<WorkerType>()\npublic inline val WorkerType.Companion.MODULE: WorkerType get() = \"module\".asDynamic().unsafeCast<WorkerType>()\n\n/* please, don't implement this interface! */\npublic external interface ShadowRootMode {\n    companion object\n}\npublic inline val ShadowRootMode.Companion.OPEN: ShadowRootMode get() = \"open\".asDynamic().unsafeCast<ShadowRootMode>()\npublic inline val ShadowRootMode.Companion.CLOSED: ShadowRootMode get() = \"closed\".asDynamic().unsafeCast<ShadowRootMode>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollBehavior {\n    companion object\n}\npublic inline val ScrollBehavior.Companion.AUTO: ScrollBehavior get() = \"auto\".asDynamic().unsafeCast<ScrollBehavior>()\npublic inline val ScrollBehavior.Companion.INSTANT: ScrollBehavior get() = \"instant\".asDynamic().unsafeCast<ScrollBehavior>()\npublic inline val ScrollBehavior.Companion.SMOOTH: ScrollBehavior get() = \"smooth\".asDynamic().unsafeCast<ScrollBehavior>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollLogicalPosition {\n    companion object\n}\npublic inline val ScrollLogicalPosition.Companion.START: ScrollLogicalPosition get() = \"start\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.CENTER: ScrollLogicalPosition get() = \"center\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.END: ScrollLogicalPosition get() = \"end\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.NEAREST: ScrollLogicalPosition get() = \"nearest\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\n/* please, don't implement this interface! */\npublic external interface CSSBoxType {\n    companion object\n}\npublic inline val CSSBoxType.Companion.MARGIN: CSSBoxType get() = \"margin\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.BORDER: CSSBoxType get() = \"border\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.PADDING: CSSBoxType get() = \"padding\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.CONTENT: CSSBoxType get() = \"content\".asDynamic().unsafeCast<CSSBoxType>()\n\n","package baaahs\n\nimport baaahs.geom.Vector2F\nimport baaahs.geom.Vector3F\nimport baaahs.imaging.Bitmap\nimport baaahs.imaging.CanvasBitmap\nimport baaahs.imaging.Image\nimport baaahs.imaging.NativeBitmap\nimport baaahs.visualizer.Rotator\nimport info.laht.threekt.cameras.Camera\nimport info.laht.threekt.cameras.PerspectiveCamera\nimport info.laht.threekt.core.*\nimport info.laht.threekt.core.Clock\nimport info.laht.threekt.geometries.SphereBufferGeometry\nimport info.laht.threekt.materials.LineBasicMaterial\nimport info.laht.threekt.materials.MeshBasicMaterial\nimport info.laht.threekt.materials.PointsMaterial\nimport info.laht.threekt.math.*\nimport info.laht.threekt.math.Color\nimport info.laht.threekt.objects.Line\nimport info.laht.threekt.objects.Mesh\nimport info.laht.threekt.objects.Points\nimport info.laht.threekt.renderers.WebGLRenderer\nimport info.laht.threekt.scenes.Scene\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport kotlinx.html.*\nimport kotlinx.html.dom.append\nimport kotlinx.html.dom.create\nimport kotlinx.html.js.onClickFunction\nimport kotlinx.html.js.table\nimport org.w3c.dom.*\nimport org.w3c.dom.events.KeyboardEvent\nimport kotlin.browser.document\nimport kotlin.browser.window\nimport kotlin.collections.component1\nimport kotlin.collections.component2\nimport kotlin.collections.set\nimport kotlin.dom.clear\nimport kotlin.math.min\nimport kotlin.math.roundToInt\n\nclass JsMapperUi(private val statusListener: StatusListener? = null) : MapperUi, HostedWebApp {\n    private lateinit var listener: MapperUi.Listener\n\n    override fun listen(listener: MapperUi.Listener) {\n        this.listener = listener\n    }\n\n    private var width = 512\n    private var height = 384\n\n    private var uiWidth = 512\n    private var uiHeight = 384\n\n    private var haveCamDimensions = false\n    private var camWidth = 0\n    private var camHeight = 0\n\n    private val clock = Clock()\n\n    // onscreen renderer for registration UI:\n    private val uiRenderer = WebGLRenderer(js(\"{alpha: true}\"))\n    private var uiScene = Scene()\n    private var uiCamera = PerspectiveCamera(45, width.toDouble() / height, 1, 10000)\n    private var uiControls: dynamic\n    private val wireframe = Object3D()\n\n    private var selectedSurfaces = mutableListOf<PanelInfo>()\n    private var uiLocked: Boolean = false\n\n    private val screen = document.create.div(\"mapperUi-screen\") {\n        tabIndex = \"-1\" // So we can receive key events.\n\n        div(\"mapperUi-controls\") {\n            button { +\"\u25b2\"; onClickFunction = { wireframe.position.y += 10 } }\n            button { +\"\u25bc\"; onClickFunction = { wireframe.position.y -= 10 } }\n//            button { i(classes=\"fas fa-crosshairs\"); onClickFunction = { target() } }\n            button { i(classes = \"fas fa-play\"); onClickFunction = { clickedPlay() } }\n            button { i(classes = \"fas fa-pause\"); onClickFunction = { clickedPause() } }\n            button { i(classes = \"fas fa-redo\"); onClickFunction = { redoFn?.invoke() } }\n            button { i(classes = \"fas fa-stop\"); onClickFunction = { clickedStop() } }\n            button {\n                i(classes = \"fas fa-sign-in-alt\")\n                onClickFunction = {\n                    val surfaceName = window.prompt(\"Surface:\")\n                    if (surfaceName != null && surfaceName.isNotEmpty()) {\n                        goToSurface(surfaceName.toUpperCase())\n                    }\n                }\n            }\n            select(\"mapperUi-sessionSelector\") { }\n        }\n        canvas(classes = \"mapperUi-2d-canvas\") {\n            width = this@JsMapperUi.width.toString() + \"px\"\n            height = this@JsMapperUi.height.toString() + \"px\"\n        }\n        div(\"mapperUi-3d-div\") { }\n        canvas(classes = \"mapperUi-diff-canvas\") {\n            width = this@JsMapperUi.width.toString() + \"px\"\n            height = this@JsMapperUi.height.toString() + \"px\"\n        }\n        canvas(classes = \"mapperUi-before-canvas\") {\n            width = this@JsMapperUi.width.toString() + \"px\"\n            height = this@JsMapperUi.height.toString() + \"px\"\n        }\n        canvas(classes = \"mapperUi-after-canvas\") {\n            width = this@JsMapperUi.width.toString() + \"px\"\n            height = this@JsMapperUi.height.toString() + \"px\"\n        }\n        div(\"mapperUi-stats\") { }\n        div(\"mapperUi-message\") { }\n        div(\"mapperUi-message2\") { }\n        div(\"mapperUi-table\") { }\n    }\n\n    private val ui2dCanvas = screen.first<HTMLCanvasElement>(\"mapperUi-2d-canvas\")\n    private val ui2dCtx = ui2dCanvas.context2d()\n\n    private val ui3dDiv = screen.first<HTMLCanvasElement>(\"mapperUi-3d-div\")\n    private val ui3dCanvas = uiRenderer.domElement as HTMLCanvasElement\n\n    private val diffCanvas = screen.first<HTMLCanvasElement>(\"mapperUi-diff-canvas\")\n    private val diffCtx = diffCanvas.context2d()\n\n    private val beforeCanvas = screen.first<HTMLCanvasElement>(\"mapperUi-before-canvas\")\n    private val afterCanvas = screen.first<HTMLCanvasElement>(\"mapperUi-after-canvas\")\n\n    private val statsDiv = screen.first<HTMLDivElement>(\"mapperUi-stats\")\n    private val messageDiv = screen.first<HTMLDivElement>(\"mapperUi-message\")\n    private val message2Div = screen.first<HTMLDivElement>(\"mapperUi-message2\")\n    private val table = screen.first<HTMLDivElement>(\"mapperUi-table\")\n    private val sessionSelector = screen.first<HTMLSelectElement>(\"mapperUi-sessionSelector\")\n\n    private val playButton = screen.first<HTMLButtonElement>(\"fa-play\")\n    private val pauseButton = screen.first<HTMLButtonElement>(\"fa-pause\")\n    private val redoButton = screen.first<HTMLButtonElement>(\"fa-redo\")\n\n    private val modelSurfaceInfos = mutableMapOf<SheepModel.Panel, PanelInfo>()\n\n    private var commandProgress = \"\"\n    private var cameraZRotation = 0f\n\n    private var redoFn: (() -> Unit)? = null\n\n    init {\n        statusListener?.mapperStatusChanged(true)\n\n        ui3dDiv.appendChild(ui3dCanvas)\n\n        uiCamera.position.z = 1000.0\n        uiScene.add(uiCamera)\n\n        uiControls = js(\"document.createCameraControls\")(uiCamera, uiRenderer.domElement)\n\n        screen.focus()\n        screen.addEventListener(\"keydown\", { event -> gotUiKeypress(event as KeyboardEvent) })\n\n        drawAnimationFrame()\n    }\n\n    private fun gotUiKeypress(event: KeyboardEvent) {\n        if (event.code == \"Enter\") {\n            processCommand(commandProgress.trim())\n            commandProgress = \"\"\n        } else if (event.code == \"Backspace\") {\n            if (commandProgress.isNotEmpty()) {\n                commandProgress = commandProgress.substring(0..(commandProgress.length - 2))\n            }\n            checkProgress()\n        } else if (commandProgress.isEmpty() && event.code == \"KeyQ\") {\n            updateCameraRotation(if (event.shiftKey) 0.025f else 0.1f)\n        } else if (commandProgress.isEmpty() && event.code == \"KeyW\") {\n            updateCameraRotation(if (event.shiftKey) -0.025f else -0.1f)\n        } else if (commandProgress.isEmpty() && event.code == \"Digit0\") {\n            cameraZRotation = 0f\n        } else if (event.key.length == 1) {\n            commandProgress += event.key\n            checkProgress()\n        }\n        showMessage2(commandProgress)\n    }\n\n    private fun checkProgress() {\n        if (commandProgress.startsWith(\"/\") && commandProgress.length > 1) {\n            selectSurfacesMatching(commandProgress.substring(1))\n        }\n    }\n\n    override fun addExistingSession(name: String) {\n        sessionSelector.insertBefore(\n            document.create.option { label = name; value = name },\n            sessionSelector.childNodes.asList().find { (it as HTMLOptionElement).value > name }\n        )\n    }\n\n    private fun resetCameraRotation() {\n        cameraZRotation = 0f\n        updateCameraRotation(0f)\n    }\n\n    private fun updateCameraRotation(angle: Float) {\n        cameraZRotation += angle\n        uiCamera.up.set(0, 1, 0)\n        uiCamera.up.applyMatrix4(Matrix4().makeRotationZ(cameraZRotation.toDouble()))\n    }\n\n    private fun selectSurfacesMatching(pattern: String) {\n        selectedSurfaces.forEach { it.deselect() }\n        selectedSurfaces.clear()\n        selectedSurfaces.addAll(modelSurfaceInfos.values.filter { it.name.contains(pattern, true) })\n        selectedSurfaces.forEach { it.select() }\n    }\n\n    private fun processCommand(command: String) {\n        console.log(command)\n\n        if (command.startsWith(\"g\", ignoreCase = true) || command.startsWith(\"/\")) {\n            val surfaceName = command.substring(1).trim()\n            goToSurface(surfaceName.toUpperCase())\n        }\n    }\n\n    private fun drawAnimationFrame() {\n        if (!uiLocked) {\n            uiControls.update(clock.getDelta())\n        }\n        uiRenderer.render(uiScene, uiCamera)\n\n        window.requestAnimationFrame { drawAnimationFrame() }\n    }\n\n    override fun render(parentNode: HTMLElement) {\n        parentNode.appendChild(screen)\n        resizeTo(parentNode.offsetWidth, heightOrWindowHeight(parentNode))\n\n        parentNode.onresize = {\n            resizeTo(parentNode.offsetWidth, heightOrWindowHeight(parentNode))\n        }\n    }\n\n    private fun heightOrWindowHeight(parentNode: HTMLElement): Int {\n        return if (parentNode.offsetHeight == 0) window.innerHeight else parentNode.offsetHeight\n    }\n\n    override fun onClose() {\n        statusListener?.mapperStatusChanged(false)\n\n        listener.onClose()\n    }\n\n    private val diffCanvasScale = 1 / 3.0\n\n    private fun resizeTo(width: Int, height: Int) {\n        this.width = width\n        this.height = height\n\n        if (!haveCamDimensions) {\n            camWidth = width\n            camHeight = height\n        }\n\n        val scale = min(1f, min((width - 10).toFloat() / camWidth, (height - 10).toFloat() / camHeight))\n        uiWidth = camWidth - 10\n        uiHeight = camHeight - 10\n\n        uiCamera.aspect = uiWidth.toDouble() / uiHeight\n        uiCamera.updateProjectionMatrix()\n\n        uiRenderer.setSize(uiWidth, uiHeight, true)\n        ui3dCanvas.width = uiWidth\n        ui3dCanvas.height = uiHeight\n\n        ui2dCanvas.width = uiWidth\n        ui2dCanvas.height = uiHeight\n        ui2dCanvas.style.transform = \"scale(${scale})\"\n\n        diffCanvas.width = (uiWidth * diffCanvasScale).toInt()\n        diffCanvas.height = (uiHeight * diffCanvasScale).toInt()\n        beforeCanvas.width = (uiWidth * diffCanvasScale).toInt()\n        beforeCanvas.height = (uiHeight * diffCanvasScale).toInt()\n        afterCanvas.width = (uiWidth * diffCanvasScale).toInt()\n        afterCanvas.height = (uiHeight * diffCanvasScale).toInt()\n    }\n\n    override fun addWireframe(sheepModel: SheepModel) {\n        val vertices = sheepModel.vertices.map { v -> Vector3(v.x, v.y, v.z) }.toTypedArray()\n        sheepModel.panels.forEach { panel ->\n            val geom = Geometry()\n            val allFaces = mutableListOf<Face3>()\n            geom.vertices = vertices\n\n            val panelFaces = mutableListOf<Face3>()\n            var faceNormalAcc = Vector3()\n            panel.faces.faces.forEach { face ->\n                val face3 = Face3(face.vertexIds[0], face.vertexIds[1], face.vertexIds[2], Vector3(0, 0, 0))\n                allFaces.add(face3)\n                panelFaces.add(face3)\n\n                // just compute this face's normal\n                geom.faces = arrayOf(face3)\n                geom.computeFaceNormals()\n                faceNormalAcc.add(face3.normal!!)\n            }\n            val surfaceNormal = faceNormalAcc.divideScalar(panel.faces.faces.size.toDouble())\n\n            val panelMaterial = MeshBasicMaterial().apply { color = Color(0, 0, 0) }\n            val mesh = Mesh(geom, panelMaterial)\n            mesh.asDynamic().name = panel.name\n            uiScene.add(mesh)\n\n            val lineMaterial = LineBasicMaterial().apply {\n                color = Color(0f, 1f, 0f)\n                linewidth = 2.0\n            }\n\n            // offset the wireframe by one of the panel's face normals so it's not clipped by the panel mesh\n            panel.lines.forEach { line ->\n                val lineGeom = BufferGeometry()\n                lineGeom.setFromPoints(line.vertices.map { pt ->\n                    Vector3(\n                        pt.x,\n                        pt.y,\n                        pt.z\n                    ) + surfaceNormal\n                }.toTypedArray())\n                wireframe.add(Line(lineGeom, lineMaterial))\n            }\n\n            geom.faces = allFaces.toTypedArray()\n            geom.computeFaceNormals()\n            geom.computeVertexNormals()\n\n            modelSurfaceInfos[panel] = PanelInfo(panel.name, panelFaces, mesh, geom, lineMaterial)\n        }\n\n        uiScene.add(wireframe)\n\n        val originMarker = Mesh(\n            SphereBufferGeometry(1, 32, 32),\n            MeshBasicMaterial().apply { color = Color(0xff0000) })\n        uiScene.add(originMarker)\n\n        val boundingBox = Box3().setFromObject(wireframe)\n        uiControls.fitTo(boundingBox, false)\n    }\n\n    override fun lockUi(): MapperUi.CameraOrientation {\n        uiLocked = true\n        return CameraOrientation.from(uiCamera)\n    }\n\n    override fun unlockUi() {\n        uiLocked = false\n    }\n\n    override fun getVisibleSurfaces(): List<MapperUi.VisibleSurface> {\n        val visibleSurfaces = mutableListOf<MapperUi.VisibleSurface>()\n        val screenBox = getScreenBox()\n        val screenCenter = screenBox.center\n        val cameraOrientation = CameraOrientation.from(uiCamera)\n\n        modelSurfaceInfos.forEach { (panel, panelInfo) ->\n            val panelPosition = panelInfo.geom.vertices[panelInfo.faces[0].a]\n            val dirToCamera = uiCamera.position.clone().sub(panelPosition)\n            dirToCamera.normalize()\n            val angle = panelInfo.faces[0].normal!!.dot(dirToCamera)\n            if (angle > 0) {\n                panelInfo.mesh.updateMatrixWorld()\n\n                val panelBoundingBox = panelInfo.boundingBox.project(uiCamera)\n                val panelBoxOnScreen = calcBoundingBoxOnScreen(panelBoundingBox, screenCenter)\n                panelInfo.boxOnScreen = panelBoxOnScreen\n                if (panelBoxOnScreen.asDynamic().intersectsBox(screenBox)) {\n                    val region = MediaDevices.Region(\n                        panelBoxOnScreen.min.x.roundToInt(),\n                        panelBoxOnScreen.min.y.roundToInt(),\n                        panelBoxOnScreen.max.x.roundToInt(),\n                        panelBoxOnScreen.max.y.roundToInt()\n                    )\n                    visibleSurfaces.add(VisibleSurface(panel, region, panelInfo, cameraOrientation))\n                }\n            }\n        }\n\n        return visibleSurfaces\n    }\n\n    inner class VisibleSurface(\n        override val modelSurface: Model.Surface,\n        override val boxOnScreen: MediaDevices.Region,\n        val panelInfo: PanelInfo,\n        cameraOrientation: CameraOrientation\n    ) : MapperUi.VisibleSurface {\n        private val camera = cameraOrientation.createCamera()\n        private val geom = Geometry()\n        private val material = PointsMaterial().apply {\n            color = Color(0x00FF00)\n            size = 5\n        }\n        private val points = Points().apply {\n            geometry = this@VisibleSurface.geom\n            material = this@VisibleSurface.material\n        }\n        private val pixels = mutableMapOf<Int, VisiblePixel>()\n\n        override fun addPixel(pixelIndex: Int, x: Float, y: Float) {\n            pixels[pixelIndex] = VisiblePixel(pixelIndex, x, y).apply { addToGeom() }\n        }\n\n        override fun translatePixelToPanelSpace(screenX: Float, screenY: Float): Vector2F? {\n            val intersection = findIntersection(screenX, screenY) ?: return null\n\n            val point = panelInfo.toPanelSpace(intersection.point.clone())\n            console.log(\"   ---->\", point.x, point.y, point.z)\n            return Vector2F(point.x.toFloat(), point.y.toFloat())\n        }\n\n        override val pixelsInModelSpace: List<Vector3F?>\n            get() {\n                val vectors = mutableListOf<Vector3F?>()\n                for (i in 0..(pixels.keys.max()!!)) {\n                    val position = pixels[i]?.positionInModel\n                    vectors.add(position?.let {\n                        Vector3F(it.x.toFloat(), it.y.toFloat(), it.z.toFloat())\n                    })\n                }\n                return vectors\n            }\n\n        private fun findIntersection(x: Float, y: Float): Intersect? {\n            val raycaster = Raycaster()\n            val pixelVector = Vector2(\n                x / uiWidth * 2 - 1,\n                -(y / uiHeight * 2 - 1)\n            )\n            raycaster.setFromCamera(pixelVector, camera)\n            var intersections = raycaster.intersectObject(panelInfo.mesh, false)\n            if (intersections.isEmpty()) {\n                intersections = raycaster.intersectObject(uiScene, true)\n                console.log(\"Couldn't find point in ${modelSurface.name}...\", intersections)\n            }\n            if (intersections.isNotEmpty()) {\n                return intersections.first()\n            } else {\n                return null\n            }\n        }\n\n        override fun showPixels() {\n            uiScene.add(points)\n        }\n\n        override fun hidePixels() {\n            uiScene.remove(points)\n        }\n\n        inner class VisiblePixel(val pixelIndex: Int, val cameraX: Float, val cameraY: Float) {\n            private val intersect: Intersect? by lazy { findIntersection(cameraX, cameraY) }\n            val positionInModel = intersect?.point\n\n            fun addToGeom() {\n                if (intersect != null) {\n                    // fill in any missing vertices...\n                    while (geom.vertices.size < pixelIndex) {\n                        geom.vertices[geom.vertices.size] = Vector3(0, 0, 0)\n                    }\n\n                    geom.vertices[pixelIndex] = intersect!!.point\n                }\n            }\n\n            val panelSpaceCoords: Pair<Float, Float>? by lazy {\n                if (positionInModel == null) {\n                    null\n                } else {\n                    panelInfo.toPanelSpace(positionInModel)\n                    positionInModel.x.toFloat() to positionInModel.y.toFloat()\n                }\n            }\n        }\n    }\n\n    data class CameraOrientation(override val cameraMatrix: baaahs.geom.Matrix4, override val aspect: Double) :\n        MapperUi.CameraOrientation {\n        fun createCamera(): PerspectiveCamera {\n            return PerspectiveCamera(45, aspect, 1, 10000).apply {\n                matrix.fromArray(cameraMatrix.elements.toDoubleArray())\n                // Get back position/rotation/scale attributes.\n                matrix.asDynamic().decompose(position, quaternion, scale)\n                updateMatrixWorld()\n            }\n        }\n\n        companion object {\n            fun from(camera: PerspectiveCamera): CameraOrientation {\n                return CameraOrientation(\n                    baaahs.geom.Matrix4(camera.matrix.toArray(js(\"undefined\")).toTypedArray()),\n                    camera.aspect\n                )\n            }\n        }\n    }\n\n    override fun showCandidates(orderedPanels: List<Pair<MapperUi.VisibleSurface, Float>>) {\n        orderedPanels as List<Pair<VisibleSurface, Float>>\n\n        val firstGuess = orderedPanels.first()\n        (firstGuess.first.panelInfo.mesh.material as MeshBasicMaterial).color.r += .25\n\n        table.clear()\n        table.append {\n            table {\n                tr {\n                    th { +\"Panel\" }\n                    th { +\"Centroid dist\" }\n                }\n\n                orderedPanels.subList(0, min(5, orderedPanels.size)).forEach { (visibleSurface, distance) ->\n                    tr {\n                        td { +visibleSurface.modelSurface.name }\n                        td { +\"$distance\" }\n                    }\n                }\n            }\n        }\n    }\n\n    override fun intersectingSurface(\n        x: Int,\n        y: Int,\n        visibleSurfaces: List<MapperUi.VisibleSurface>\n    ): MapperUi.VisibleSurface? {\n        val raycaster = Raycaster()\n        val pixelVector = Vector2(\n            x.toFloat() / uiWidth * 2 - 1,\n            -(y.toFloat() / uiHeight * 2 - 1)\n        )\n        raycaster.setFromCamera(pixelVector, uiCamera)\n        val intersections = raycaster.intersectObject(uiScene, true)\n        if (intersections.isNotEmpty()) {\n            val intersect = intersections.first()\n            return visibleSurfaces.find { it.modelSurface.name == intersect.`object`.name }\n        } else {\n            return null\n        }\n    }\n\n    private fun getScreenBox(): Box2 {\n        return Box2(Vector2(0, 0), Vector2(width, height))\n    }\n\n    private fun calcBoundingBoxOnScreen(box: Box3, screenCenter: Vector2): Box2 {\n        val minX = ((box.min.x * screenCenter.x) + screenCenter.x).toInt()\n        val maxX = ((box.max.x * screenCenter.x) + screenCenter.x).toInt()\n\n        // Invert Y for screen coordinates.\n        val minY = ((-box.max.y * screenCenter.y) + screenCenter.y).toInt()\n        val maxY = ((-box.min.y * screenCenter.y) + screenCenter.y).toInt()\n\n        return Box2(Vector2(minX, minY), Vector2(maxX, maxY))\n    }\n\n    override fun showCamImage(image: Image, changeRegion: MediaDevices.Region?) {\n        if (!haveCamDimensions) {\n            camWidth = image.width\n            camHeight = image.height\n            haveCamDimensions = true\n            resizeTo(width, height)\n        }\n\n        ui2dCtx.resetTransform()\n        CanvasBitmap(ui2dCanvas).drawImage(image)\n\n        changeRegion?.apply {\n            ui2dCtx.lineWidth = 2.0\n            ui2dCtx.strokeStyle = \"#ff0000\"\n            ui2dCtx.strokeRect(x0.toDouble(), y0.toDouble(), width.toDouble(), height.toDouble())\n        }\n    }\n\n    override fun showDiffImage(deltaBitmap: Bitmap, changeRegion: MediaDevices.Region?) {\n        diffCtx.resetTransform()\n        diffCtx.scale(diffCanvasScale, diffCanvasScale)\n        CanvasBitmap(diffCanvas).drawImage(deltaBitmap.asImage())\n\n        changeRegion?.apply {\n            diffCtx.strokeStyle = \"#ff0000\"\n            diffCtx.lineWidth = 1 / diffCanvasScale\n            diffCtx.strokeRect(\n                x0.toDouble(), y0.toDouble(),\n                changeRegion.width.toDouble(), changeRegion.height.toDouble()\n            )\n        }\n    }\n\n    override fun showMessage(message: String) {\n        messageDiv.innerText = message\n        console.log(\"Message:\", message)\n    }\n\n    override fun showMessage2(message: String) {\n        message2Div.innerText = message\n//        console.log(\"Message2:\", message)\n    }\n\n    override fun showBefore(bitmap: Bitmap) {\n        val beforeCanvas = document.body!!.first<HTMLCanvasElement>(\"mapperUi-before-canvas\")\n        val beforeCtx = beforeCanvas.getContext(\"2d\") as CanvasRenderingContext2D\n        beforeCtx.resetTransform()\n        beforeCtx.scale(.3, .3)\n        val renderBitmap: Any = when (bitmap) { // TODO: huh?\n            is NativeBitmap -> bitmap.canvas\n            is CanvasBitmap -> bitmap.canvas\n            else -> bitmap\n        }\n        beforeCtx.drawImage(renderBitmap, 0.0, 0.0)\n    }\n\n    override fun showAfter(bitmap: Bitmap) {\n        val afterCanvas = document.body!!.first<HTMLCanvasElement>(\"mapperUi-after-canvas\")\n        val afterCtx = afterCanvas.getContext(\"2d\") as CanvasRenderingContext2D\n        afterCtx.resetTransform()\n        afterCtx.scale(.3, .3)\n        val renderBitmap = when (bitmap) {\n            is NativeBitmap -> bitmap.canvas\n            is CanvasBitmap -> bitmap.canvas\n            else -> bitmap\n        }\n        afterCtx.drawImage(renderBitmap, 0.0, 0.0)\n    }\n\n    override fun setRedo(fn: (suspend () -> Unit)?) {\n        if (fn == null) {\n            redoFn = null\n        } else {\n            redoFn = {\n                GlobalScope.launch { fn() }\n                redoButton.enabled(false)\n            }\n        }\n        redoButton.enabled(fn != null)\n    }\n\n    override fun showStats(total: Int, mapped: Int, visible: Int) {\n        statsDiv.innerHTML = \"<i class=\\\"fas fa-triangle\\\"></i>Mapped: $mapped / $total<br/>Visible: $visible\"\n    }\n\n    override fun pauseForUserInteraction() {\n        clickedPause()\n    }\n\n    private fun clickedPlay() {\n        showPauseMode(false)\n        listener.onStart()\n    }\n\n    private fun clickedPause() {\n        showPauseMode(true)\n        listener.onPause()\n    }\n\n    private fun showPauseMode(isPaused: Boolean) {\n        pauseButton.enabled(!isPaused)\n        playButton.enabled(isPaused)\n    }\n\n    private fun HTMLButtonElement.enabled(isEnabled: Boolean) {\n        style.opacity = if (isEnabled) \"1\" else \".5\"\n    }\n\n    private fun clickedStop() {\n        listener.onStop()\n    }\n\n    private fun goToSurface(name: String) {\n        val surface = modelSurfaceInfos.keys.find { it.name == name }\n        if (surface != null) {\n            val panelInfo = modelSurfaceInfos[surface]!!\n            panelInfo.geom.computeBoundingBox()\n            val surfaceCenter = panelInfo.center\n            val surfaceNormal = panelInfo.surfaceNormal\n\n            val newCamPosition = surfaceCenter.clone()\n            newCamPosition.add(surfaceNormal.clone().multiplyScalar(100))\n            resetCameraRotation()\n            uiControls.setLookAt(\n                newCamPosition.x, newCamPosition.y, newCamPosition.z,\n                surfaceCenter.x, surfaceCenter.y, surfaceCenter.z, true\n            )\n        }\n    }\n\n    override fun close() {\n    }\n\n    interface StatusListener {\n        fun mapperStatusChanged(isRunning: Boolean)\n    }\n}\n\nprivate val Box2.center: Vector2 get() = max.clone().sub(min).divideScalar(2).add(min)\n\nprivate fun Box3.project(camera: Camera): Box3 {\n    min.project(camera)\n    max.project(camera)\n\n    // Projection may cause min/max to be swapped; correct.\n    if (min.x > max.x) {\n        val temp = min.x; min.x = max.x; max.x = temp\n    }\n    if (min.y > max.y) {\n        val temp = min.y; min.y = max.y; max.y = temp\n    }\n    if (min.z > max.z) {\n        val temp = min.z; min.z = max.z; max.z = temp\n    }\n\n    return this\n}\n\nclass PanelInfo(\n    val name: String,\n    val faces: List<Face3>,\n    val mesh: Mesh,\n    val geom: Geometry,\n    val lineMaterial: LineBasicMaterial\n) {\n    val vertices: Set<Vector3>\n        get() {\n            val v = mutableSetOf<Vector3>()\n            for (face in faces) {\n                v.add(geom.vertices[face.a])\n                v.add(geom.vertices[face.b])\n                v.add(geom.vertices[face.c])\n            }\n            return v\n        }\n\n    val _boundingBox: Box3 by lazy {\n        val boundingBox = Box3()\n        for (vertex in vertices) {\n            boundingBox.expandByPoint(vertex)\n        }\n        boundingBox.translate(mesh.getWorldPosition())\n    }\n\n    val boundingBox get() = _boundingBox.clone()\n\n    private val rotator by lazy { Rotator(surfaceNormal, Vector3(0, 0, 1)) }\n\n    fun toSurfaceNormal(point: Vector3): Vector3 {\n        rotator.rotate(point); return point\n    }\n\n    private val normalBoundingBox: Box3 by lazy {\n        val worldPos = mesh.getWorldPosition()\n        val boundingBox = Box3()\n        for (vertex in vertices) {\n            boundingBox.expandByPoint(toSurfaceNormal(vertex).add(worldPos))\n        }\n        boundingBox\n    }\n\n    private val normalBoundingBoxVolume: Vector3 by lazy {\n        normalBoundingBox.max.clone().sub(normalBoundingBox.min)\n    }\n\n    fun toPanelSpace(point: Vector3): Vector3 {\n        var pt = point.clone()\n        pt = toSurfaceNormal(pt)\n        pt.sub(normalBoundingBox.min)\n        pt.divide(normalBoundingBoxVolume)\n        return pt\n    }\n\n    fun select() {\n        lineMaterial.color.r = 1.0\n        lineMaterial.color.g = 0.0\n    }\n\n    fun deselect() {\n        lineMaterial.color.r = 0.0\n        lineMaterial.color.g = 1.0\n    }\n\n    val center get() = boundingBox.getCenter()\n\n    val isMultiFaced get() = faces.size > 1\n\n    val _surfaceNormal: Vector3 by lazy {\n        val faceNormalSum = Vector3()\n        var totalArea = 0f\n        for (face in faces) {\n            val triangle = Triangle(geom.vertices[face.a], geom.vertices[face.b], geom.vertices[face.c])\n            val faceArea = triangle.asDynamic().getArea() as Float\n            faceNormalSum.addScaledVector(face.normal!!, faceArea)\n            totalArea += faceArea\n        }\n        faceNormalSum.divideScalar(totalArea.toDouble())\n    }\n\n    val surfaceNormal get() = _surfaceNormal.clone()\n\n    var boxOnScreen: Box2? = null\n}","package baaahs\n\nimport org.w3c.dom.Element\nimport org.w3c.dom.HTMLButtonElement\nimport org.w3c.dom.HTMLElement\nimport kotlin.dom.appendElement\nimport kotlin.dom.appendText\n\nclass Launcher(val parentNode: Element) {\n    private val fakeDomContainer = FakeDomContainer()\n\n    fun add(name: String, onLaunch: () -> HostedWebApp): HTMLButtonElement {\n        return parentNode.appendElement(\"button\") {\n            appendText(name)\n\n            (this as HTMLElement).onclick = {\n                console.log(\"Launch $name\", this)\n                fakeDomContainer.createFrame(name, onLaunch())\n            }\n        } as HTMLButtonElement\n    }\n\n}\n","package baaahs\n\nimport org.w3c.dom.*\n\nvar Element.disabled: Boolean\n    get() = getAttribute(\"disabled\") == \"disabled\"\n    set(value) {\n        if (value) {\n            setAttribute(\"disabled\", \"disabled\")\n        } else {\n            removeAttribute(\"disabled\")\n        }\n    }\n\nfun <T> ItemArrayLike<T>.forEach(action: (T) -> Unit) {\n    for (i in 0 until length) {\n        action(item(i)!!)\n    }\n}\n\nfun DOMTokenList.clear() {\n    while (length > 0) {\n        remove(item(0)!!)\n    }\n}\n\n@Suppress(\"UNCHECKED_CAST\")\nfun <T : HTMLElement> HTMLElement.first(className: String) : T = (getElementsByClassName(className)[0] as T?)!!\n\nfun HTMLCanvasElement.context2d() = this.getContext(\"2d\")!! as CanvasRenderingContext2D\n\ninterface HostedWebApp {\n    @JsName(\"render\")\n    fun render(parentNode: HTMLElement)\n\n    @JsName(\"onClose\")\n    fun onClose()\n}\n\ninterface DomContainer {\n    fun createFrame(name: String, hostedWebApp: HostedWebApp): Frame\n\n    interface Frame {\n        @JsName(\"close\")\n        fun close()\n    }\n}\n\nclass FakeDomContainer : DomContainer {\n    override fun createFrame(name: String, hostedWebApp: HostedWebApp): DomContainer.Frame =\n        js(\"document.createFakeClientDevice\")(name, hostedWebApp)\n}","package baaahs\n\nimport baaahs.net.Network\nimport baaahs.proto.Ports\n\nobject WebUi {\n    @JsName(\"createPubSubClient\")\n    fun createPubSubClient(network: Network, pinkyAddress: Network.Address): PubSub.Client =\n        PubSub.Client(network.link(), pinkyAddress, Ports.PINKY_UI_TCP).apply {\n            install(gadgetModule)\n        }\n}","package baaahs.browser\n\nimport baaahs.MediaDevices\nimport baaahs.imaging.Image\nimport baaahs.imaging.VideoElementImage\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.MainScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport org.w3c.dom.HTMLVideoElement\nimport org.w3c.dom.ImageBitmap\nimport org.w3c.dom.events.EventTarget\nimport org.w3c.dom.mediacapture.MediaStream\nimport org.w3c.dom.mediacapture.MediaStreamConstraints\nimport org.w3c.dom.mediacapture.MediaStreamTrack\nimport org.w3c.dom.mediacapture.MediaStreamTrackEvent\nimport kotlin.browser.document\nimport kotlin.browser.window\nimport kotlin.js.Promise\n\nclass RealMediaDevices : MediaDevices, CoroutineScope by MainScope() {\n    override fun getCamera(): MediaDevices.Camera {\n        return object : MediaDevices.Camera {\n            val camPromise: Promise<MediaStream> =\n                window.navigator.mediaDevices.getUserMedia(MediaStreamConstraints(video = js(\"({\" +\n                        \"    width: { min: 1024, ideal: 1280, max: 1920 },\\n\" +\n                        \"    height: { min: 776, ideal: 720, max: 1080 }\\n\" +\n                        \"})\")))\n            lateinit var videoTrack: MediaStreamTrack\n            //            lateinit var imageCapture: ImageCapture\n            val videoEl = document.createElement(\"video\") as HTMLVideoElement\n\n            init {\n                videoEl.autoplay = true\n\n                camPromise.then { stream: MediaStream ->\n                    videoTrack = stream.getVideoTracks()[0]\n//                    imageCapture = ImageCapture(videoTrack)\n                    videoEl.srcObject = stream\n                    videoEl.controls = true\n                    videoEl.play()\n\n                    videoEl.oncanplay = {\n                        println(\"oncanplay\")\n                        launch { capture() }\n                    }\n\n                    videoEl.onended = {\n                        println(\"onended\")\n                    }\n\n                    videoEl.onloadeddata = {\n                        println(\"onloadeddata\")\n                    }\n\n                }.catch { t -> println(\"caught ${t}\") }\n            }\n\n\n            override var onImage: (image: Image) -> Unit = {}\n\n            override fun close() {\n            }\n\n            suspend fun capture() {\n                onImage(VideoElementImage(videoEl))\n\n                delay(50)\n                capture()\n            }\n        }\n    }\n}\n\npublic open external class ImageCapture() : EventTarget {\n    constructor(track: MediaStreamTrack)\n\n    //    constructor(tracks: Array<MediaStreamTrack>)\n    open val id: String\n    open val active: Boolean\n    var onaddtrack: ((MediaStreamTrackEvent) -> dynamic)?\n    var onremovetrack: ((MediaStreamTrackEvent) -> dynamic)?\n    fun getAudioTracks(): Array<MediaStreamTrack>\n    fun getVideoTracks(): Array<MediaStreamTrack>\n    fun getTracks(): Array<MediaStreamTrack>\n    fun getTrackById(trackId: String): MediaStreamTrack?\n    fun addTrack(track: MediaStreamTrack): Unit\n    fun removeTrack(track: MediaStreamTrack): Unit\n    fun clone(): MediaStream\n    fun grabFrame(): Promise<ImageBitmap>\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.dom.mediacapture\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [MediaStream](https://developer.mozilla.org/en/docs/Web/API/MediaStream) to Kotlin\n */\npublic external open class MediaStream() : EventTarget {\n    constructor(stream: MediaStream)\n    constructor(tracks: Array<MediaStreamTrack>)\n    open val id: String\n    open val active: Boolean\n    var onaddtrack: ((MediaStreamTrackEvent) -> dynamic)?\n    var onremovetrack: ((MediaStreamTrackEvent) -> dynamic)?\n    fun getAudioTracks(): Array<MediaStreamTrack>\n    fun getVideoTracks(): Array<MediaStreamTrack>\n    fun getTracks(): Array<MediaStreamTrack>\n    fun getTrackById(trackId: String): MediaStreamTrack?\n    fun addTrack(track: MediaStreamTrack): Unit\n    fun removeTrack(track: MediaStreamTrack): Unit\n    fun clone(): MediaStream\n}\n\n/**\n * Exposes the JavaScript [MediaStreamTrack](https://developer.mozilla.org/en/docs/Web/API/MediaStreamTrack) to Kotlin\n */\npublic external abstract class MediaStreamTrack : EventTarget {\n    open val kind: String\n    open val id: String\n    open val label: String\n    open var enabled: Boolean\n    open val muted: Boolean\n    open var onmute: ((Event) -> dynamic)?\n    open var onunmute: ((Event) -> dynamic)?\n    open val readyState: MediaStreamTrackState\n    open var onended: ((Event) -> dynamic)?\n    open var onoverconstrained: ((Event) -> dynamic)?\n    fun clone(): MediaStreamTrack\n    fun stop(): Unit\n    fun getCapabilities(): MediaTrackCapabilities\n    fun getConstraints(): MediaTrackConstraints\n    fun getSettings(): MediaTrackSettings\n    fun applyConstraints(constraints: MediaTrackConstraints = definedExternally): Promise<Unit>\n}\n\n/**\n * Exposes the JavaScript [MediaTrackSupportedConstraints](https://developer.mozilla.org/en/docs/Web/API/MediaTrackSupportedConstraints) to Kotlin\n */\npublic external interface MediaTrackSupportedConstraints {\n    var width: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var aspectRatio: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var frameRate: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var facingMode: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeMode: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var volume: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleRate: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleSize: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var echoCancellation: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var autoGainControl: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var noiseSuppression: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var latency: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var channelCount: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var deviceId: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var groupId: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaTrackSupportedConstraints(width: Boolean? = true, height: Boolean? = true, aspectRatio: Boolean? = true, frameRate: Boolean? = true, facingMode: Boolean? = true, resizeMode: Boolean? = true, volume: Boolean? = true, sampleRate: Boolean? = true, sampleSize: Boolean? = true, echoCancellation: Boolean? = true, autoGainControl: Boolean? = true, noiseSuppression: Boolean? = true, latency: Boolean? = true, channelCount: Boolean? = true, deviceId: Boolean? = true, groupId: Boolean? = true): MediaTrackSupportedConstraints {\n    val o = js(\"({})\")\n\n    o[\"width\"] = width\n    o[\"height\"] = height\n    o[\"aspectRatio\"] = aspectRatio\n    o[\"frameRate\"] = frameRate\n    o[\"facingMode\"] = facingMode\n    o[\"resizeMode\"] = resizeMode\n    o[\"volume\"] = volume\n    o[\"sampleRate\"] = sampleRate\n    o[\"sampleSize\"] = sampleSize\n    o[\"echoCancellation\"] = echoCancellation\n    o[\"autoGainControl\"] = autoGainControl\n    o[\"noiseSuppression\"] = noiseSuppression\n    o[\"latency\"] = latency\n    o[\"channelCount\"] = channelCount\n    o[\"deviceId\"] = deviceId\n    o[\"groupId\"] = groupId\n\n    return o\n}\n\npublic external interface MediaTrackCapabilities {\n    var width: ULongRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: ULongRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var aspectRatio: DoubleRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var frameRate: DoubleRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var facingMode: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeMode: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var volume: DoubleRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleRate: ULongRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleSize: ULongRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var echoCancellation: Array<Boolean>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var autoGainControl: Array<Boolean>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var noiseSuppression: Array<Boolean>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var latency: DoubleRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var channelCount: ULongRange?\n        get() = definedExternally\n        set(value) = definedExternally\n    var deviceId: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var groupId: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaTrackCapabilities(width: ULongRange? = undefined, height: ULongRange? = undefined, aspectRatio: DoubleRange? = undefined, frameRate: DoubleRange? = undefined, facingMode: Array<String>? = undefined, resizeMode: Array<String>? = undefined, volume: DoubleRange? = undefined, sampleRate: ULongRange? = undefined, sampleSize: ULongRange? = undefined, echoCancellation: Array<Boolean>? = undefined, autoGainControl: Array<Boolean>? = undefined, noiseSuppression: Array<Boolean>? = undefined, latency: DoubleRange? = undefined, channelCount: ULongRange? = undefined, deviceId: String? = undefined, groupId: String? = undefined): MediaTrackCapabilities {\n    val o = js(\"({})\")\n\n    o[\"width\"] = width\n    o[\"height\"] = height\n    o[\"aspectRatio\"] = aspectRatio\n    o[\"frameRate\"] = frameRate\n    o[\"facingMode\"] = facingMode\n    o[\"resizeMode\"] = resizeMode\n    o[\"volume\"] = volume\n    o[\"sampleRate\"] = sampleRate\n    o[\"sampleSize\"] = sampleSize\n    o[\"echoCancellation\"] = echoCancellation\n    o[\"autoGainControl\"] = autoGainControl\n    o[\"noiseSuppression\"] = noiseSuppression\n    o[\"latency\"] = latency\n    o[\"channelCount\"] = channelCount\n    o[\"deviceId\"] = deviceId\n    o[\"groupId\"] = groupId\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaTrackConstraints](https://developer.mozilla.org/en/docs/Web/API/MediaTrackConstraints) to Kotlin\n */\npublic external interface MediaTrackConstraints : MediaTrackConstraintSet {\n    var advanced: Array<MediaTrackConstraintSet>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaTrackConstraints(advanced: Array<MediaTrackConstraintSet>? = undefined, width: dynamic = undefined, height: dynamic = undefined, aspectRatio: dynamic = undefined, frameRate: dynamic = undefined, facingMode: dynamic = undefined, resizeMode: dynamic = undefined, volume: dynamic = undefined, sampleRate: dynamic = undefined, sampleSize: dynamic = undefined, echoCancellation: dynamic = undefined, autoGainControl: dynamic = undefined, noiseSuppression: dynamic = undefined, latency: dynamic = undefined, channelCount: dynamic = undefined, deviceId: dynamic = undefined, groupId: dynamic = undefined): MediaTrackConstraints {\n    val o = js(\"({})\")\n\n    o[\"advanced\"] = advanced\n    o[\"width\"] = width\n    o[\"height\"] = height\n    o[\"aspectRatio\"] = aspectRatio\n    o[\"frameRate\"] = frameRate\n    o[\"facingMode\"] = facingMode\n    o[\"resizeMode\"] = resizeMode\n    o[\"volume\"] = volume\n    o[\"sampleRate\"] = sampleRate\n    o[\"sampleSize\"] = sampleSize\n    o[\"echoCancellation\"] = echoCancellation\n    o[\"autoGainControl\"] = autoGainControl\n    o[\"noiseSuppression\"] = noiseSuppression\n    o[\"latency\"] = latency\n    o[\"channelCount\"] = channelCount\n    o[\"deviceId\"] = deviceId\n    o[\"groupId\"] = groupId\n\n    return o\n}\n\npublic external interface MediaTrackConstraintSet {\n    var width: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var aspectRatio: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var frameRate: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var facingMode: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeMode: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var volume: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleRate: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleSize: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var echoCancellation: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var autoGainControl: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var noiseSuppression: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var latency: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var channelCount: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var deviceId: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var groupId: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaTrackConstraintSet(width: dynamic = undefined, height: dynamic = undefined, aspectRatio: dynamic = undefined, frameRate: dynamic = undefined, facingMode: dynamic = undefined, resizeMode: dynamic = undefined, volume: dynamic = undefined, sampleRate: dynamic = undefined, sampleSize: dynamic = undefined, echoCancellation: dynamic = undefined, autoGainControl: dynamic = undefined, noiseSuppression: dynamic = undefined, latency: dynamic = undefined, channelCount: dynamic = undefined, deviceId: dynamic = undefined, groupId: dynamic = undefined): MediaTrackConstraintSet {\n    val o = js(\"({})\")\n\n    o[\"width\"] = width\n    o[\"height\"] = height\n    o[\"aspectRatio\"] = aspectRatio\n    o[\"frameRate\"] = frameRate\n    o[\"facingMode\"] = facingMode\n    o[\"resizeMode\"] = resizeMode\n    o[\"volume\"] = volume\n    o[\"sampleRate\"] = sampleRate\n    o[\"sampleSize\"] = sampleSize\n    o[\"echoCancellation\"] = echoCancellation\n    o[\"autoGainControl\"] = autoGainControl\n    o[\"noiseSuppression\"] = noiseSuppression\n    o[\"latency\"] = latency\n    o[\"channelCount\"] = channelCount\n    o[\"deviceId\"] = deviceId\n    o[\"groupId\"] = groupId\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaTrackSettings](https://developer.mozilla.org/en/docs/Web/API/MediaTrackSettings) to Kotlin\n */\npublic external interface MediaTrackSettings {\n    var width: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var aspectRatio: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var frameRate: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var facingMode: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeMode: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var volume: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleRate: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var sampleSize: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var echoCancellation: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var autoGainControl: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var noiseSuppression: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var latency: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var channelCount: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var deviceId: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var groupId: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaTrackSettings(width: Int? = undefined, height: Int? = undefined, aspectRatio: Double? = undefined, frameRate: Double? = undefined, facingMode: String? = undefined, resizeMode: String? = undefined, volume: Double? = undefined, sampleRate: Int? = undefined, sampleSize: Int? = undefined, echoCancellation: Boolean? = undefined, autoGainControl: Boolean? = undefined, noiseSuppression: Boolean? = undefined, latency: Double? = undefined, channelCount: Int? = undefined, deviceId: String? = undefined, groupId: String? = undefined): MediaTrackSettings {\n    val o = js(\"({})\")\n\n    o[\"width\"] = width\n    o[\"height\"] = height\n    o[\"aspectRatio\"] = aspectRatio\n    o[\"frameRate\"] = frameRate\n    o[\"facingMode\"] = facingMode\n    o[\"resizeMode\"] = resizeMode\n    o[\"volume\"] = volume\n    o[\"sampleRate\"] = sampleRate\n    o[\"sampleSize\"] = sampleSize\n    o[\"echoCancellation\"] = echoCancellation\n    o[\"autoGainControl\"] = autoGainControl\n    o[\"noiseSuppression\"] = noiseSuppression\n    o[\"latency\"] = latency\n    o[\"channelCount\"] = channelCount\n    o[\"deviceId\"] = deviceId\n    o[\"groupId\"] = groupId\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaStreamTrackEvent](https://developer.mozilla.org/en/docs/Web/API/MediaStreamTrackEvent) to Kotlin\n */\npublic external open class MediaStreamTrackEvent(type: String, eventInitDict: MediaStreamTrackEventInit) : Event {\n    open val track: MediaStreamTrack\n}\n\npublic external interface MediaStreamTrackEventInit : EventInit {\n    var track: MediaStreamTrack?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaStreamTrackEventInit(track: MediaStreamTrack?, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MediaStreamTrackEventInit {\n    val o = js(\"({})\")\n\n    o[\"track\"] = track\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external open class OverconstrainedErrorEvent(type: String, eventInitDict: OverconstrainedErrorEventInit) : Event {\n    open val error: dynamic\n}\n\npublic external interface OverconstrainedErrorEventInit : EventInit {\n    var error: dynamic /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun OverconstrainedErrorEventInit(error: dynamic = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): OverconstrainedErrorEventInit {\n    val o = js(\"({})\")\n\n    o[\"error\"] = error\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaDevices](https://developer.mozilla.org/en/docs/Web/API/MediaDevices) to Kotlin\n */\npublic external abstract class MediaDevices : EventTarget {\n    open var ondevicechange: ((Event) -> dynamic)?\n    fun enumerateDevices(): Promise<dynamic>\n    fun getSupportedConstraints(): MediaTrackSupportedConstraints\n    fun getUserMedia(constraints: MediaStreamConstraints = definedExternally): Promise<MediaStream>\n}\n\n/**\n * Exposes the JavaScript [MediaDeviceInfo](https://developer.mozilla.org/en/docs/Web/API/MediaDeviceInfo) to Kotlin\n */\npublic external abstract class MediaDeviceInfo {\n    open val deviceId: String\n    open val kind: MediaDeviceKind\n    open val label: String\n    open val groupId: String\n    fun toJSON(): dynamic\n}\n\npublic external abstract class InputDeviceInfo : MediaDeviceInfo {\n    fun getCapabilities(): MediaTrackCapabilities\n}\n\n/**\n * Exposes the JavaScript [MediaStreamConstraints](https://developer.mozilla.org/en/docs/Web/API/MediaStreamConstraints) to Kotlin\n */\npublic external interface MediaStreamConstraints {\n    var video: dynamic /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var audio: dynamic /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaStreamConstraints(video: dynamic = false, audio: dynamic = false): MediaStreamConstraints {\n    val o = js(\"({})\")\n\n    o[\"video\"] = video\n    o[\"audio\"] = audio\n\n    return o\n}\n\npublic external interface ConstrainablePattern {\n    var onoverconstrained: ((Event) -> dynamic)?\n    fun getCapabilities(): Capabilities\n    fun getConstraints(): Constraints\n    fun getSettings(): Settings\n    fun applyConstraints(constraints: Constraints = definedExternally): Promise<Unit>\n}\n\n/**\n * Exposes the JavaScript [DoubleRange](https://developer.mozilla.org/en/docs/Web/API/DoubleRange) to Kotlin\n */\npublic external interface DoubleRange {\n    var max: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var min: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DoubleRange(max: Double? = undefined, min: Double? = undefined): DoubleRange {\n    val o = js(\"({})\")\n\n    o[\"max\"] = max\n    o[\"min\"] = min\n\n    return o\n}\n\npublic external interface ConstrainDoubleRange : DoubleRange {\n    var exact: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ideal: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConstrainDoubleRange(exact: Double? = undefined, ideal: Double? = undefined, max: Double? = undefined, min: Double? = undefined): ConstrainDoubleRange {\n    val o = js(\"({})\")\n\n    o[\"exact\"] = exact\n    o[\"ideal\"] = ideal\n    o[\"max\"] = max\n    o[\"min\"] = min\n\n    return o\n}\n\npublic external interface ULongRange {\n    var max: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var min: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ULongRange(max: Int? = undefined, min: Int? = undefined): ULongRange {\n    val o = js(\"({})\")\n\n    o[\"max\"] = max\n    o[\"min\"] = min\n\n    return o\n}\n\npublic external interface ConstrainULongRange : ULongRange {\n    var exact: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ideal: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConstrainULongRange(exact: Int? = undefined, ideal: Int? = undefined, max: Int? = undefined, min: Int? = undefined): ConstrainULongRange {\n    val o = js(\"({})\")\n\n    o[\"exact\"] = exact\n    o[\"ideal\"] = ideal\n    o[\"max\"] = max\n    o[\"min\"] = min\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ConstrainBooleanParameters](https://developer.mozilla.org/en/docs/Web/API/ConstrainBooleanParameters) to Kotlin\n */\npublic external interface ConstrainBooleanParameters {\n    var exact: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ideal: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConstrainBooleanParameters(exact: Boolean? = undefined, ideal: Boolean? = undefined): ConstrainBooleanParameters {\n    val o = js(\"({})\")\n\n    o[\"exact\"] = exact\n    o[\"ideal\"] = ideal\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ConstrainDOMStringParameters](https://developer.mozilla.org/en/docs/Web/API/ConstrainDOMStringParameters) to Kotlin\n */\npublic external interface ConstrainDOMStringParameters {\n    var exact: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var ideal: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConstrainDOMStringParameters(exact: dynamic = undefined, ideal: dynamic = undefined): ConstrainDOMStringParameters {\n    val o = js(\"({})\")\n\n    o[\"exact\"] = exact\n    o[\"ideal\"] = ideal\n\n    return o\n}\n\npublic external interface Capabilities {\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun Capabilities(): Capabilities {\n    val o = js(\"({})\")\n\n\n    return o\n}\n\npublic external interface Settings {\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun Settings(): Settings {\n    val o = js(\"({})\")\n\n\n    return o\n}\n\npublic external interface ConstraintSet {\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConstraintSet(): ConstraintSet {\n    val o = js(\"({})\")\n\n\n    return o\n}\n\npublic external interface Constraints : ConstraintSet {\n    var advanced: Array<ConstraintSet>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun Constraints(advanced: Array<ConstraintSet>? = undefined): Constraints {\n    val o = js(\"({})\")\n\n    o[\"advanced\"] = advanced\n\n    return o\n}\n\n/* please, don't implement this interface! */\npublic external interface MediaStreamTrackState {\n    companion object\n}\npublic inline val MediaStreamTrackState.Companion.LIVE: MediaStreamTrackState get() = \"live\".asDynamic().unsafeCast<MediaStreamTrackState>()\npublic inline val MediaStreamTrackState.Companion.ENDED: MediaStreamTrackState get() = \"ended\".asDynamic().unsafeCast<MediaStreamTrackState>()\n\n/* please, don't implement this interface! */\npublic external interface VideoFacingModeEnum {\n    companion object\n}\npublic inline val VideoFacingModeEnum.Companion.USER: VideoFacingModeEnum get() = \"user\".asDynamic().unsafeCast<VideoFacingModeEnum>()\npublic inline val VideoFacingModeEnum.Companion.ENVIRONMENT: VideoFacingModeEnum get() = \"environment\".asDynamic().unsafeCast<VideoFacingModeEnum>()\npublic inline val VideoFacingModeEnum.Companion.LEFT: VideoFacingModeEnum get() = \"left\".asDynamic().unsafeCast<VideoFacingModeEnum>()\npublic inline val VideoFacingModeEnum.Companion.RIGHT: VideoFacingModeEnum get() = \"right\".asDynamic().unsafeCast<VideoFacingModeEnum>()\n\n/* please, don't implement this interface! */\npublic external interface VideoResizeModeEnum {\n    companion object\n}\npublic inline val VideoResizeModeEnum.Companion.NONE: VideoResizeModeEnum get() = \"none\".asDynamic().unsafeCast<VideoResizeModeEnum>()\npublic inline val VideoResizeModeEnum.Companion.CROP_AND_SCALE: VideoResizeModeEnum get() = \"crop-and-scale\".asDynamic().unsafeCast<VideoResizeModeEnum>()\n\n/* please, don't implement this interface! */\npublic external interface MediaDeviceKind {\n    companion object\n}\npublic inline val MediaDeviceKind.Companion.AUDIOINPUT: MediaDeviceKind get() = \"audioinput\".asDynamic().unsafeCast<MediaDeviceKind>()\npublic inline val MediaDeviceKind.Companion.AUDIOOUTPUT: MediaDeviceKind get() = \"audiooutput\".asDynamic().unsafeCast<MediaDeviceKind>()\npublic inline val MediaDeviceKind.Companion.VIDEOINPUT: MediaDeviceKind get() = \"videoinput\".asDynamic().unsafeCast<MediaDeviceKind>()\n\n","package baaahs.geom\n\nactual class Vector2 actual constructor(x: Double, y: Double) : info.laht.threekt.math.Vector2(x, y) {\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n\n    return o\n}\n\npublic external abstract class WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation {\n}\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int): Unit\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?): Unit\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String): Unit\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?): Unit\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?): Unit\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?): Unit\n    fun bindTexture(target: Int, texture: WebGLTexture?): Unit\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float): Unit\n    fun blendEquation(mode: Int): Unit\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int): Unit\n    fun blendFunc(sfactor: Int, dfactor: Int): Unit\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int): Unit\n    fun bufferData(target: Int, size: Int, usage: Int): Unit\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int): Unit\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?): Unit\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int): Unit\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float): Unit\n    fun clearDepth(depth: Float): Unit\n    fun clearStencil(s: Int): Unit\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean): Unit\n    fun compileShader(shader: WebGLShader?): Unit\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView): Unit\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView): Unit\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int): Unit\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int): Unit\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int): Unit\n    fun deleteBuffer(buffer: WebGLBuffer?): Unit\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?): Unit\n    fun deleteProgram(program: WebGLProgram?): Unit\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?): Unit\n    fun deleteShader(shader: WebGLShader?): Unit\n    fun deleteTexture(texture: WebGLTexture?): Unit\n    fun depthFunc(func: Int): Unit\n    fun depthMask(flag: Boolean): Unit\n    fun depthRange(zNear: Float, zFar: Float): Unit\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?): Unit\n    fun disable(cap: Int): Unit\n    fun disableVertexAttribArray(index: Int): Unit\n    fun drawArrays(mode: Int, first: Int, count: Int): Unit\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int): Unit\n    fun enable(cap: Int): Unit\n    fun enableVertexAttribArray(index: Int): Unit\n    fun finish(): Unit\n    fun flush(): Unit\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?): Unit\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int): Unit\n    fun frontFace(mode: Int): Unit\n    fun generateMipmap(target: Int): Unit\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int): Unit\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float): Unit\n    fun linkProgram(program: WebGLProgram?): Unit\n    fun pixelStorei(pname: Int, param: Int): Unit\n    fun polygonOffset(factor: Float, units: Float): Unit\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int): Unit\n    fun sampleCoverage(value: Float, invert: Boolean): Unit\n    fun scissor(x: Int, y: Int, width: Int, height: Int): Unit\n    fun shaderSource(shader: WebGLShader?, source: String): Unit\n    fun stencilFunc(func: Int, ref: Int, mask: Int): Unit\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int): Unit\n    fun stencilMask(mask: Int): Unit\n    fun stencilMaskSeparate(face: Int, mask: Int): Unit\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int): Unit\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int): Unit\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?): Unit\n    fun texParameterf(target: Int, pname: Int, param: Float): Unit\n    fun texParameteri(target: Int, pname: Int, param: Int): Unit\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?): Unit\n    fun uniform1f(location: WebGLUniformLocation?, x: Float): Unit\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform1i(location: WebGLUniformLocation?, x: Int): Unit\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float): Unit\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int): Unit\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float): Unit\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int): Unit\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float): Unit\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int): Unit\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun useProgram(program: WebGLProgram?): Unit\n    fun validateProgram(program: WebGLProgram?): Unit\n    fun vertexAttrib1f(index: Int, x: Float): Unit\n    fun vertexAttrib1fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib2f(index: Int, x: Float, y: Float): Unit\n    fun vertexAttrib2fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float): Unit\n    fun vertexAttrib3fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float): Unit\n    fun vertexAttrib4fv(index: Int, values: dynamic): Unit\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int): Unit\n    fun viewport(x: Int, y: Int, width: Int, height: Int): Unit\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int8Array.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint8Array.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint8ClampedArray.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Short>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int16Array.set(index: Int, value: Short): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Short>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint16Array.set(index: Int, value: Short): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Int>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int32Array.set(index: Int, value: Int): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Int>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint32Array.set(index: Int, value: Int): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Float>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Float32Array.set(index: Int, value: Float): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Double>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Float64Array.set(index: Int, value: Double): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte): Unit\n    fun setUint8(byteOffset: Int, value: Byte): Unit\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally): Unit\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally): Unit\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally): Unit\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally): Unit\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally): Unit\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally): Unit\n}\n\npublic external @marker interface BufferDataSource {\n}\n\npublic external @marker interface TexImageSource {\n}\n\n","package baaahs.imaging\n\nimport baaahs.MediaDevices\nimport baaahs.context2d\nimport baaahs.first\nimport kotlinx.html.dom.create\nimport kotlinx.html.js.canvas\nimport org.khronos.webgl.Uint8ClampedArray\nimport org.khronos.webgl.get\nimport org.w3c.dom.CanvasRenderingContext2D\nimport org.w3c.dom.HTMLCanvasElement\nimport org.w3c.dom.HTMLVideoElement\nimport org.w3c.dom.ImageBitmap\nimport kotlin.browser.document\n\nactual class NativeBitmap actual constructor(override val width: Int, override val height: Int) :\n    CanvasBitmap(createCanvas(width, height)), Bitmap {\n}\n\nfun createCanvas(width: Int, height: Int) =\n    document.create.canvas {\n        this.width = \"${width}px\"\n        this.height = \"${height}px\"\n    }\n\nopen class CanvasBitmap(internal val canvas: HTMLCanvasElement) : Bitmap {\n    override val width = canvas.width\n    override val height = canvas.height\n\n    internal val ctx = canvas.context2d()\n\n    override fun drawImage(image: Image) = (image as JsImage).draw(ctx, 0, 0)\n\n    override fun drawImage(\n        image: Image,\n        sX: Int, sY: Int, sWidth: Int, sHeight: Int,\n        dX: Int, dY: Int, dWidth: Int, dHeight: Int\n    ) = (image as JsImage).draw(ctx, sX, sY, sWidth, sHeight, dX, dY, dWidth, dHeight)\n\n    override fun copyFrom(other: Bitmap) {\n        assertSameSizeAs(other)\n\n        ctx.resetTransform()\n        ctx.globalCompositeOperation = \"source-over\"\n        ctx.drawImage((other as CanvasBitmap).canvas, 0.0, 0.0)\n        ctx.resetTransform()\n    }\n\n    private fun apply(other: Bitmap, operation: String) {\n        other as CanvasBitmap\n        assertSameSizeAs(other)\n\n        ctx.resetTransform()\n        ctx.globalCompositeOperation = operation\n        ctx.drawImage(other.canvas, 0.0, 0.0)\n        ctx.resetTransform()\n    }\n\n    override fun lighten(other: Bitmap) {\n        apply(other, \"lighten\")\n    }\n\n    override fun darken(other: Bitmap) {\n        apply(other, \"darken\")\n    }\n\n    override fun subtract(other: Bitmap) {\n        apply(other, \"difference\")\n    }\n\n    override fun toDataUrl(): String = canvas.toDataURL(\"image/webp\")\n\n    override fun withData(region: MediaDevices.Region, fn: (data: UByteClampedArray) -> Boolean) {\n        val x = region.x0.toDouble()\n        val y = region.y0.toDouble()\n        val width = region.width.toDouble()\n        val height = region.height.toDouble()\n        val imageData = ctx.getImageData(x, y, width, height)\n        if (fn(JsUByteClampedArray(imageData.data))) {\n            ctx.putImageData(imageData, x, y, x, y, width, height)\n        }\n    }\n\n    override fun asImage(): Image {\n        return object : JsImage() {\n            override val width = this@CanvasBitmap.width\n            override val height = this@CanvasBitmap.height\n            override fun toBitmap(): Bitmap = this@CanvasBitmap\n\n            override fun draw(ctx: CanvasRenderingContext2D, x: Int, y: Int) {\n                ctx.drawImage(canvas, 0.0, 0.0)\n            }\n\n            override fun draw(\n                ctx: CanvasRenderingContext2D,\n                sX: Int, sY: Int, sWidth: Int, sHeight: Int,\n                dX: Int, dY: Int, dWidth: Int, dHeight: Int\n            ) {\n                ctx.drawImage(\n                    canvas,\n                    sX.toDouble(), sY.toDouble(), sWidth.toDouble(), sHeight.toDouble(),\n                    dX.toDouble(), dY.toDouble(), dWidth.toDouble(), dHeight.toDouble()\n                )\n            }\n        }\n    }\n\n    override fun clone(): Bitmap {\n        val newCanvas = document.createElement(\"canvas\") as HTMLCanvasElement\n        newCanvas.width = canvas.width\n        newCanvas.height = canvas.height\n        val ctx = newCanvas.getContext(\"2d\") as CanvasRenderingContext2D\n        ctx.drawImage(canvas, 0.0, 0.0)\n        return CanvasBitmap(newCanvas)\n    }\n\n    private fun assertSameSizeAs(other: Bitmap) {\n        if (width != other.width || height != other.height) {\n            throw IllegalArgumentException(\n                \"other bitmap is not the same size\" +\n                        \" (${width}x${height} != ${other.width}x${other.height})\"\n            )\n        }\n    }\n}\n\nabstract class JsImage : Image {\n    abstract fun draw(ctx: CanvasRenderingContext2D, x: Int, y: Int)\n\n    abstract fun draw(\n        ctx: CanvasRenderingContext2D,\n        sX: Int, sY: Int, sWidth: Int, sHeight: Int,\n        dX: Int, dY: Int, dWidth: Int, dHeight: Int\n    )\n}\n\nclass ImageBitmapImage(private val imageBitmap: ImageBitmap) : JsImage() {\n    override val width = imageBitmap.width\n    override val height = imageBitmap.height\n\n    override fun toBitmap(): Bitmap {\n        val bitmap = NativeBitmap(imageBitmap.width, imageBitmap.height)\n        bitmap.drawImage(this)\n        return bitmap\n    }\n\n    override fun draw(ctx: CanvasRenderingContext2D, x: Int, y: Int) {\n        ctx.drawImage(imageBitmap, 0.0, 0.0)\n    }\n\n    override fun draw(\n        ctx: CanvasRenderingContext2D,\n        sX: Int, sY: Int, sWidth: Int, sHeight: Int,\n        dX: Int, dY: Int, dWidth: Int, dHeight: Int\n    ) {\n        ctx.drawImage(\n            imageBitmap,\n            sX.toDouble(), sY.toDouble(), sWidth.toDouble(), sHeight.toDouble(),\n            dX.toDouble(), dY.toDouble(), dWidth.toDouble(), dHeight.toDouble()\n        )\n    }\n}\n\nclass VideoElementImage(private val videoEl: HTMLVideoElement) : JsImage() {\n    override val width get() = videoEl.videoWidth\n    override val height get() = videoEl.videoHeight\n\n    override fun toBitmap(): Bitmap {\n        val bitmap = NativeBitmap(videoEl.videoWidth, videoEl.videoHeight)\n        bitmap.drawImage(this)\n        return bitmap\n    }\n\n    override fun draw(ctx: CanvasRenderingContext2D, x: Int, y: Int) {\n        ctx.drawImage(videoEl, 0.0, 0.0)\n    }\n\n    override fun draw(\n        ctx: CanvasRenderingContext2D,\n        sX: Int, sY: Int, sWidth: Int, sHeight: Int,\n        dX: Int, dY: Int, dWidth: Int, dHeight: Int\n    ) {\n        ctx.drawImage(\n            videoEl,\n            sX.toDouble(), sY.toDouble(), sWidth.toDouble(), sHeight.toDouble(),\n            dX.toDouble(), dY.toDouble(), dWidth.toDouble(), dHeight.toDouble()\n        )\n    }\n}\n\nclass JsUByteClampedArray(val delegate: Uint8ClampedArray) : UByteClampedArray {\n    override val size: Int get() = delegate.length\n\n    override operator fun get(index: Int): Int {\n        return delegate[index].toInt()\n    }\n\n    override operator fun set(index: Int, value: UByte) {\n        delegate.asDynamic()[index] = value\n    }\n}","package baaahs\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.promise\nimport org.w3c.xhr.XMLHttpRequest\nimport kotlin.js.Date\n\nactual fun doRunBlocking(block: suspend () -> Unit) {\n    GlobalScope.promise { block() }\n    return\n}\n\nactual fun getResource(name: String): String {\n    val xhr = XMLHttpRequest()\n    xhr.open(\"GET\", name, false)\n    xhr.send()\n\n    if (xhr.status.equals(200)) {\n        return xhr.responseText\n    }\n\n    throw Exception(\"failed to load resource ${name}: ${xhr.status} ${xhr.responseText}\")\n}\n\nactual fun getTimeMillis(): Long = Date.now().toLong()\n\nactual fun decodeBase64(s: String): ByteArray {\n    TODO(\"decodeBase64 not implemented\")\n}\n","package baaahs.net\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.Int8Array\nimport org.khronos.webgl.get\nimport org.w3c.dom.ARRAYBUFFER\nimport org.w3c.dom.BinaryType\nimport org.w3c.dom.WebSocket\n\n/**\n * Uses WebSockets for TCP, and proxies UDP via Pinky.\n */\nclass BrowserNetwork(private val udpProxyAddress: BrowserAddress? = null, private val udpProxyPort: Int = 0) : Network {\n    override fun link(): Network.Link = object : Network.Link {\n        override val myAddress: Network.Address = object : Network.Address {}\n\n        var udpProxy: BrowserUdpProxy? = null\n        init {\n            udpProxyAddress?.let {\n                udpProxy = BrowserUdpProxy(this, it, udpProxyPort)\n            }\n        }\n\n        override val udpMtu = 1500\n\n        override fun listenUdp(port: Int, udpListener: Network.UdpListener): Network.UdpSocket {\n            return udpProxy!!.listenUdp(port, udpListener)\n        }\n\n        override fun startHttpServer(port: Int): Network.HttpServer =\n            TODO(\"BrowserNetwork.startHttpServer not implemented\")\n\n        override fun connectWebSocket(\n            toAddress: Network.Address,\n            port: Int,\n            path: String,\n            webSocketListener: Network.WebSocketListener\n        ): Network.TcpConnection {\n            val webSocket = WebSocket((toAddress as BrowserAddress).urlString.trimEnd('/') + path)\n            webSocket.binaryType = BinaryType.ARRAYBUFFER\n\n            val tcpConnection = object : Network.TcpConnection {\n                override val fromAddress: Network.Address = myAddress\n                override val toAddress: Network.Address = myAddress\n                override val port: Int get() = port\n\n                override fun send(bytes: ByteArray) {\n                    webSocket.send(Int8Array(bytes.toTypedArray()))\n                }\n            }\n\n            webSocket.onopen = {\n                console.log(\"WebSocket open!\", it)\n                webSocketListener.connected(tcpConnection)\n            }\n\n            webSocket.onmessage = {\n                // TODO: be less woefully inefficient...\n                val buf = it.data as ArrayBuffer\n                val byteBuf = Int8Array(buf)\n                val bytes = ByteArray(byteBuf.length)\n                for (i in 0 until byteBuf.length) {\n                    bytes[i] = byteBuf[i]\n                }\n                webSocketListener.receive(tcpConnection, bytes)\n            }\n\n            webSocket.onerror = { console.error(\"WebSocket error!\", it) }\n            webSocket.onclose = { console.error(\"WebSocket close!\", it) }\n\n            return tcpConnection\n        }\n    }\n\n    class BrowserAddress(val urlString: String) : Network.Address\n\n}","package baaahs.net\n\nimport baaahs.Logger\nimport baaahs.getTimeMillis\nimport baaahs.io.ByteArrayReader\nimport baaahs.io.ByteArrayWriter\n\ninternal class BrowserUdpProxy(\n    link: Network.Link, address: BrowserNetwork.BrowserAddress, port: Int\n) : Network.WebSocketListener {\n    private var udpListener: Network.UdpListener? = null\n\n    val tcpConnection = link.connectWebSocket(address, port, \"/sm/udpProxy\", this)\n    var connected: Boolean = false\n    val toSend = mutableListOf<ByteArray>()\n\n    override fun connected(tcpConnection: Network.TcpConnection) {\n        connected = true\n\n        toSend.forEach { tcpConnection.send(it) }\n        toSend.clear()\n    }\n\n    override fun receive(tcpConnection: Network.TcpConnection, bytes: ByteArray) {\n        try {\n            if (bytes.isEmpty()) return\n\n            ByteArrayReader(bytes).apply {\n                val op = readByte()\n                when (op) {\n                    Network.UdpProxy.RECEIVE_OP.toByte() -> {\n                        val fromAddress = UdpProxyAddress(readBytes())\n                        val fromPort = readInt()\n                        val data = readBytes()\n                        log(\"UDP: Received ${data.size} bytes ${msgId(data)} from $fromAddress:$fromPort\")\n                        udpListener!!.receive(fromAddress, fromPort, data)\n                    }\n                    else -> {\n                        log(\"UDP: Huh? unknown op $op: $bytes\")\n                    }\n                }\n            }\n        } catch (e: Exception) {\n            logger.error(\"Error receiving WebSocket command\", e)\n            throw e\n        }\n    }\n\n    override fun reset(tcpConnection: Network.TcpConnection) {\n        TODO(\"UdpProxy.reset not implemented\")\n    }\n\n    fun listenUdp(port: Int, udpListener: Network.UdpListener): Network.UdpSocket {\n        if (this.udpListener != null) {\n            throw IllegalStateException(\"UDP proxy is already listening\")\n        }\n\n        this.udpListener = udpListener\n\n        if (port != 0) {\n            throw IllegalArgumentException(\"UDP proxy can't listen on a specific port, sorry!\")\n        }\n\n        tcpConnectionSend(ByteArrayWriter().apply {\n            writeByte(Network.UdpProxy.LISTEN_OP.toByte())\n            log(\"UDP: Listen\")\n        }.toBytes())\n\n        return UdpSocketProxy(port)\n    }\n\n    inner class UdpSocketProxy(requestedPort: Int) : Network.UdpSocket {\n        override val serverPort = requestedPort // TODO: this is probably wrong\n\n        override fun sendUdp(toAddress: Network.Address, port: Int, bytes: ByteArray) {\n            if (toAddress !is UdpProxyAddress) {\n                throw IllegalArgumentException(\"UDP proxy can't send to $toAddress!\")\n            }\n\n            tcpConnectionSend(ByteArrayWriter().apply {\n                writeByte(Network.UdpProxy.SEND_OP.toByte())\n                writeBytes(toAddress.bytes)\n                writeInt(port)\n                writeBytes(bytes)\n                log(\"UDP: Sent ${bytes.size} bytes ${msgId(bytes)} to $toAddress:$port\")\n            }.toBytes())\n        }\n\n        override fun broadcastUdp(port: Int, bytes: ByteArray) {\n            tcpConnectionSend(ByteArrayWriter().apply {\n                writeByte(Network.UdpProxy.BROADCAST_OP.toByte())\n                writeInt(port)\n                writeBytes(bytes)\n                log(\"UDP: Broadcast ${bytes.size} bytes ${msgId(bytes)} to *:$port\")\n            }.toBytes())\n        }\n\n    }\n\n    private fun tcpConnectionSend(bytes: ByteArray) {\n        if (connected) {\n            tcpConnection.send(bytes)\n        } else {\n            toSend.add(bytes)\n        }\n    }\n\n    private fun log(s: String) {\n        println(\"[${getTimeMillis()}] $s\")\n    }\n\n    private fun msgId(data: ByteArray): String {\n        return \"msgId=${((data[0].toInt() and 0xff) * 256) or (data[1].toInt() and 0xff)}\"\n    }\n\n    private data class UdpProxyAddress(val bytes: ByteArray) : Network.Address {\n        override fun toString(): String {\n            return bytes.joinToString(\".\") { it.toInt().and(0xff).toString() }\n        }\n\n        override fun equals(other: Any?): Boolean {\n            if (this === other) return true\n            if (other == null || this::class.js != other::class.js) return false\n\n            other as UdpProxyAddress\n\n            if (!bytes.contentEquals(other.bytes)) return false\n\n            return true\n        }\n\n        override fun hashCode(): Int {\n            return bytes.contentHashCode()\n        }\n    }\n\n    companion object {\n        val logger = Logger(\"BrowserUdpProxy\")\n    }\n}","package baaahs.sim\n\nimport baaahs.MediaDevices\nimport baaahs.imaging.Image\nimport baaahs.imaging.ImageBitmapImage\nimport baaahs.visualizer.Visualizer\nimport info.laht.threekt.cameras.Camera\nimport info.laht.threekt.cameras.PerspectiveCamera\nimport info.laht.threekt.renderers.WebGLRenderer\nimport info.laht.threekt.scenes.Scene\nimport org.khronos.webgl.Uint8Array\nimport org.khronos.webgl.Uint8ClampedArray\nimport org.w3c.dom.*\nimport kotlin.browser.window\n\nclass FakeMediaDevices(private val visualizer: Visualizer) : MediaDevices {\n    var currentCam: MediaDevices.Camera? = null\n\n    @JsName(\"getCurrentCam\")\n    fun getCurrentCam() = currentCam\n\n    override fun getCamera(): MediaDevices.Camera {\n        return FakeCamera(640, 480).also {\n            visualizer.addFrameListener(it)\n        }\n    }\n\n    inner class FakeCamera(val width: Int, val height: Int) : MediaDevices.Camera, Visualizer.FrameListener {\n        // offscreen renderer for virtual camera:\n        var camRenderer = WebGLRenderer(js(\"{preserveDrawingBuffer: true}\")).apply {\n            setSize(width, height)\n        }\n\n        private val camCtx = (camRenderer.domElement as HTMLCanvasElement).getContext(\"webgl\")!!\n        private val altCamera = PerspectiveCamera(45, 1.0, 1, 10000)\n        private val pixelBuffer = Uint8ClampedArray(width * height * 4)\n        private val imageData = ImageData(pixelBuffer, width, height)\n\n        override fun onFrameReady(scene: Scene, camera: Camera) {\n            altCamera.copy(camera, true)\n            altCamera.aspect = width.toDouble() / height\n            altCamera.updateProjectionMatrix()\n            camRenderer.render(scene, altCamera)\n\n            camCtx.asDynamic().readPixels(\n                0, 0, width, height, camCtx.asDynamic().RGBA, camCtx.asDynamic().UNSIGNED_BYTE,\n                Uint8Array(pixelBuffer.buffer)\n            )\n\n            window.createImageBitmap(imageData, ImageBitmapOptions().apply {\n                imageOrientation = ImageOrientation.Companion.FLIPY\n            }).then { onImage.invoke(ImageBitmapImage(it)) }\n        }\n\n        override var onImage: (image: Image) -> Unit = { _ -> }\n\n        override fun close() {\n            onImage = { _ -> }\n            visualizer.removeFrameListener(this)\n        }\n    }\n}\n","import org.w3c.dom.Location\n\nexternal fun decodeURIComponent(encodedURI: String): String\n\n\nfun decodeQueryParams(location: Location): Map<String, String> {\n    val query = location.search\n    if (query.startsWith(\"?\")) {\n        return query.substring(1).decodeQueryParams()\n    } else {\n        return emptyMap()\n    }\n}\n\nfun decodeHashParams(location: Location): Map<String, String> {\n    val hash = location.hash\n    if (hash.startsWith(\"#\")) {\n        return hash.substring(1).decodeQueryParams()\n    } else {\n        return emptyMap()\n    }\n}\n\nfun String.decodeQueryParams(): Map<String, String> {\n    return split(\"&\").map {\n        val (k, v) = it.split(\"=\", limit = 2)\n        decodeURIComponent(k) to decodeURIComponent(v)\n    }.toMap()\n}\n","package baaahs.visualizer\n\nimport info.laht.threekt.core.Face3\nimport info.laht.threekt.core.Geometry\nimport info.laht.threekt.math.Line3\nimport info.laht.threekt.math.Matrix4\nimport info.laht.threekt.math.Quaternion\nimport info.laht.threekt.math.Vector3\nimport kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.floor\nimport kotlin.math.sin\nimport kotlin.random.Random\n\nclass SwirlyPixelArranger(private val pixelDensity: Float = 0.2f, private val pixelSpacing : Float = 2f) {\n\n    fun arrangePixels(vizPanel: VizPanel): Array<Vector3> = PanelArranger(vizPanel).arrangePixels()\n\n    inner class PanelArranger(vizPanel: VizPanel) {\n        private val pixelCount = floor(vizPanel.area * pixelDensity).toInt()\n        private val panelGeometry = vizPanel.geometry.clone()\n        private val vertices = panelGeometry.vertices\n        private val isMultiFaced = vizPanel.isMultiFaced\n        private val edgeNeighbors = vizPanel.edgeNeighbors\n\n        fun arrangePixels(): Array<Vector3> {\n            panelGeometry.computeFaceNormals()\n\n            val pixelsGeometry = Geometry()\n\n            val quaternion = Quaternion()\n\n            val panelFaces = panelGeometry.faces\n            var curFace = panelFaces[0]\n            var revertToNormal = curFace.normal!!.clone()\n            val straightOnNormal = Vector3(0, 0, 1)\n            quaternion.setFromUnitVectors(curFace.normal!!, straightOnNormal)\n            val matrix = Matrix4()\n            matrix.makeRotationFromQuaternion(quaternion)\n            panelGeometry.applyMatrix(matrix)\n            pixelsGeometry.applyMatrix(matrix)\n\n            val pos = randomLocation(curFace, vertices)\n            val nextPos = Vector3()\n\n            pixelsGeometry.vertices.asDynamic().push(pos.clone())\n\n            var tries = 1000\n            var angleRad = Random.nextFloat() * 2 * PI\n            var angleRadDelta = Random.nextFloat() * 0.5 - 0.5\n            var pixelsSinceEdge = 0\n            var pixelI = 1\n            while (pixelI < pixelCount) {\n                nextPos.x = pos.x + pixelSpacing * sin(angleRad)\n                nextPos.y = pos.y + pixelSpacing * cos(angleRad)\n                nextPos.z = pos.z\n\n                // console.log(\"cur face: \", this.faceVs(curFace, panelGeometry))\n\n                if (!isInsideFace(curFace, nextPos)) {\n                    val newFace = getFaceForPoint(curFace, nextPos)\n                    if (newFace != null) {\n                        // console.log(\"moving from\", curFace, \"to\", newFace)\n                        // console.log(\"prior face vs:\", this.faceVs(curFace, panelGeometry))\n\n                        quaternion.setFromUnitVectors(straightOnNormal, revertToNormal)\n                        matrix.makeRotationFromQuaternion(quaternion)\n                        panelGeometry.applyMatrix(matrix)\n                        pixelsGeometry.applyMatrix(matrix)\n                        nextPos.applyMatrix4(matrix)\n\n                        curFace = newFace\n                        revertToNormal = curFace.normal!!.clone()\n                        quaternion.setFromUnitVectors(curFace.normal!!, straightOnNormal)\n                        matrix.makeRotationFromQuaternion(quaternion)\n                        panelGeometry.applyMatrix(matrix)\n                        pixelsGeometry.applyMatrix(matrix)\n                        // console.log(\"pos was\", nextPos)\n                        nextPos.applyMatrix4(matrix)\n                        // console.log(\"pos is now\", nextPos)\n                        // console.log(\"new face vs:\", this.faceVs(newFace, panelGeometry))\n                        nextPos.z = panelGeometry.vertices[newFace.a].z\n                        if (!isInsideFace(curFace, nextPos)) {\n                            // console.log(nextPos, \"is not in\", this.faceVs(curFace, panelGeometry))\n                            nextPos.copy(randomLocation(curFace, vertices))\n                        } else {\n                            // console.log(\"AWESOME\", nextPos, \"is in\", this.faceVs(curFace, panelGeometry))\n                        }\n                    } else {\n                        angleRad = Random.nextFloat() * 2 * PI\n                        if (tries-- < 0) break\n                        pixelsSinceEdge = 0\n                        continue\n                    }\n                }\n\n                // console.log(\"pixel z = \", nextPos.z)\n                pixelsGeometry.vertices.asDynamic().push(nextPos.clone())\n\n                angleRad += angleRadDelta\n                angleRadDelta *= 1 - Random.nextFloat() * 0.2 + 0.1\n\n                // occasional disruption just in case we're in a tight loop...\n                if (pixelsSinceEdge > pixelCount / 10) {\n                    angleRad = Random.nextFloat() * 2 * PI\n                    angleRadDelta = Random.nextFloat() * 0.5 - 0.5\n                    pixelsSinceEdge = 0\n                }\n                pos.copy(nextPos)\n                pixelsSinceEdge++\n\n                pixelI++;\n            }\n\n            quaternion.setFromUnitVectors(straightOnNormal, revertToNormal)\n            matrix.makeRotationFromQuaternion(quaternion)\n            panelGeometry.applyMatrix(matrix)\n            pixelsGeometry.applyMatrix(matrix)\n\n            return pixelsGeometry.vertices\n        }\n\n\n        fun randomLocation(face: Face3, vertices: Array<Vector3>): Vector3 {\n            val v = Vector3().copy(vertices[face.a])\n            v.addScaledVector(Vector3().copy(vertices[face.b]).sub(v), Random.nextFloat())\n            v.addScaledVector(Vector3().copy(vertices[face.c]).sub(v), Random.nextFloat())\n            return v\n        }\n\n        fun isInsideFace(curFace: Face3, v: Vector3): Boolean {\n            val vertices = panelGeometry.vertices\n\n            return isInside(\n                xy(v),\n                arrayOf(\n                    xy(vertices[curFace.a]),\n                    xy(vertices[curFace.b]),\n                    xy(vertices[curFace.c])\n                )\n            )\n        }\n\n        fun isInside(point: VizPanel.Point2, vs: Array<VizPanel.Point2>): Boolean {\n            // ray-casting algorithm based on\n            // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\n            val (x, y) = point\n\n            var inside = false\n\n            var i = 0\n            var j = vs.size - 1\n            while (i < vs.size) {\n                val xi = vs[i].x\n                val yi = vs[i].y\n                val xj = vs[j].x\n                val yj = vs[j].y\n\n                val intersect = ((yi > y) != (yj > y))\n                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n                if (intersect) {\n                    inside = !inside\n                }\n\n                j = i++\n            }\n\n            return inside\n        }\n\n        fun xy(v: Vector3) = VizPanel.Point2(v.x.toFloat(), v.y.toFloat())\n\n        // we've tried to add a pixel that's not inside curFace; figure out which face it corresponds to...\n        internal fun getFaceForPoint(curFace: Face3, v: Vector3): Face3? {\n            if (isMultiFaced) {\n                val vertices = panelGeometry.vertices\n\n                // find the edge closest to v...\n                var closestEdge = arrayOf(-1, -1)\n                var bestDistance = Float.POSITIVE_INFINITY\n                curFace.segments().forEach { edgeVs ->\n                    val closestPointOnEdge = Vector3()\n                    val v0 = edgeVs[0]\n                    val v1 = edgeVs[1]\n                    Line3(vertices[v0], vertices[v1]).closestPointToPoint(v, true, closestPointOnEdge)\n                    val thisDistance = closestPointOnEdge.distanceTo(v).toFloat()\n                    if (thisDistance < bestDistance) {\n                        closestEdge = edgeVs\n                        bestDistance = thisDistance\n                    }\n                }\n\n                val edgeId = closestEdge.asKey()\n                // console.log(\"Closest edge to\", v, \"is\", edgeId, this.edgeNeighbors[edgeId])\n\n                val neighbors = edgeNeighbors[edgeId]\n                val neighbor = neighbors?.filter { f -> f !== curFace } ?: emptyList()\n                if (neighbor.size == 0) {\n                    return null\n                } else if (neighbor.size > 1) {\n//                console.warn(\"Found multiple neighbors for \", this.panel.name, \" edge \", edgeId, \": \", neighbors)\n                }\n\n                // console.log(\"Face for \", v, \"is\", edgeId, neighbor[0])\n                return neighbor[0]\n            }\n            return null\n        }\n    }\n}","package baaahs.visualizer\n\nimport baaahs.*\nimport baaahs.dmx.LixadaMiniMovingHead\nimport baaahs.dmx.Shenzarpy\nimport baaahs.sim.FakeDmxUniverse\nimport info.laht.threekt.cameras.Camera\nimport info.laht.threekt.cameras.PerspectiveCamera\nimport info.laht.threekt.core.Geometry\nimport info.laht.threekt.core.Object3D\nimport info.laht.threekt.external.controls.OrbitControls\nimport info.laht.threekt.geometries.ConeBufferGeometry\nimport info.laht.threekt.geometries.SphereBufferGeometry\nimport info.laht.threekt.materials.LineBasicMaterial\nimport info.laht.threekt.materials.Material\nimport info.laht.threekt.materials.MeshBasicMaterial\nimport info.laht.threekt.materials.PointsMaterial\nimport info.laht.threekt.math.Matrix4\nimport info.laht.threekt.math.Vector2\nimport info.laht.threekt.math.Vector3\nimport info.laht.threekt.objects.Mesh\nimport info.laht.threekt.objects.Points\nimport info.laht.threekt.renderers.WebGLRenderer\nimport info.laht.threekt.scenes.Scene\nimport org.w3c.dom.HTMLDivElement\nimport org.w3c.dom.HTMLInputElement\nimport org.w3c.dom.events.MouseEvent\nimport kotlin.browser.document\nimport kotlin.browser.window\nimport kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.sin\n\nclass Visualizer(sheepModel: SheepModel, private val display: VisualizerDisplay): JsMapperUi.StatusListener {\n\n    private var rotate: Boolean\n        get() = getVizRotationEl().checked\n        set(value) {\n            getVizRotationEl().checked = value\n        }\n\n    var mapperIsRunning = false\n        set(isRunning) {\n            field = isRunning\n\n            vizPanels.forEach { panel -> panel.faceMaterial.transparent = !isRunning }\n\n            if (isRunning) {\n                rotate = false\n            }\n        }\n\n    private val frameListeners = mutableListOf<FrameListener>()\n\n    private val controls: OrbitControls\n    private val camera: PerspectiveCamera\n    private val scene: Scene\n    private val renderer: WebGLRenderer\n    private val geom: Geometry\n\n    private var obj: Object3D = Object3D()\n    private val pointMaterial: Material\n    private val lineMaterial: Material\n    private val panelMaterial: Material\n\n    private val raycaster: Raycaster\n    private var mouse: Vector2? = null\n    private val sphere: Mesh\n\n    private val rendererListeners = mutableListOf<() -> Unit>()\n\n    private var vizPanels = mutableListOf<VizPanel>()\n\n    private var sheepView = document.getElementById(\"sheepView\")!! as HTMLDivElement\n    private val selectionInfo = document.getElementById(\"selectionInfo\")!! as HTMLDivElement\n\n    init {\n        sheepView.addEventListener(\"mousedown\", { event -> onMouseDown(event as MouseEvent) }, false)\n        camera = PerspectiveCamera(45, sheepView.offsetWidth.toDouble() / sheepView.offsetHeight, 1, 10000)\n        camera.position.z = 1000.0\n        controls = OrbitControls(camera, sheepView)\n        controls.minPolarAngle = PI / 2 - .25 // radians\n        controls.maxPolarAngle = PI / 2 + .25 // radians\n\n        scene = Scene()\n        pointMaterial = PointsMaterial().apply { color.set(0xffffff) }\n        lineMaterial = LineBasicMaterial().apply { color.set(0xaaaaaa) }\n        panelMaterial = LineBasicMaterial().apply { color.set(0xaaaaaa); linewidth = 3.0 }\n        scene.add(camera)\n        renderer = WebGLRenderer()\n        renderer.setPixelRatio(window.devicePixelRatio)\n        renderer.setSize(sheepView.offsetWidth, sheepView.offsetHeight)\n        sheepView.appendChild(renderer.domElement)\n        geom = Geometry()\n        raycaster = Raycaster()\n        raycaster.asDynamic().params.Points.threshold = 1\n        sphere = Mesh(\n            SphereBufferGeometry(1, 32, 32),\n            MeshBasicMaterial().apply { color.set(0xff0000) }\n        )\n        scene.add(sphere)\n\n        // convert from SheepModel to THREE\n        sheepModel.vertices.forEach { v ->\n            geom.vertices.asDynamic().push(Vector3(v.x, v.y, v.z))\n        }\n\n        startRender()\n\n        var resizeTaskId: Int? = null\n        window.addEventListener(\"resize\", {\n            if (resizeTaskId !== null) {\n                window.clearTimeout(resizeTaskId!!)\n            }\n\n            resizeTaskId = window.setTimeout({\n                resizeTaskId = null\n                doResize()\n            }, resizeDelay)\n        })\n    }\n\n    fun addFrameListener(frameListener: FrameListener) {\n        frameListeners.add(frameListener)\n    }\n\n    fun removeFrameListener(frameListener: FrameListener) {\n        frameListeners.remove(frameListener)\n    }\n\n    fun onMouseDown(event: MouseEvent) {\n        mouse = Vector2(\n            (event.clientX.toDouble() / sheepView.offsetWidth) * 2 - 1,\n            -(event.clientY.toDouble() / sheepView.offsetHeight) * 2 + 1\n        )\n    }\n\n    fun addPanel(p: SheepModel.Panel): VizPanel {\n        // if (p.name !== '15R') return\n        // if (omitPanels.includes(p.name)) return\n\n        val vizPanel = VizPanel(p, geom, scene)\n        vizPanels.add(vizPanel)\n        return vizPanel\n    }\n\n    fun addMovingHead(movingHead: MovingHead, dmxUniverse: FakeDmxUniverse): VizMovingHead {\n        return VizMovingHead(movingHead, dmxUniverse)\n    }\n\n    inner class VizMovingHead(movingHead: MovingHead, dmxUniverse: FakeDmxUniverse) {\n        private val baseChannel = Config.DMX_DEVICES[movingHead.name]!!\n        private val device = LixadaMiniMovingHead(dmxUniverse.reader(baseChannel, 16) { receivedDmxFrame() })\n        private val geometry = ConeBufferGeometry(50, 1000)\n        private val material = MeshBasicMaterial().apply { color.set(0xffff00) }\n        private val cone = Mesh(geometry, material)\n        private val baseXRotation = PI\n        private val baseYRotation = 0.0\n        private val baseZRotation = 0.0\n\n        init {\n            geometry.applyMatrix(Matrix4().makeTranslation(0.0, -500.0, 0.0))\n            material.transparent = true\n            material.opacity = .75\n            cone.position.set(movingHead.origin.x, movingHead.origin.y, movingHead.origin.z)\n            cone.rotation.x = baseXRotation\n            cone.rotation.y = baseYRotation\n            cone.rotation.z = baseZRotation\n            scene.add(cone)\n        }\n\n        private fun receivedDmxFrame() {\n            material.color.set(device.color.rgb)\n            material.visible = device.dimmer > .1\n\n            cone.rotation.x = baseXRotation + device.tilt\n            cone.rotation.y = baseYRotation\n            cone.rotation.z = baseZRotation\n        }\n    }\n\n    private fun getVizRotationEl() = document.getElementById(\"vizRotation\") as HTMLInputElement\n\n    private fun startRender() {\n        geom.computeBoundingSphere()\n        this.obj = Points().apply { geometry = geom; material = pointMaterial }\n        scene.add(obj)\n        val target = geom.boundingSphere.asDynamic().center.clone()\n        controls.target = target\n        camera.lookAt(target)\n\n        render()\n    }\n\n    private val REFRESH_DELAY = 50 // ms\n\n    fun render() {\n        window.setTimeout(fun() {\n            window.requestAnimationFrame { render() }\n        }, REFRESH_DELAY)\n\n        mouse?.let { mouseClick ->\n            mouse = null\n            raycaster.setFromCamera(mouseClick, camera)\n            val intersections = raycaster.intersectObjects(scene.children, false)\n            intersections.forEach { intersection ->\n                val intersectedObject = intersection.`object`\n                val vizPanel = VizPanel.getFromObject(intersectedObject)\n                vizPanel?.let {\n                    selectionInfo.innerText = \"Selected: \" + vizPanel.name\n                    return@forEach\n                }\n            }\n        }\n\n        if (!mapperIsRunning) {\n            if (getVizRotationEl().checked) {\n                val rotSpeed = .01\n                val x = camera.position.x\n                val z = camera.position.z\n                camera.position.x = x * cos(rotSpeed) + z * sin(rotSpeed)\n                camera.position.z = z * cos(rotSpeed * 2) - x * sin(rotSpeed * 2)\n                camera.lookAt(scene.position)\n            }\n        }\n\n        controls.update()\n\n        val startMs = getTimeMillis()\n        renderer.render(scene, camera)\n        display.renderMs = (getTimeMillis() - startMs).toInt()\n\n        frameListeners.forEach { f -> f.onFrameReady(scene, camera) }\n        rendererListeners.forEach { value -> value() }\n    }\n\n// vector.applyMatrix(object.matrixWorld).project(camera) to get 2d x,y coord\n\n    private val resizeDelay = 100\n\n    private fun doResize() {\n        camera.aspect = sheepView.offsetWidth.toDouble() / sheepView.offsetHeight\n        camera.updateProjectionMatrix()\n        renderer.setSize(sheepView.offsetWidth, sheepView.offsetHeight)\n    }\n\n    override fun mapperStatusChanged(isRunning: Boolean) {\n        mapperIsRunning = isRunning\n    }\n\n    interface FrameListener {\n        @JsName(\"onFrameReady\")\n        fun onFrameReady(scene: Scene, camera: Camera)\n    }\n}\n","package baaahs.visualizer\n\nimport baaahs.Color\nimport baaahs.Pixels\nimport baaahs.SheepModel\nimport baaahs.geom.Vector2\nimport info.laht.threekt.THREE.AdditiveBlending\nimport info.laht.threekt.THREE.FrontSide\nimport info.laht.threekt.THREE.VertexColors\nimport info.laht.threekt.core.BufferGeometry\nimport info.laht.threekt.core.Face3\nimport info.laht.threekt.core.Geometry\nimport info.laht.threekt.core.Object3D\nimport info.laht.threekt.geometries.PlaneBufferGeometry\nimport info.laht.threekt.loaders.TextureLoader\nimport info.laht.threekt.materials.LineBasicMaterial\nimport info.laht.threekt.materials.MeshBasicMaterial\nimport info.laht.threekt.math.Matrix4\nimport info.laht.threekt.math.Triangle\nimport info.laht.threekt.math.Vector3\nimport info.laht.threekt.math.minus\nimport info.laht.threekt.objects.Line\nimport info.laht.threekt.objects.Mesh\nimport info.laht.threekt.scenes.Scene\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.get\nimport org.khronos.webgl.set\nimport org.w3c.dom.get\nimport three.BufferGeometryUtils\nimport three.Float32BufferAttribute\nimport kotlin.browser.document\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.random.Random\n\nclass VizPanel(panel: SheepModel.Panel, private val geom: Geometry, private val scene: Scene) {\n    companion object {\n        private val roundLightTx = TextureLoader().load(\n            \"./visualizer/textures/round.png\",\n            { println(\"loaded!\") },\n            { println(\"progress!\") },\n            { println(\"error!\") }\n        )\n\n        fun getFromObject(object3D: Object3D): VizPanel? =\n            object3D.userData.asDynamic()[\"VizPanel\"] as VizPanel?\n    }\n\n    val name = panel.name\n    internal val geometry = Geometry()\n    var area = 0.0f\n    private var panelNormal: Vector3\n    val isMultiFaced: Boolean\n    internal var edgeNeighbors: Map<String, List<Face3>>\n    private val lineMaterial = LineBasicMaterial().apply { color.set(0xaaaaaa) }\n    internal var faceMaterial: MeshBasicMaterial\n    private var mesh: Mesh\n    private var lines: List<Line>\n    var vizPixels: VizPixels? = null\n        set(value) {\n            field?.removeFromScene(scene)\n            value?.addToScene(scene)\n\n            field = value\n        }\n\n    init {\n        val panelGeometry = this.geometry\n        val panelVertices = panelGeometry.vertices\n\n        val triangle = Triangle() // for computing area...\n\n        val faceAreas = mutableListOf<Float>()\n        panelGeometry.faces = panel.faces.faces.map { face ->\n            val localVerts = face.vertexIds.map { vi ->\n                val v = geom.vertices[vi]\n                var lvi = panelVertices.indexOf(v)\n                if (lvi == -1) {\n                    lvi = panelVertices.size\n                    panelVertices.asDynamic().push(v)\n                }\n                lvi\n            }\n\n            triangle.set(\n                panelVertices[localVerts[0]],\n                panelVertices[localVerts[1]],\n                panelVertices[localVerts[2]]\n            )\n\n            val faceArea = triangle.asDynamic().getArea() as Float\n            faceAreas.add(faceArea)\n            this.area += faceArea\n\n            val normal: Vector3 = document[\"non-existant-key\"]\n            Face3(localVerts[0], localVerts[1], localVerts[2], normal)\n        }.toTypedArray()\n\n        isMultiFaced = panelGeometry.faces.size > 1\n\n        panelGeometry.computeFaceNormals()\n        val faceNormalSum = Vector3()\n        panelGeometry.faces.forEachIndexed { index, face ->\n            val faceArea = faceAreas[index]\n            faceNormalSum.addScaledVector(face.normal!!, faceArea)\n        }\n        panelNormal = faceNormalSum.divideScalar(area.toDouble())\n\n        val edgeNeighbors = mutableMapOf<String, MutableList<Face3>>()\n        panelGeometry.faces.forEach { face ->\n            face.segments().forEach { vs ->\n                val vsKey = vs.asKey()\n                val neighbors = edgeNeighbors.getOrPut(vsKey) { mutableListOf() }\n                neighbors.add(face)\n            }\n        }\n        this.edgeNeighbors = edgeNeighbors\n\n        geom.computeVertexNormals() // todo: why is this here?\n\n        val lines = panel.lines.map { line ->\n            val lineGeo = Geometry()\n            lineGeo.vertices = line.vertices.map { pt -> Vector3(pt.x, pt.y, pt.z) }.toTypedArray()\n            lineGeo\n        }\n\n        this.faceMaterial = MeshBasicMaterial().apply { color.set(0x222222) }\n        this.faceMaterial.side = FrontSide\n        this.faceMaterial.transparent = false\n\n        this.mesh = Mesh(panelGeometry, this.faceMaterial)\n        mesh.asDynamic().name = \"Surface: $name\"\n\n        // so we can get back to the VizPanel from a raycaster intersection:\n        this.mesh.userData.asDynamic()[\"VizPanel\"] = this\n\n        scene.add(this.mesh)\n\n        this.lines = lines.map { line -> Line(line.asDynamic(), lineMaterial) }\n\n        this.lines.forEach { line ->\n            scene.add(line)\n        }\n    }\n\n    class Point2(val x: Float, val y: Float) {\n        operator fun component1() = x\n        operator fun component2() = y\n    }\n\n\n    class VizPixels(vizPanel: VizPanel, val positions: Array<Vector3>) : Pixels {\n        override val size = positions.size\n        private val pixGeometry = BufferGeometry()\n        private val planeGeometry: BufferGeometry\n        private val vertexColorBufferAttr: Float32BufferAttribute\n        private val colorsAsInts = IntArray(size) // store colors as an int array too for Pixels.get()\n\n        init {\n            val positionsArray = Float32Array(size * 3)\n            positions.forEachIndexed { i, v ->\n                positionsArray[i * 3] = v.x.toFloat()\n                positionsArray[i * 3 + 1] = v.y.toFloat()\n                positionsArray[i * 3 + 2] = v.z.toFloat()\n            }\n\n            val positionsBufferAttr = Float32BufferAttribute(positionsArray, 3)\n            pixGeometry.addAttribute(\"position\", positionsBufferAttr)\n\n            vertexColorBufferAttr = Float32BufferAttribute(Float32Array(size * 3 * 4), 3)\n            vertexColorBufferAttr.dynamic = true\n\n            val rotator = Rotator(Vector3(0, 0, 1), vizPanel.panelNormal)\n            planeGeometry = BufferGeometryUtils.mergeBufferGeometries(positions.map { position ->\n                val geometry = PlaneBufferGeometry(2 + Random.nextFloat() * 8, 2 + Random.nextFloat() * 8)\n                rotator.rotate(geometry)\n                geometry.translate(position.x, position.y, position.z)\n                geometry\n            }.toTypedArray())\n            planeGeometry.addAttribute(\"color\", vertexColorBufferAttr)\n        }\n\n        private val pixelsMesh = Mesh(planeGeometry, MeshBasicMaterial().apply {\n            side = FrontSide\n            transparent = true\n            blending = AdditiveBlending\n//            depthFunc = AlwaysDepth\n            depthTest = false\n            depthWrite = false\n            vertexColors = VertexColors\n\n            map = roundLightTx\n        })\n\n        fun addToScene(scene: Scene) {\n            scene.add(pixelsMesh)\n        }\n\n        fun removeFromScene(scene: Scene) {\n            scene.remove(pixelsMesh)\n        }\n\n        override fun get(i: Int): Color {\n            return Color(colorsAsInts[i])\n        }\n\n        override fun set(i: Int, color: Color) {\n            colorsAsInts[i] = color.argb\n\n            val redF = color.redF / 2\n            val greenF = color.greenF / 2\n            val blueF = color.blueF / 2\n\n            val rgb3Buf = vertexColorBufferAttr\n            rgb3Buf.setXYZ(i * 4, redF, greenF, blueF)\n            rgb3Buf.setXYZ(i * 4 + 1, redF, greenF, blueF)\n            rgb3Buf.setXYZ(i * 4 + 2, redF, greenF, blueF)\n            rgb3Buf.setXYZ(i * 4 + 3, redF, greenF, blueF)\n            vertexColorBufferAttr.needsUpdate = true\n        }\n\n        override fun set(colors: Array<Color>) {\n            val maxCount = min(this.size, colors.size)\n            val rgbBuf = vertexColorBufferAttr.array\n            for (i in 0 until maxCount) {\n                colorsAsInts[i] = colors[i].argb\n\n                val pColor = colors[i]\n                rgbBuf[i * 3] = pColor.redF / 2\n                rgbBuf[i * 3 + 1] = pColor.greenF / 2\n                rgbBuf[i * 3 + 2] = pColor.blueF / 2\n            }\n            vertexColorBufferAttr.needsUpdate = true\n        }\n\n        fun getPixelLocationsInModelSpace(vizPanel: VizPanel): Array<Vector3> = positions\n\n        fun getPixelLocationsInPanelSpace(vizPanel: VizPanel): Array<Vector2> {\n            val panelGeom = vizPanel.geometry.clone()\n            val pixGeom = pixGeometry.clone()\n\n            val straightOnNormal = Vector3(0, 0, 1)\n\n            // Rotate to straight on.\n            val rotator = Rotator(vizPanel.panelNormal, straightOnNormal)\n            rotator.rotate(panelGeom)\n            rotator.rotate(pixGeom)\n\n            // Translate and scale pixels to panel space (0f..1f)\n            panelGeom.computeBoundingBox()\n            val boundingBox = panelGeom.boundingBox!!\n            val min = boundingBox.min\n            val size = boundingBox.max - boundingBox.min\n\n            val translate = Matrix4().makeTranslation(-min.x, -min.y, -min.z)\n            panelGeom.applyMatrix(translate)\n            pixGeom.applyMatrix(translate)\n\n            val scale = Matrix4().makeScale(1.0 / size.x, 1.0 / size.y, 1.0)\n            panelGeom.applyMatrix(scale)\n            pixGeom.applyMatrix(scale)\n\n            val pixelVs = mutableListOf<Vector2>()\n            val pixelPositions = pixGeom.getAttribute(\"position\")\n            val array = pixelPositions.array as Float32Array\n            for (i in 0 until pixelPositions.count * 3 step 3) {\n                val v = Vector2(clamp(array[i]).toDouble(), clamp(array[i + 1]).toDouble())\n                pixelVs.add(v)\n            }\n\n            return pixelVs.toTypedArray()\n        }\n\n        fun clamp(f: Float): Float = min(1f, max(f, 0f))\n    }\n\n    fun getPixelLocationsInPanelSpace(): Array<Vector2>? {\n        return vizPixels?.getPixelLocationsInPanelSpace(this)\n    }\n\n    fun getPixelLocationsInModelSpace(): Array<Vector3>? {\n        return vizPixels?.getPixelLocationsInModelSpace(this)\n    }\n}\n","package baaahs.visualizer\n\nimport info.laht.threekt.cameras.Camera\nimport info.laht.threekt.core.*\nimport info.laht.threekt.math.*\n\nfun Face3.segments() = arrayOf(arrayOf(a, b), arrayOf(b, c), arrayOf(c, a))\nfun Array<Int>.asKey() = sorted().joinToString(\"-\")\n\nclass Rotator(val from: Vector3, val to: Vector3) {\n    private val quaternion = Quaternion()\n    private val matrix = Matrix4()\n\n    init {\n        quaternion.setFromUnitVectors(from, to)\n        matrix.makeRotationFromQuaternion(quaternion)\n    }\n\n    fun rotate(vararg geoms: Geometry) {\n        geoms.forEach { it.applyMatrix(matrix) }\n    }\n\n    fun rotate(vararg geoms: BufferGeometry) {\n        geoms.forEach { it.applyMatrix(matrix) }\n    }\n\n    fun rotate(vararg vectors: Vector3) {\n        vectors.forEach { it.applyMatrix4(matrix) }\n    }\n\n    fun invert(): Rotator = Rotator(to, from)\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAiBqD,gB;cAkDnC,yB;;;;;;;;;;;;;;;;eC6oBlB,I;;;;;;;;;;;;;;;;;2BC9pBA,mD;qBCsCA,8C;uBCLA,+C;oBCrEA,qC;;;;2BFkDA,oD;gCGi9BA,yD;oBAAA,6C;sBAAA,0C;6BAAA,mD;;cCnyBsB,yB;;;;;WAoFA,e;YA4IS,uB;YAqBjB,uB;;eAQQ,0B;;;;;;;WAuJJ,sB;;;;;yBDiqBlB,gD;2BA+BA,oD;mBAzaA,4C;qBExyBA,mB;mBCpGA,wB;;;;;;YCiGkB,uB;;;;iCCvFlB,iC;;;;;;;;;;;;qBT4CA,6C;aUgDA,+B;iBCxCA,mC;ePynCA,wC;;;;;;;;gBQ7rCA,oC;;;;;;6CRowDA,wD;;kBStoCA,mC;;;;oBCtmBuC,sB;;;;;;;;;oBC+8CvC,6C;iBAAA,qC;sBA+xUA,+C;;;;WCntXkB,sB;;;;;;;;;;;;;;;;gBC7ClB,K;;;;;;;;;;mBC0B8C,8B;;mBnBi7B9C,qC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBoB13BkB,2B;;mBCiD0B,8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICnIxC,+B;MAAA,kBAA2B,C;IAE3B,0B;MAAA,aAAwB,G;IAPxB,4C;IAGA,oC;IAEA,sC;IAEA,4B;EARe,C;;;MAYP,IAAI,wBAAkB,CAAtB,C;QAAyB,OAAW,G;MACpC,OAAQ,KAAyB,GAAhB,mBAAgB,I;IACrC,C;;;IAGA,iCAAiC,KAAM,MAAN,GAAc,uB;IAC/C,OAAS,0BAA6C,GAAhB,mBAA/B,GAA4D,oB;EACvE,C;;IAGI,iCAAiC,KAAM,MAAN,GAAc,uB;IAC/C,OAAQ,0BAA6C,GAAhB,mB;EACzC,C;;IAKI,WAAI,+BAAkB,KAAlB,IAA2B,G;EAA/B,C;;IAKA,WAAI,8BAAiB,KAAjB,C;EAA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YAAA,KAAO,qBAAP,C;cAAA,gB;;;;YAAiB,gB;4BAAA,gB;gBAAA,kBiB7czB,mB;qBjB6cyB,mB;YAAA,Q;;YAAjB,gB;;;YACA,qBAAS,sBAAa,EAAb,C;;;;;;;;;;;;;;;;;EACb,C;;mBAHA,uD;QAAA,S;aAAA,Q;;aAAA,uB;EAGA,C;;IAEA,wC;IAAA,yB;IAAA,kB;IAAA,4B;EAGA,C;;;;;;;;;;;;;YAFI,uBAAU,iBAAV,C;YACA,gB;4BAAA,kC;gBAAA,kBiBndR,mB;qBjBmdQ,mB;YAAA,Q;;;;;;;;;;;;;;;;;;;;EACJ,C;;mBAHA,iE;QAAA,S;aAAA,Q;;aAAA,uB;EAGA,C;;IAEA,wC;IAAA,yB;IAAA,kB;EAEA,C;;;;;;;;;;;;;YADc,gB;4BAAV,sBAAU,oC;gBAAA,kBiBvdlB,mB;qBjBudkB,mB;YAAA,Q;;;;;;;;;;;;;;;;;;;;EACd,C;;mBAFA,qD;QAAA,S;aAAA,Q;;aAAA,uB;EAEA,C;;IDwlCgB,Q;IAAA,OCrlCZ,kBAAY,ODqlCA,W;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MCplCR,gBAAU,cDolCW,OCplCX,S;;EAElB,C;;IAEA,wC;IAAA,yB;IAAA,kB;IAAA,oB;EAIA,C;;;;;;;;;;;;;YAHI,gB;4BAAA,mB;gBAAA,kBiBjeR,mB;qBjBieQ,mB;YAAA,Q;;;;YACA,gB;4BAAA,gB;gBAAA,kBiBleR,mB;qBjBkeQ,mB;YAAA,Q;;YACA,gB;4BAAA,mB;gBAAA,kBiBneR,mB;qBjBmeQ,mB;YAAA,Q;;;;;;;;;;;;;;;;;;EACJ,C;;mBAJA,iD;QAAA,S;aAAA,Q;;aAAA,uB;EAIA,C;;IAI+D,wC;IAAA,6B;IAAA,yB;IAAA,sC;EAK3D,C;;;;;;;;;;;;;YAJI,gB;;;;;YAAA,KAAO,kCAAP,C;cAAA,gB;;;;YACI,gB;4BAAA,mB;gBAAA,kBiB1ehB,mB;qBjB0egB,mB;YAAA,Q;;YACA,kCAAU,sBAAa,IAAb,EAA0B,uBAAmB,kCAAnB,CAA1B,C;YAFd,gB;;;YAIJ,W;;;;;;;;;;;;;;;;EAAA,C;;IAL2D,yD;qBAAA,2F;UAAA,S;eAAA,Q;;eAAA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;;IAYT,gB;IACf,iD;IACA,6C;IAEA,yC;IASA,6D;EAbJ,C;;;;;MACI,8B;IAAA,C;;MAAA,kC;IAAA,C;;;;;;MACA,4B;IAAA,C;;MAAA,8B;IAAA,C;;;;;;MAEA,0B;IAAA,C;;MAAA,0B;IAAA,C;;;;MAGY,kB;IAAA,C;;;;MAEO,gBAAP,W;MlCmnBL,kBAAS,gB;MAyEA,Q;MAAA,2B;MAAhB,OAAgB,cAAhB,C;QAAgB,yB;QAAM,IkC5rBe,WAAM,IAAN,CAAY,iBlC4rBb,OkC5rB2B,KAAd,ClC4rB3B,C;UAAwB,WAAY,WAAI,OAAJ,C;;MkC5rB9C,OlC6rBL,W;IkC7rBK,C;;;;MAEuC,gB;IAAA,C;;;;MAClB,qB;IAAA,C;;;;;;MACjC,oC;IAAA,C;;MAAA,8C;IAAA,C;;;IAqDI,wB;MACW,wB;MAAA,U;MAAA,2CAAa,KAAb,W;QlC0lCR,kBAAU,gB;QAOD,U;QAAA,wB;QAAhB,OAAgB,gBAAhB,C;UAAgB,2B;UkChmCQ,kB;UlCimCpB,WkCjmCoB,mDlCimCC,OkCjmCD,yDAA8B,W;UlCkmCtC,OAAZ,WAAY,EAAO,IAAP,C;;QkCnmCD,SlCqmCR,W;;;QkCrmCQ,a;MAAA,U;MAAA,8B;QlCyjBR,oBAAS,gB;QAyEA,U;QAAA,0B;QAAhB,OAAgB,gBAAhB,C;UAAgB,6B;UAAM,IkChoBC,ElCgoBa,SkChoBb,WlCgoBa,SkChoBb,sBlCgoBD,C;YAAwB,aAAY,WAAI,SAAJ,C;;QkCloB3C,SlCmoBR,a;;;QkCnoBQ,a;MAAP,OAAO,qCAGA,W;IAJX,C;EAAA,C;;IAlDA,epCqCgD,gB;IoCpChD,apCoCgD,gB;IoCnChD,uBAAmB,qBAAM,SAAN,CAAnB,C;IAEA,mBrCgBoD,oB;IqCfpD,mBrCeoD,oB;IqCX/C,gBADA,MADL,YAAY,kBAAZ,CACK,GAAM,IAAN,E;IlCouCF,kBAAM,iBAAa,mCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;MM9uC0B,U;MN+uCnC,WAAY,WM/uC6C,KAAtB,+BN+uCT,IM/uCS,uBAAsB,CAAO,WN+uCpD,C;;IA2MA,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AAhB,OAAgB,gBAAhB,C;MAAgB,6B;MAAa,S2EjgDjB,SAAY,gBAAY,M;M3EigDP,S2EhgDjB,OAAa,OAAH,GAAe,C;M3EggDR,S2E//CjB,QAAW,QAAQ,C;;EAE3B,C;;I3E6/CY,Q;IAAA,O2E1/CR,e3E0/CQ,W;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;M2E1/CkB,iBAAW,c3E0/ChB,O2E1/CgB,C;;I3E0/C7B,U;IAAA,S2Ez/CR,W3Ey/CQ,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,6B;M2Ez/Cc,iC;MAAA,YAAiB,qB3Ey/ClB,S2Ez/CkB,C;M9E6I/C,sBG42C6B,SH52C7B,EAAS,KAAT,C;;E8E5II,C;;;;;;IA7CmE,iE;EAAA,C;;IAiDnE,0C;IACA,gD;IACA,oD;EAHY,C;;;;;;;;;;;;;IAjDpB,oC;MAAA,mB;;IAAA,6B;EAAA,C;;ICFA,kC;IAA4B,gBAAK,iBAAL,C;EAA5B,C;;IAWe,8C;IAAA,kD;IACH,SAAa,C;EADV,C;;IAIC,YAAY,wBAAY,M;I5EyhDpB,Q;IAAA,O4EvhDJ,0B5EuhDI,W;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MAAa,O4EthDV,QAAH,CAAW,CAAX,S;M5EshDa,O4ErhDV,gBAAO,CAAP,C;M5EqhDU,O4EphDb,aAAG,S5EohDU,O4EphDH,OAAO,KAAjB,EAAyB,CAAzB,C;;IAEJ,uB;EACJ,C;;;;;;IArBJ,kBAAkB,UAAW,mBAAU,OAAV,EAAmB,gBAAY,OAAZ,CAAnB,C;IAE7B,aAAa,6D;IAC8B,gBAAvB,UAAW,Y;I5EkxC5B,kBAAM,iBAAa,mCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;mBACT,W;M4Ev1C2C,kBAA5B,mC5Eu1CW,I4Ev1CX,S;MvEmEnB,WuElEY,SAAQ,CAAR,IAAa,6BAAM,M;M5Es1Cf,YAAZ,WAAY,EKnxCT,WLmxCS,C;;I4Ex1CZ,oB5Ey1CG,W;I4En1CH,sF;EAcJ,C;;;;;;;;IAzBJ,yC;MAAA,wB;;IAAA,kC;EAAA,C;;ICFwC,gBAAK,IAAL,C;EAAjB,C;;IASR,sC;IAAA,kF;IAAA,4C;IAA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AA,Q;;;;YAAyB,gB;4BAAN,wBAAM,U;gBAAA,kBGlFzD,mB;qBHkFyD,mB;YAAA,Q;;YAAzB,OAAyB,a;;;;;;;;;;;;;;;;EAAM,C;;IAAjC,yD;qBAAA,6G;UAAA,S;eAAA,Q;;eAAA,uB;IAAA,C;EAAA,C;;IAUR,wC;IAAA,yB;EAEd,C;;;;;;;;;;;;;YADI,gB;4BAAA,oB;gBAAA,kBG7FZ,mB;qBH6FY,mB;YAAA,Q;;;;YAAA,oB;;;;;;;;;;;;;;;;EACJ,C;;mBAFc,kE;QAAA,S;aAAA,Q;;aAAA,uB;EAEd,C;;IA1DwB,wC;IAAA,yB;IAAA,sD;IAAA,+B;IAAA,4B;IAAA,6B;EA2D5B,C;;;;;;;;;;;;;qCA1DsB,kBAAkB,cAAA,QAAS,SAAT,CAAlB,C;YAEP,OAAX,2CAAW,kBAAO,kEAAP,C;kCAEI,aAAS,cAAA,QAAS,gBAAe,UAAf,CAAT,CAAT,C;mCACf,mBAAS,aAAI,QAAJ,EAAc,oEAAd,C;YAMA,gB;4BAAA,kB;gBAAA,kBGhDjB,mB;qBHgDiB,mB;YAAA,Q;;;;YVgDP,oBUhDuB,Q;YAEzB,mBAAS,aAAI,QAAJ,EAAc,oEAAd,C;YASsB,UAAU,c;YlBkNgC,Q;YkBlNzE,mBRoB2C,SV8L8B,QkBlNtD,sBlBkNsD,WAAI,GAAJ,UU9L9B,GV8L8B,IU9L9B,GQpBgB,KRoBhB,C;YQnBZ,YAAU,c;YlBiNgC,U;YkBjNzE,mBRmB2C,SV8L8B,UkBjNtD,sBlBiNsD,WAAI,KAAJ,UU9L9B,GV8L8B,MU9L9B,GQnBgB,GRmBhB,C;YQlB3C,oBAAoB,wBAAoB,YAApB,EAAkC,YAAlC,C;YACpB,sBAAkB,CAAlB,C;Yf4/CS,oB;YADb,YAAY,C;YACC,SArqBN,Wer1BH,2CAAW,Ofq1BR,iCEjzBI,0E;qBapCsC,c;YAAlB,CboCpB,EFizBJ,EAqqBM,W;YAAb,OAAa,gBAAb,C;cAAa,wB;ce1/CyD,wD;cf0/CnD,cAAO,oBAAmB,gBAAnB,EAAmB,wBAAnB,Y;ce1+CiB,U;cAbnC,eAAe,gCAAW,kBfu/CqB,Iev/CrB,C;cAC1B,qBAAmC,oCAAc,QAAd,C;cACnC,qBAA8B,uBAAU,Q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"}